## 7

![images](images/threesquare.jpg)

## 安全性和成员资格

web 应用程序设计中的一个常见要求是，web 站点的某些部分只对某些特权用户可用。实际上，这通常是通过让用户登录站点来确定他们的身份来实现的；这个过程被称为*认证*。

一旦用户的身份被确定，他们就可以访问他们的用户帐户所允许的网站部分；这就是所谓的*成员资格*。

在本章中，我们将看到如何使用 WebMatrix `WebSecurity` helper 来实现网站中的认证和成员功能。我们将学习如何将网站的区域限制为个人和经过身份验证的用户组，如何允许新用户注册帐户，以及如何允许现有用户登录、更改和重置密码。

会员系统将其数据存储在一组数据库表中。我们将了解 WebMatrix 如何在现有数据库中为我们生成这些表格，以及如何将其他来源的现有用户数据插入系统。我们还将看到一个示例，展示如何提供页面来执行用户管理，以及如何将用户信息安全地存储在数据库中。

### 设置网络安全助手

为了使用`WebSecurity`助手，它必须首先在代码中初始化。为此，我们需要调用`WebSecurity.InitializeDatabaseConnection()`方法，传入一些初始值。在第一次与助手交互之前，可以随时调用`InitializeDatabaseConnection()`方法。在大多数情况下，最好是在应用程序初始启动时将它放在站点的`_AppStart.cshtml`文件中。

`InitializeDatabaseConnection()`方法有一个包含五个参数的签名和一个包含六个参数的重载:

`public static void InitializeDatabaseConnection(
        string connectionStringName,
        string userTableName,
        string userIdColumn,
        string userNameColumn,
        bool autoCreateTables
)

public static void InitializeDatabaseConnection(
        string connectionStringName,
        string providerName,` `        string userTableName,
        string userIdColumn,
        string userNameColumn,
        bool autoCreateTables
)`

表 7-1 详细解释了这些参数。

![images](images/t0701.jpg)

WebSecurity helper 的灵活性是其主要特性和优势之一。该助手既可以使用自己的专有数据库表，也可以轻松配置为与任何现有数据集成。

例如，许多公司已经拥有员工信息，这些信息可以作为会员系统的基础。通过将助手指向现有的数据库，以及用户 id 和用户名的相关列，可以最大限度地减少数据重复。

![images](images/square.jpg) **提示**ASP.NET 提供了一个`ActiveDirectoryMembershipProvider`类，尽管这已经超出了本章的范围，但它可以与 ASP.NET 网页一起使用，根据 Windows Active Directory 系统对用户进行身份验证。我们可以在 MSDN 网站上找到更多相关信息:http://msdn . Microsoft . com/en-us/library/system . web . security . activedirectorymembershipprovider . aspx

网络安全助手区分*档案*和*会员*数据。用户配置文件数据是用户名和 ID，以及我们希望存储的关于用户的任何其他个人信息(电子邮件地址、联系电话、出生日期等)。).成员资格数据是成员资格系统认证和管理该特定系统的用户所需的安全信息(密码、上次密码更改日期、应用程序角色等)。).简档和成员数据之间的这种分离使得帮助者能够处理我们当前的用户数据——我们现有的数据提供了系统的简档部分。

让我们创建一个新站点来演示 WebMatrix 会员系统。使用空网站模板创建一个新网站，并添加一个名为 MembershipExample.sdf 的空白数据库，将名为 _AppStart.cshtml 的文件添加到网站的根目录，并用以下内容替换默认标记:

`@{
  WebSecurity.InitializeDatabaseConnection("MembershipExample",
     "UserProfile", "UserId", "UserName", true);
}`

接下来，将名为 default.cshtml 的 C # ASP.NET 网页添加到站点的根目录，这将是我们的主页，并将生成的标记修改为如下所示:

`<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Home Page</title>
    </head>
    <body>
        <h1>Home Page</h1>
        <p>
            Welcome to the Home Page of the Membership Example site.
        </p>
    </body>
</html>`

当我们第一次运行这个站点时，我们会看到`_AppStart.cshtml`文件中的`InitializeDatabaseConnection()`方法调用已经在`MembershipExample.sdf`数据库中创建了四个表，如图 7-1 中的[所示。](#fig_7_1)

![images](images/0701.jpg)

***图 7-1。**通过 InitializeDatabaseConnection()方法添加的数据库表*

`UserProfile`表只包含方法调用中指定的两列:`UserID`和`UserName`。只要不改变这两列的定义，我们就可以定制这个表来包含关于用户的附加个人信息。

`webpages_Membership`表包含助手所需的所有详细的成员和安全信息。

助手使用`webpages_Roles`表来定义可用于创建用户组的角色。该表与`webpages_UsersInRoles`表结合使用，后者将用户链接到角色。角色将在本章后面深入讨论。

![images](images/square.jpg) **注意**对会员系统使用的四个数据库表的现有模式进行更改可能会产生严重后果，可能会导致我们网站的会员功能完全失效。唯一经常更改的表是 UserProfile 表，它可以添加额外的列来存储额外的用户信息。本章后面的“存储附加用户信息”一节将详细介绍这一过程。

既然会员系统已经初始化，我们可以继续并实现一个注册页面，这将允许新用户在我们的会员数据库中创建帐户。

### 创建新的用户注册页面

在我们的用户注册页面上，我们将提供一个包含用户名文本框和两个密码文本框的表单——这是此类页面的标准设计。当用户提交表单时，我们将检查使用该用户名的帐户是否已经存在，以及两个密码文本框的值是否匹配。如果这两个条件都满足，我们将注销任何当前用户，创建新帐户，让新用户登录，并显示一条成功消息。

在我们站点的根目录下创建一个名为 register.cshtml 的新页面，并添加以下标记，该标记显示一个注册表单:

`**@{**
**    var username = "";**
**    var password1 = "";**
**    var password2 = "";**
**}**
<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>**Register**</title>
    </head>
    <body>
**        <h1>Register</h1>**
**        <form action="register" method="post">**
**            <div>**
**                @Html.Label("Username: ", "username")<br />**
**                @Html.TextBox("username", username)**
**            </div>**
**            <div>**
**                @Html.Label("Password: ", "password1")<br />**
**                @Html.Password("password1", password1)**
**            </div>**
**            <div>**
**                @Html.Label("Confirm Password: ", "password2")<br />**
**                @Html.Password("password2", password2)**
**            </div>**
**            <div>**
**                 <input type="submit" value="Register" />**
            </div>
**        </form>**
    </body>
</html>`

接下来，将代码添加到要在回发时运行的页面顶部的块中。该代码将执行以下操作:

*   注销任何当前用户(通过`WebSecurity.Logout()`方法)。
*   检查表单中提交的用户名是否已经存在(通过`WebSecurity.UserExists()`方法)。
*   比较两个密码文本框的值，确保它们匹配。

最后，如果所有的验证都通过了，我们将调用`WebSecurity.CreateUserAndAccount()`方法在数据库中插入新的帐户，让用户登录，并将他们返回到默认页面。

`@{
    var username = "";
    var password1 = "";
    var password2 = "";

    if(IsPost)
    {
        WebSecurity.Logout();

        username = Request["username"];
        password1 = Request["password1"];
        password2 = Request["password2"];

        // Validation
        if (username.IsEmpty()) {
            ModelState.AddError("username", "Username is required.");
        }

        if (password1.IsEmpty()) {
            ModelState.AddError("password1", "Password is required.");
        }

        if(WebSecurity.UserExists(username))
        {
            ModelState.AddError("username", "An account with this name already exists.");
        }

        if(password1 != password2)
        {
            ModelState.AddError("password1", "The passwords do not match.");
        }

        // Create Account
        if(ModelState.IsValid)
        {
            WebSecurity.CreateUserAndAccount(username, password1, null, false);
            WebSecurity.Login(username, password1);
            Response.Redirect("default");
        }
    }
}`

在这段代码中，我们对 WebSecurity 助手进行了四次方法调用:`Logout()`、`UserExists()`、`CreateUserAndAccount()`和`Login()`。

Logout()方法不接受任何参数，只是注销任何当前用户。如果我们在没有登录用户的情况下调用`Logout()`方法，将不会显示任何错误消息，所以在调用之前没有必要检查这一点。

`UserExists()`方法查询配置文件和成员数据库，看是否能找到一个记录，该记录的用户名与传入的参数相匹配。如果找到匹配的记录，该方法返回`true`，否则返回`false`。

一旦我们确定帐户不存在，我们就向`CreateUserAndAccount()`方法传递要创建的帐户的用户名和密码，然后调用`Login()`方法，再次传递用户名和密码。

![images](images/square.jpg) **提示**`CreateUserAndAccount()`方法也可以用来存储用户的附加信息。这将在本章后面的“存储附加用户信息”一节中解释。

最后，我们需要向页面添加一些代码和标记，以显示任何验证错误的结果。

`<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Register</title>
        **<style>**
**            .validation-summary-errors,**
**            span.field-validation-error { color: #FF0000; }**
**            input.field-validation-error { border: 1px solid #FF0000;**
**                                           background-color: #FFCCCC; }**
**        </style>**
    </head>
    <body>
        <h1>Register</h1>
**        @Html.ValidationSummary("Unable to create account. Please correct the following:")**
        <form action="register" method="post">
            <div>
                @Html.Label("Username: ", "username")<br />
                @Html.TextBox("username", username)
**                @Html.ValidationMessage("username")**
            </div>
            <div>
                @Html.Label("Password: ", "password1")<br />
                @Html.Password("password1", password1)
**                @Html.ValidationMessage("password1")**
            </div>
            <div>
                @Html.Label("Confirm Password: ", "password2")<br />
                @Html.Password("password2", password2)
            </div>
            <div>
                 <input type="submit" value="Register" />
            </div>
        </form>
    </body>
</html>`

当 register.cshtml 页面运行时，用户将看到如图 7-2 所示的表单:

![images](images/0702.jpg)

***图 7-2。**新账户注册页面*

当一个帐户成功注册后，用户将被引导回默认页面，包含相关帐户信息的行将被插入到数据库的 UserProfile 和网页 _ 成员资格表中。看一下数据库工作区中的这些表，我们会注意到密码作为安全散列而不是纯文本存储在网页 _ 成员资格表中，以帮助提高安全性。

![images](images/square.jpg) **注**默认情况下，ASP.NET 网页使用纯文本在服务器和客户端浏览器之间不安全地传递数据。当通过 internet 发送敏感数据时，最好使用安全套接字层(SSL)证书和 HTTPS 协议安全地发送。

这是一个服务器配置过程，超出了本书的范围。但是，我们可以在 http://www . Microsoft . com/web/post/securing-we B- communication s-certificates-SSL-and-https 找到有关安全网络通信的更多信息

### 添加账户汇总帮助器

接下来，我们将创建一个名为 AccountSummary 的助手，我们可以使用它在我们站点的页面上向用户显示登录信息。如果当前没有用户登录该网站，它将显示登录和注册页面的链接(见[图 7-3](#fig_7_3) ):

![images](images/0703.jpg)

***图 7-3。**没有用户登录时 AccountSummary helper 显示的内容*

如果用户当前登录到网站，助手将显示当前用户名，该用户名本身将是一个允许用户更改密码的页面链接，以及一个注销链接(见[图 7-4](#fig_7_4) )。

![images](images/0704.jpg)

***图 7-4。**当用户已经登录时，AccountSummary 助手显示的内容*

若要创建 AccountSummary 帮助程序，请在站点的根目录下创建一个 App_Code 文件夹(如果尚不存在)。在 App_Code 文件夹中，添加一个名为 MembershipHelpers.cshtml 的文件，并用以下内容替换 WebMatrix 生成的默认标记:

`@helper AccountSummary()
{
    <div id="accountSummary">
        @if(WebSecurity.IsAuthenticated) {
            <p>
                Welcome <a href="@Href("~/changePassword")">@WebSecurity.CurrentUserName</a> |
                <a href="@Href("~/logout")">Logout</a>
            </p>
        } else {
            <p>
                <a href="@Href("~/login")">Login</a> |
                <a href="@Href("~/register")">Register</a>
            </p>
        }
    </div>
}`

![images](images/square.jpg) **注意**account summary 助手是一个很好的例子，说明了如何在 ASP.NET 网页中使用助手，通过代码重用来显著提高可读性、质量和维护。通过将此功能封装在一个助手中，我们可以编写一次代码，然后在站点的任何页面中使用它。

有关在 WebMatrix 中使用助手的更多信息，请参见第 4 章中的[助手部分。](04.html#ch4)

这个助手中的代码相对简单。我们检查`WebSecurity.IsAuthenticated`属性来获取当前用户的身份验证状态。如果当前用户已经过身份验证，我们将显示`WebSecurity.CurrentUserName`属性的值，其中包含经过身份验证的用户的用户名。我们将用户名显示为到 changePassword 页面的链接。

在用户名的旁边，我们提供了一个页面的链接，允许用户退出网站；对于使用共享或公共计算机的用户来说，这是一项重要的安全功能。

如果当前用户没有通过认证，也就是说，如果他们是一个*匿名用户*，我们显示登录和注册页面的链接。

目前只存在注册页面；在本章的其余部分，我们将添加登录、注销和更改密码页面。

最后，为了在主页上显示 AccountSummary 助手，我们需要在 default.cshtml 中添加对`MembershipHelpers.AccountSummary()`的调用:

`<body>
**    @MembershipHelpers.AccountSummary()**
    <h1>Home Page</h1>
    <p>
        Welcome to the Home Page of the Membership Example site.
    </p>
</body>`

要测试助手的功能，请关闭我们 web 浏览器的所有实例以确保我们没有登录，运行默认页面，然后单击 Register 链接。在注册页面上，输入新的用户名和密码并提交表单。然后，注册页面将创建用户，让我们登录，并将我们重定向到主页。当我们返回主页时，我们会注意到 AccountSummary 助手显示的内容类似于图 7-5 中所示的内容。

![images](images/0705.jpg)

***图 7-5。**首页显示的账户汇总帮助*

### 提供登录页面

一旦用户注册了该网站，他们需要能够在下次访问时登录。我们将通过为他们提供一个登录页面来实现这一点，该页面可以通过 AccountSummary helper 为未经身份验证的用户显示的登录链接来访问。

向站点的根目录添加一个名为 login.cshtml 的新文件。首次加载 login.cshtml 时，将显示一个简单的登录表单，其中包含两个文本框，一个用于输入用户名，另一个用于输入密码，以及一个“在这台计算机上记住我”复选框。

当提交表单时，我们将执行一些基本的验证，以确保文本框不是空的。如果验证通过，我们将尝试使用`WebSecurity.Login()`方法让用户登录。如果用户选中了`rememberMe`复选框，`Login()`方法会将 cookie 中的认证令牌设置为在当前会话之后持续存在。这样，当他们以后返回站点时，他们将自动登录，因为 cookie 中的身份验证令牌仍然有效。

如果`Login()`方法成功，用户将被重定向到主页；否则，一个表单错误将被添加到 ModelStateDictionary 中，相关的错误消息将由 ValidationSummary 帮助器显示在页面的顶部(参见[图 7-6](#fig_7_6) )。

将 login.cshtml 中由 WebMatrix 生成的默认标记修改为以下内容:

`@{
    var username = "";
    var password = "";

    if(IsPost)
    {
        username = Request["username"];
        password = Request["password"];
        var rememberMe = Request["rememberMe"].AsBool();

        // Validation
        if (username.IsEmpty()) {
            ModelState.AddError("username", "Username cannot be blank.");
        }

        if (password.IsEmpty()) {
            ModelState.AddError("password", "Password cannot be blank.");
        }

        // Attempt login
        if(ModelState.IsValid)
        {
            if(WebSecurity.Login(username, password, rememberMe))
            {
                Response.Redirect("~/default");
            }
            else
            {
                ModelState.AddFormError("Unable to log in.");
            }
        }
    }
}
<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Login</title>
        <style>
            .validation-summary-errors,
            span.field-validation-error { color: #FF0000; }
            input.field-validation-error { border: 1px solid #FF0000;
                                           background-color: #FFCCCC; }
        </style>
    </head>` `    <body>
        <h1>Login</h1>
        @Html.ValidationSummary(true)
        <form action="login" method="post">
            <div>
                @Html.Label("Username: ", "username")<br />
                @Html.TextBox("username", username)
                @Html.ValidationMessage("username")
            </div>
            <div>
                @Html.Label("Password: ", "password")<br />
                @Html.Password("password")
                @Html.ValidationMessage("password")
            </div>
            <div>
                @Html.CheckBox("rememberMe", new { value = "true" })
                @Html.Label("Remember me on this computer?", "rememberMe")
            </div>

            <div>
                 <input type="submit" value="Login" />
            </div>
        </form>
    </body>
</html>` ![images](images/0706.jpg)

***图 7-6。**显示失败信息的登录页面*

在本章的后面，我们将看到如何使用 WebSecurity helper 来处理忘记密码的用户。

### 注销页面

对于从共享或公共计算机访问网站的用户，我们提供在他们完成后从网站注销的能力是很重要的。

将名为 logout.cshtml 的新文件添加到站点的根目录，并用如下所示的内容替换生成的标记:

`@{
  WebSecurity.Logout();
}
<!DOCTYPE html>

<html lang="en">
    <head>
        <title>Log Out</title>
    </head>
    <body>
        <h1>Log Out</h1>
        <p>We have been logged out from the site.</p>
        <p><a href="@Href("~/default")">Return to home page</a></p>
    </body>
</html>`

这是一个非常简单的页面，它调用`WebSecurity.Logout()`方法并向用户显示一条消息以及一个返回主页的链接(见[图 7-7](#fig_7_7) )。

要测试该页面，请登录到该站点，并单击 AccountSummary 帮助程序中的“注销”链接，这会将我们引导到“注销”页面。当我们单击返回主页的链接时，我们会看到我们已经被注销。

![images](images/0707.jpg)

***图 7-7。**登出页面*

### 更改密码

将通过帐户摘要帮助程序中显示的用户名超链接访问更改密码页面。用户可以更改自己的密码，这是任何网站的基本安全功能。

要更改帐户的密码，我们调用`WebSecurity.ChangePassword()`方法。该方法需要三个参数— `userName`、`currentPassword`和`newPassword` —并返回一个布尔值，指示密码更改操作是否成功。

在我们网站的根文件夹中创建一个名为 changePassword.cshtml 的文件。用以下内容替换页面中默认生成的标记:

`@{
    if (!WebSecurity.IsAuthenticated)
    {
        Response.Redirect("default");
    }

    var currentPassword = "";
    var newPassword1 = "";
    var newPassword2 = "";

    if(IsPost)
    {
        currentPassword = Request["currentPassword"];
        newPassword1 = Request["newPassword1"];
        newPassword2 = Request["newPassword2"];

        // Validation
        if (currentPassword.IsEmpty()) {
            ModelState.AddError("currentPassword", "Current Password required.");
        }

        if (newPassword1.IsEmpty()) {
            ModelState.AddError("newPassword1", "Required.");
        }

        if (newPassword2.IsEmpty()) {
            ModelState.AddError("newPassword2", "Required.");
        }

        if(newPassword1 != newPassword2)
        {
            ModelState.AddError("newPassword1", "The passwords do not match.");
        }

        // Attempt password change
        if(ModelState.IsValid)
        {
            var currentUser = WebSecurity.CurrentUserName;` `            
            if(WebSecurity.ChangePassword(currentUser, currentPassword, newPassword1))
            {
                Response.Redirect("~/default");
            }
            else
            {
                ModelState.AddFormError("Unable to change password.");
            }
        }
    }
}
<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Change Password</title>
        <style>
            .validation-summary-errors,
            span.field-validation-error { color: #FF0000; }
            input.field-validation-error { border: 1px solid #FF0000;
                                           background-color: #FFCCCC; }
        </style>
    </head>
    <body>
        <h1>Change Password</h1>
        @Html.ValidationSummary(true)
        <form action="changePassword" method="post">
            <div>
                @Html.Label("Current Password: ", "currentPassword")<br />
                @Html.Password("currentPassword")
                @Html.ValidationMessage("currentPassword")
            </div>
            <div>
                @Html.Label("New Password: ", "newPassword1")<br />
                @Html.Password("newPassword1")
                @Html.ValidationMessage("newPassword1")
            </div>
            <div>
                @Html.Label("Confirm New Password: ", "newPassword2")<br />
                @Html.Password("newPassword2")
                @Html.ValidationMessage("newPassword2")
            </div>
            <div>
                 <input type="submit" value="Change Password" />
            </div>
        </form>
    </body>
</html>`

让我们快速描述一下这个页面是如何工作的。

当用户登陆页面时，第一件事就是检查他们是否是经过身份验证的用户，也就是说，他们当前已经登录到站点。如果不是，它们会立即被重定向到默认页面。这是必要的，因为它们可能已经通过书签或其他链接到达页面，但实际上当前可能没有被认证；匿名用户使用更改密码页面是没有意义的。正如我们所预料的那样，在没有当前经过验证的用户操作的情况下调用`ChangePassword()`方法会显示一个错误。

如果页面没有作为回发的一部分显示，用户的浏览器中会显示一个类似于图 7-8 所示的表格。为了测试这个页面，我们首先需要登录到站点，因此运行默认页面，从那里登录，并单击 AccountSummary 帮助器中的用户名超链接。

![images](images/0708.jpg)

***图 7-8。**修改密码表单*

当提交表单时，我们执行一些简单的验证，以确保所有必需的字段都已完成，并且两个新密码字段具有匹配的值。

接下来，如果表单数据有效，我们通过访问`WebSecurity.CurrentUserName`属性获得当前用户名。最后，调用`WebSecurity.ChangePassword()`方法，传入所需的参数。

如果密码更改操作成功，用户将被重定向到默认页面。如果操作失败，一条消息被添加到表单的`ModelStateDictionary`中，表单被重新显示。

就是这样。基本的成员资格功能已经完成。在本章的其余部分，我们将学习 ASP.NET 网页会员系统的一些其他功能，并了解如何将它们集成到我们的会员示例站点中。

### 保护内容

除了提供注册、验证和管理个人用户帐户的方法，WebMatrix 会员系统还提供了限制访问站点区域的方法。在本节中，我们将看到在不同级别上实现这一点的各种方法，包括针对经过身份验证的个人用户和组。

#### 限制为认证用户

最基本的内容保护形式是通过限制页面和文件夹，只允许经过身份验证的用户访问。通过以这种方式保护内容，我们不关心用户使用哪个帐户登录，而只关心他们是否登录。

##### 页面级访问限制

我们已经在更改密码一节中看到了页面级访问限制的示例。在页面顶部的代码块中有以下代码行:

`if (!WebSecurity.IsAuthenticated)
{
    Response.Redirect("default");
}`

这段代码只是询问`WebSecurity`类的`IsAuthenticated`属性，如果它包含值`false`，就将用户重定向到默认页面。这是将单个页面限制为只允许经过身份验证的用户访问所需的全部代码。

##### 文件夹级访问限制

通过仔细规划我们的站点，我们可以将所有我们希望限制为只允许经过身份验证的用户访问的页面放在一个特定的文件夹或一组文件夹中。然后，我们可以整体控制对该文件夹的访问。

要查看如何工作的示例，请在我们站点的根目录下创建一个名为 Members 的新文件夹。该文件夹的名称没有任何特别之处；同样的技术可以应用于站点结构中任何级别的任何名称的文件夹。在 Members 文件夹中，创建两个新的 Razor 文件:_PageStart.cshtml 和 Members page . cs html。_ pagestart . cs html 文件是一个特殊的文件，当该文件夹中的任何页面被请求时，就会执行该文件。通过将身份验证检查放在 _PageStart.cshtml 文件中，我们可以控制对整个文件夹的访问。

[图 7-9](#fig_7_9) 显示了文件和文件夹结构现在应该是什么样子。

![images](images/0709.jpg)

***图 7-9。**wer Members 文件夹中的任何页面都将受到 _PageStart 文件中代码的保护。*

在 _PageStart.cshtml 中，用以下代码替换默认标记:

`@{
    if (!WebSecurity.IsAuthenticated)
    {
        Response.Redirect("~/default");
    }
}`

每当在 Members 文件夹中访问页面时，首先执行这段代码。该代码使用 ASP.NET 波浪符号(~)来访问站点的根文件夹。

为了证明这一点，请用以下内容替换我们刚刚创建的 MembersPage.cshtml 文件中的现有标记:

`<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title> **Members Only**</title>
    </head>
    <body>
**        <h1>Members Only Page</h1>**
    </body>
</html>`

注意，我们在这个页面中不需要任何身份验证代码，因为它完全由 we by _PageStart.cshtml 处理。

运行网站，浏览 Members/MembersPage.cshtml，无需登录。我们将被重定向回主页。现在登录并再次浏览 Members/MembersPage.cshtml，我们将看到预期的页面。任何添加到 Members 文件夹的新页面都将被自动限制为只允许通过 _PageStart 验证的用户访问。

##### 提供更好的用户体验

当一个匿名用户登陆我们的一个受保护页面时，他们会通过我们放入 _PageStart.cshtml 中的代码被立即重定向到主页。这是功能性的，当然会将我们的页面限制为只有经过身份验证的用户才能访问，但它确实在用户体验方面留下了一些改进的空间。

对于试图访问受限页面的未经身份验证的用户来说，最有可能的情况是，他们登录到网站的主页，导航到受限页面，然后返回到主页，在那里他们可以单击登录链接。一旦他们登录，他们将再次被重定向到主页，从那里他们可以导航回到他们最初试图访问的页面。这是最好的情况！

我确信我们会同意这为用户提供了不太理想的体验。然而，如果用户直接浏览受保护的页面，可能通过浏览器书签或通过点击电子邮件中的超链接，情况会变得更糟。在这种情况下，很可能用户甚至不知道如何导航到他们首先希望看到的页面。

幸运的是，这相对容易解决。通过对 _PageStart.cshtml 和 login.cshtml 中的现有代码进行一些轻微的修改，我们可以将未经身份验证的用户直接发送到登录页面，并让登录页面在他们成功登录后将他们重定向回他们最初试图访问的页面。

该解决方案将为用户提供极大改善的体验。这种对用户体验中细节的关注是一个高质量网站的标志——一个设计和实现良好的网站。

将 _PageStart.cshtml 中的代码更改为以下内容:

`@{
    if (!WebSecurity.IsAuthenticated)
    {
**        string currentUrl = Request.Url.ToString();**
**        Response.Redirect("~/login?sender=" + currentUrl);**
    }
}`

这段代码现在将未经身份验证的用户直接发送到登录页面。通过查询`Request`对象的`Url`属性，我们可以获得用户最初试图访问的页面的完整 URL。当我们执行重定向时，我们在 QueryString 中发送带有关键字`sender`的 URL。我们将重定向到的 URL 如下所示:

`http://localhost:1956/login?sender=http://localhost:1956/Members/MembersPage`

接下来，我们需要对 login.cshtml 进行必要的修改，以便在成功登录后将用户重定向回他们的初始页面。此处突出显示了对页面顶部代码块的必要更改:

`@{
    var username = "";
    var password = "";

    if(IsPost)
    {
        username = Request["username"];
        password = Request["password"];
        var rememberMe = Request["rememberMe"].AsBool();

        // Validation
        if (username.IsEmpty()) {
            ModelState.AddError("username", "Username cannot be blank.");
        }

        if (password.IsEmpty()) {
            ModelState.AddError("password", "Password cannot be blank.");
        }

        // Attempt login
        if(ModelState.IsValid)
        {
            if(WebSecurity.Login(username, password, rememberMe))
            {
**                if (Request.QueryString["sender"] != null)**
**                {**
**                    Response.Redirect(Request.QueryString["sender"]);**
**                }**
**                else**
**                {**
**                    Response.Redirect("~/default");**
**                }**
            }
            else
            {
                ModelState.AddFormError("Unable to log in.");
            }
        }
    }
}`

这段代码的修改部分非常简单，它只是检查是否在 QueryString 中传递了一个带有 sender 键的值。如果有，用户被重定向到传递的值；如果没有，它们将被重定向回主页。

为了完成这项工作，我们需要对 login.cshtml 中的<表单>标签做最后一个修改。这个修改将把整个 QueryString 传递回 post back 页面，允许我们在 post 请求处理程序中访问发送者 URL:

`<form action="login**?@Request.QueryString**" method="post">`

现在，我们有了一个更令人满意的登录系统，为我们的用户提供了一个大大改善的体验。

#### 角色

角色是创建相关用户组的一种便捷方式。它们是对页面和功能访问进行精细控制的下一步。到目前为止，本节中看到的示例只是关于经过身份验证的用户或匿名用户，而角色允许将经过身份验证的用户进一步划分为不同的组。

例如，我们的站点可能有对所有用户开放的区域(经过验证的和匿名的)，只对经过验证的用户开放的区域，以及其他只允许站点管理员访问的区域。这就是角色的用武之地。我们可以创建一个名为“Admins”的角色，并将该角色仅分配给站点管理员的成员帐户。一旦我们做到了这一点，就只需要限制站点的相关区域，只允许“管理员”角色的成员访问。

角色和角色成员分别存储在成员数据库的`webpages_Roles`和`webpages_UsersInRoles`表中。数据库的模式非常简单。角色在`webpages_Roles`表中定义，该表包含两列:`RoleId`和`RoleName`。可以使用任何有效的字符串来命名角色，但是在`webpages_Roles`表中必须是唯一的。`webpages_UsersInRoles`表通过使用两列将用户链接到角色:`UserId`和`RoleId`。该表中的每一行都将一个用户与一个角色相关联。如果一个用户有许多角色，每个角色映射将有一个单独的行。

显然，我们可以使用 WebMatrix IDE 中的工具，通过直接在数据库表中添加、删除和创建行来管理角色及其成员资格。然而，更好的解决方案是在我们的站点中提供这种功能，因此在接下来的四个部分中，我们将创建用于执行角色管理的页面。

我们网站的角色管理部分将由两个主要页面组成。第一个将列出所有当前角色，并提供添加新角色的能力。通过单击该页面中的角色名称，用户将被带到第二个主页，该主页将列出当前与该角色关联的所有用户，并提供向该角色添加新用户和从该角色中删除现有用户的方法。我们还需要两个辅助页面来删除用户和角色。

##### 列出和添加角色

如前所述，我们的网站将包含一个页面，列出我们的会员数据库中的所有角色，并让用户能够添加新的角色。ASP.NET 网页成员系统通过`Roles`类提供角色管理功能。

我们将把所有的角色管理页面保存在一个名为“Admin”的单独文件夹中，我们应该在站点的根目录下创建这个文件夹。在 Admin 文件夹中，创建一个名为 roles.cshtml 的新页面，并用以下代码填充它:

`@{
    if(IsPost)
    {
        var newRole = Request["roleName"];

        // Add new role
        if(!newRole.IsEmpty()) && (!Roles.RoleExists(newRole))
        {
            Roles.CreateRole(newRole);
        }
    }

    var currentRoles = Roles.GetAllRoles();
}
<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Roles</title>
    </head>
    <body>
        <h1>Roles</h1>
        <div>
            <h2>Current Roles</h2>
            @if(currentRoles.Length > 0)
            {
                @* List all current roles *@
                <ul>
                    @foreach(var role in currentRoles)
                    {
                        <li><a href="roleDetails?roleName=@role">@role</a></li>
                    }
                </ul>
            }
            else
            {
                <p>No roles currently defined.</p>
            }
        </div>
        <div>
            @* Form to add new roles to the membership database *@
            <h2>Add New Role</h2>
            <form action="roles" method="post">
                @Html.Label("Role Name: ", "roleName")
                @Html.TextBox("roleName")
                <input type="submit" value="Add Role" name="addRole" />
            </form>    
        </div>
    </body>
</html>`

在初始加载时，这个页面使用`Roles.GetAllRoles()`方法获得所有当前定义的角色列表，并将其赋给一个变量。`Roles.GetAllRoles()`方法返回一个字符串数组，数组中的每个元素保存一个角色名。

`var currentRoles = Roles.GetAllRoles();`

如果数组不为空，也就是说，有一个或多个当前角色，我们使用一个`foreach`循环遍历数组，并在 web 页面上的项目符号列表中显示每个名字，并带有一个到`roleDetails`页面的超链接，我们稍后将创建该页面。超链接还在名为`roleName`的查询字符串键中传递角色的名称。如果数组为空，我们只需向用户显示一条消息，告诉用户没有要显示的角色。

`@if(currentRoles.Length > 0)
{
    @* List all current roles *@
    <ul>
        @foreach(var role in currentRoles)
        {
            <li><a href="roleDetails?roleName=@role">@role</a></li>
        }
    </ul>
}
else
{
    <p>No roles currently defined.</p>
}`

在页面底部，当前角色列表的下方，我们显示了一个简单的表单，允许用户添加新角色。当用户单击该表单的提交按钮时，页面顶部的代码会检查文本框是否为空，以及用户输入的角色名称是否已经存在。如果这两个检查都通过了，那么通过将新的角色名称传递到`Roles.CreateRole()`方法中，就可以将角色添加到数据库中。

`if(IsPost)
{
    var newRole = Request["roleName"];

    // Add new role
    if((!newRole.IsEmpty()) && (!Roles.RoleExists(newRole)))
    {
        Roles.CreateRole(newRole);
    }
}`

在[图 7-10](#fig_7_10) 中可以看到显示给用户的页面示例:

![images](images/0710.jpg)

***图 7-10。**角色管理页面，显示通过添加新角色表单创建的其他角色*

##### 列出角色成员并将用户添加到角色

当用户单击 roles.cshtml 中的角色时，他们将被定向到一个页面，该页面列出了当前分配给该角色的所有用户。也是在这里，现有用户可以被分配到角色。

在 Admin 文件夹中创建一个名为 roleDetails.cshtml 的新文件。将以下代码和标记添加到页面中:

`@{
    var roleName = Request["roleName"];

    if(IsPost)
    {
        // Assign user to role
        var userName = Request["newUser"];

        if (!Roles.IsUserInRole(userName, roleName))
        {
            Roles.AddUsersToRoles(
                new [] { userName }.ToArray(),
                new [] { roleName }.ToArray()
            );
        }
    }

    // Get all current role members
    var usersInRole = Roles.GetUsersInRole(roleName);

    // Get all users from database and create a list of SelectListItems
    var db = Database.Open("MembershipExample");` `    var sqlCommand = "SELECT UserName FROM UserProfile ORDER BY UserName";

    List<SelectListItem> allUsers = new List<SelectListItem>();
    foreach(var item in db.Query(sqlCommand))
    {
        allUsers.Add(new SelectListItem { Text = item.UserName });
    }
}

<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Role Details</title>
    </head>
    <body>
        <h1>Role Details - @roleName</h1>
        <div>
            @if(usersInRole.Length > 0)
            {
                @* List all current role members *@
                <ul>
                    @foreach(var user in usersInRole)
                    {
                        <li>@user
                            <a href="removeUserFromRole?roleName=@roleName&userName=@user">
                                [Remove]
                            </a>
                        </li>
                    }
                </ul>
            }
            else
            {
                <p>No users currently attached to this role.</p>
                <p><a href="deleteRole?roleName=@roleName">Delete this role</a></p>
            }
        </div>
        <div>
        @* Form to assign users to the current role *@
            <h2>Add User</h2>
            <form action="roleDetails" method="post">
                @Html.Hidden("roleName", roleName)
                @Html.Label("User: ", "newUser")
                @Html.DropDownList("newUser", allUsers)
                <input type="submit" value="Add User" name="addUser" />
            </form>
        </div>
    </body>
</html>`

让我们仔细阅读代码，以完全理解到底发生了什么。

当页面被请求时，我们通过访问在 URL 中传递的`Request`对象中的`roleName`键来获得相关角色的名称。

`var roleName = Request["roleName"];`

现在让我们跳过`if(IsPost)` post 请求处理程序代码，稍后我们将回到这个问题。一旦我们有了角色名，我们就可以调用`GetUsersInRole()`方法，该方法返回一个字符串数组，其中包含作为参数传递给该方法的角色所有成员的用户名。

`// Get all current role members
var usersInRole = Roles.GetUsersInRole(roleName);`

页面顶部的代码块的最后一部分查询数据库的`UserProfile`表以返回所有用户的列表，结果我们用来创建一个用于下拉列表的`SelectListItems`的集合。

`// Get all users from database and create a list of SelectListItems
var db = Database.Open("MembershipExample");
var sqlCommand = "SELECT UserName FROM UserProfile ORDER BY UserName";

List<SelectListItem> allUsers = new List<SelectListItem>();
foreach(var item in db.Query(sqlCommand))
{
    allUsers.Add(new SelectListItem { Text = item.UserName });
}`

在页面本身中，我们通过检查由`Roles.GetUsersInRoles()`方法调用返回的数组的长度来查看当前是否有任何用户被分配到这个角色。如果有一个或多个成员，我们使用一个`foreach`循环遍历数组，并在一个项目符号列表中输出他们的名字。每个列表项中的用户名都显示为超链接，用于方便从角色中删除用户。“Remove”超链接将浏览器定向到 removeUserFromRole.cshtml，我们将在后面创建它，并将 URL 中的角色名和用户名作为 QueryString 传递。

`@if(usersInRole.Length > 0)
{
    @* List all current role members *@
    <ul>
        @foreach(var user in usersInRole)
        {
            <li>@user
                <a href="removeUserFromRole?roleName=@roleName&userName=@user">
                    [Remove]
                </a>
            </li>
        }
    </ul>
}`

如果当前没有用户被分配到该角色，我们将显示一条消息，同时显示一个删除该角色的链接；只有当`webpages_UsersInRoles`表中没有相关记录时，角色才能被删除，即角色没有成员。“Delete this role”超链接指向 deleteRole.cshtml，我们还没有创建它，在 URL 中传递角色名称。

`else
{
    <p>No users currently attached to this role.</p>
    <p><a href="deleteRole?roleName=@roleName">Delete this role</a></p>
}`

最后，我们向用户显示一个表单，允许他们向角色添加用户。在这个表单中，我们显示了一个下拉列表，使用我们之前从成员数据库创建的集合`SelectListItems`填充，以及一个提交表单的按钮。该表单还包含一个隐藏字段，其中包含先前从 URL 中提取的角色名，该角色名将被传递给 post 请求处理程序。

`<form action="roleDetails" method="post">
    @Html.Hidden("roleName", roleName)
    @Html.Label("User: ", "newUser")
    @Html.DropDownList("newUser", allUsers)
    <input type="submit" value="Add User" name="addUser" />
</form>`

要测试此页面，请以管理员用户身份登录，单击 AccountSummary 帮助器中的“角色管理”链接，并选择一个至少有一个相关用户的角色。最终呈现给用户的页面是这样的(见[图 7-11](#fig_7_11) ):

![images](images/0711.jpg)

***图 7-11。**角色详情页面*

当点击“添加用户”按钮时，post 请求处理程序使用`Roles.IsUserInRole()`方法检查我们试图添加的用户是否已经被分配了角色。然后，它使用`Roles.AddUsersToRoles()`方法为用户分配角色。由于该方法接受字符串数组作为参数，我们使用`String.ToArray()`方法来转换表单值。

`var roleName = Request["roleName"];

if(IsPost)
{
    // Assign user to role
    var userName = Request["newUser"];

    if (!Roles.IsUserInRole(userName, roleName))
    {
        Roles.AddUsersToRoles(
            new [] { userName }.ToArray(),
            new [] { roleName }.ToArray()
        );
    }
}`

角色管理系统中的最后两个页面与角色和角色成员的删除有关。

##### 从角色中删除用户

我们的“角色详细信息”页面列出了特定角色的所有当前成员，并为用户提供了一个“删除”超链接。超链接将角色名和用户名传递给 removeUserFromRole.cshtml，我们现在将创建该文件。

removeUserFromRole.cshtml 的代码如下:

`@{
    var userName = Request["userName"];
    var roleName = Request["roleName"];

    if(IsPost)
    {
        // Remove user from role
        if (Roles.IsUserInRole(userName, roleName))
        {
            Roles.RemoveUsersFromRoles(
                new [] { userName }.ToArray(),
                new [] { roleName }.ToArray()
            );
        }

        Response.Redirect("roleDetails?roleName=" + roleName);
    }
}
<!DOCTYPE html>

<html lang="en">
    <head>` `        <meta charset="utf-8" />
        <title>Remove User From Role</title>
    </head>
    <body>
        <h1>Remove User from Role</h1>
        <p>Are we sure we wish to remove user @userName from the @roleName role?</p>
        <p>
            <form action="" method="post">
                @Html.Hidden("roleName", roleName)
                @Html.Hidden("userName", userName)
                <input type="button"
                    onclick="window.location.href='roleDetails.cshtml?roleName=@roleName';"
                    value="Cancel" />
                <input type="submit" value="Remove" />
            </form>
        </p>
    </body>
</html>`

当第一次请求这个页面时，我们向用户显示一条确认消息。这有助于确保将正确的用户从角色中移除，也使我们能够对 POST 请求执行移除操作，而不是 GET(即，当用户单击页面上的 submit 按钮时)。

除了确认删除的按钮之外，表单还包含一个简单的 HTML“Cancel”按钮，该按钮带有一个 JavaScript `onclick`事件，让用户返回到角色详细信息页面，而无需提交表单。两个 HTML 隐藏输入控件用于将角色名和用户名从初始 URL 传递给 POST 请求处理程序。

在[图 7-12](#fig_7_12) 中可以看到从角色中删除用户页面的示例:

![images](images/0712.jpg)

***图 7-12。**从角色确认页面移除用户*

当提交表单时，我们从隐藏字段中获取用户名和角色名，检查用户是否在角色中，如果是，则删除它们。为了从角色中删除用户，我们使用`Roles.RemoveUsersFromRoles()`方法，传入用户名和角色名。与前面看到的`AddUsersToRoles()`方法一样，`RemoveUsersFromRoles()`方法接受字符串数组作为参数，所以我们使用`String.ToArray()`方法将表单值转换为数组。

从角色中删除用户后，浏览器将被重定向到角色详细信息页面，并在 QueryString 中传递角色名称。

##### 删除角色

最后，我们将实现“删除角色”页面。该页面相对简单，工作方式类似于“从角色中删除用户”页面。该页面通过“角色详细信息”页面上的超链接访问。

向 Admin 文件夹添加一个名为 deleteRole.cshtml 的新文件，并用以下内容替换默认标记:

`@{
    var roleName = Request["roleName"];

    if(IsPost)
    {
        // Delete role
        if(Roles.GetUsersInRole(roleName).Length == 0 && !roleName.IsEmpty())
        {
            Roles.DeleteRole(roleName, true);
        }

        Response.Redirect("roles");
    }
}
<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Delete Role</title>
    </head>
    <body>
        <h1>Delete Role</h1>
        <p>Are we sure we wish to delete the @roleName role?</p>
        <p>
            <form action="" method="post">
                @Html.Hidden("roleName", roleName)
                <input type="button"
                    onclick="window.location.href='roleDetails.cshtml?roleName=@roleName';"
                    value="Cancel" />
                <input type="submit" value="Delete" />
            </form>
        </p>
    </body>
</html>`

同样，当用户第一次请求页面时，会显示一条确认消息。页面底部的表单包含一个提交按钮、一个取消按钮和一个 HTML 隐藏字段，该字段包含从 URL QueryString 检索的角色名称。

[图 7-13](#fig_7_13) 显示了一个删除角色页面的例子。

![images](images/0713.jpg)

***图 7-13。**删除角色确认页面*

当单击 Delete submit 按钮时，POST 请求处理程序会检查角色名称是否为空，以及是否没有分配成员。这一步很重要，因为当角色在`webpages_UsersInRoles`表中有相关用户时，不能将其删除。由于 web 应用程序的性质，在我们请求角色详细信息页面和单击删除角色页面上的删除提交按钮之间的时间内，可能有另一个用户(在另一个浏览器中)向角色添加了用户。在这种情况下，我们不想调用`Roles.DeleteRole()`方法。

如果角色没有成员用户，则使用`Roles.DeleteRole()`方法将其删除，浏览器被重定向到角色页面。

##### 使用角色限制访问

现在，角色管理页面已经完成，我们可以使用它们来创建角色，为角色分配用户，并将站点中的页面限制为只允许该角色的成员访问。

如果我们还没有名为“Administrators”的角色，请使用 Roles 页面创建一个角色，或者直接将其添加到`webpages_Roles`表中；请确保向该角色添加用户。要使用角色页面创建角色，请在浏览器中打开 Admin/Roles.cshtml，并使用 UI 添加名为“Administrators”的角色该页面将显示新角色，然后我们应该单击它以转到角色详细信息页面。这将允许我们向该角色添加用户。

我们将限制该角色的用户访问 Admin 文件夹中的页面。为此，使用以下代码将 _PageStart.cshtml 文件添加到 Admin 文件夹中:

`@{
    if (!Roles.IsUserInRole(WebSecurity.CurrentUserName, "Administrators"))
    {
        string currentUrl = Request.Url.ToString();
        Response.Redirect("~/login?sender=" + currentUrl);
    }
}`

这段代码在 Admin 文件夹中请求的任何页面执行之前立即运行。该代码使用`Roles.IsUserInRole()`方法来检查当前用户是否处于“管理员”角色。我们通过调用`WebSecurity.CurrentUserName()`将当前用户的名字传递给`Roles.IsUserInRole()`方法，后者返回一个包含当前已验证用户的用户名的字符串。如果当前用户不属于“管理员”角色，他们将被重定向到根文件夹中的登录页面。如“提供更好的用户体验”一节中所讨论的，被请求页面的 URL 被附加到 QueryString 中的 URL。

##### 更新帐户摘要助手

虽然站点管理员可以通过在 web 浏览器的地址栏中键入 URL 来直接浏览角色页面，但如果我们能为他们提供一个链接，那就更好了。做这件事的理想地方是`AccountSummary`助手，它已经显示了特定于认证用户的帐户信息。我们将修改`AccountSummary`助手以使用`Roles.IsUserInRole()`方法来为作为“管理员”角色成员的已验证用户显示角色链接。

打开 App_Code 文件夹中的 MembershipHelpers.cshtml 文件，修改`AccountSummary`助手，如下所示:

`@helper AccountSummary()
{
    <div id="accountSummary">
        @if(WebSecurity.IsAuthenticated) {
            <p>
                Welcome <a href="@Href("~/changePassword")">@WebSecurity.CurrentUserName</a> |
                <a href="@Href("~/logout")">Logout</a>
**                @if (Roles.IsUserInRole(WebSecurity.CurrentUserName, "Administrators"))**
**                {**
**                    <text>**
**                         | <a href="@Href("~/Admin/roles")">Roles Administration</a>**
**                    </text>**
**                }**
            </p>
        } else {
            <p>
                <a href="@Href("~/login")">Login</a> |
                <a href="@Href("~/register")">Register</a>
            </p>
        }
    </div>
}`

现在，当管理员角色的成员登录到站点时，他们将在`AccountSummary`助手中收到一个指向角色管理页面的链接(参见[图 7-14](#fig_7_14) ):

![images](images/0714.jpg)

***图 7-14。**显示角色管理超链接的修改后的 account summary helper*

### 高级会员功能

本章的最后一部分将研究 ASP.NET 网页会员系统的一些更高级的功能，着眼于以下方面:

*   如何使用`WebSecurity`助手存储注册时收集的关于用户的附加信息。
*   实施更高级的注册系统，向用户发送电子邮件，要求在激活帐户前进行确认。
*   为忘记密码的注册用户添加密码重置功能。

#### 存储附加用户信息

创建新用户帐户时，通常希望存储更多信息，而不仅仅是用户名和密码。幸运的是，`WebSecurity`助手通过在`CreateUserAndAccount()`方法中添加一个可选参数使这变得简单。

为了证明这一点，我们将修改我们的注册页面和数据库来收集和存储用户的电子邮件地址。首先，我们需要向 register.cshtml 中的注册表单添加一个额外的字段:

`<form action="register" method="post">
    <div>
        @Html.Label("Username: ", "username")<br />
        @Html.TextBox("username", username)
        @Html.ValidationMessage("username")
    </div>
**    <div>**
**        @Html.Label("Email Address: ", "email")<br />**
**        @Html.TextBox("email", email)**
**        @Html.ValidationMessage("email")**
**    </div>**
    <div>
        @Html.Label("Password: ", "password1")<br />
        @Html.Password("password1", password1)
        @Html.ValidationMessage("password1")
    </div>
    <div>
        @Html.Label("Confirm Password: ", "password2")<br />
        @Html.Password("password2", password2)
    </div>
    <div>
         <input type="submit" value="Register" />
    </div>
</form>`

接下来，在 WebMatrix IDE 中打开数据库工作区，选择站点数据库中的`UserProfile`表，并单击屏幕顶部功能区控件中的“定义”按钮。现在单击 Ribbon 控件中的“New Column”按钮，添加一个名为`EmailAddress`的列。该列应为可空的`nvarchar`，长度为 100 个字符(见[图 7-15](#fig_7_15) ):

![images](images/0715.jpg)

***图 7-15。**向用户资料表添加一个电子邮件地址列*

保存修改后的`UserProfile`表，并导航回文件工作区中的 register.cshtml 页面。

当用户提交表单时，我们将检查他们是否输入了电子邮件地址，然后将该字段的值传递给`CreateUserAndAccount()`方法的可选`propertyValues`参数。

![images](images/square.jpg) **注意**这个代码示例只检查用户是否在表单的 emailAddress 字段中输入了值；它不会检查所提供的电子邮件地址是否有效。要了解如何使用 WebMatrix 验证电子邮件地址，请参见第 5 章的[的“构建验证库”部分。](05.html#ch5)

修改 register.cshtml 顶部的代码块，以包含以下突出显示的更改:

`@{
    var username = "";
**    var email = "";**
    var password1 = "";
    var password2 = "";

    if(IsPost)
    {
        WebSecurity.Logout();` `        
        username = Request["username"];
**        email = Request["email"];**
        password1 = Request["password1"];
        password2 = Request["password2"];

        // Validation
        if (username.IsEmpty()) {
            ModelState.AddError("username", "Username is required.");
        }

**        if (email.IsEmpty()) {**
**            ModelState.AddError("email", "Email Address is required.");**
        }

        if (password1.IsEmpty()) {
            ModelState.AddError("password1", "Password is required.");
        }

        if(WebSecurity.UserExists(username))
        {
            ModelState.AddError("username", "An account with this name already exists.");
        }

        if(password1 != password2)
        {
            ModelState.AddError("password1", "The passwords do not match.");
        }

        // Create Account
        if(ModelState.IsValid)
        {
**            WebSecurity.CreateUserAndAccount(userName:username,**
**                                            Password: password1,**
**                                            propertyValues: new { emailAddress = email } );**
            WebSecurity.Login(username, password1);
            Response.Redirect("default");
        }
    }
}`

`propertyValues`参数接受一个包含附加用户属性的`object`。我们只需要创建一个新的`object`,并将变量`email`的值赋给一个与我们创建的数据库列同名的实体。当该方法被调用时，`WebSecurity`助手将尝试将`propertyValues` `object`中的任何实体与数据库列进行匹配，并存储其中保存的值。

##### 通过电子邮件确认注册

为了帮助防止人类和机器人进行欺诈性注册，常见的做法是在注册后向用户发送包含注册确认页面链接的电子邮件。只有在用户点击电子邮件中的链接并成功验证其注册后，他们才能登录到该网站。

完成这一设计所需的所有组件都可以在 ASP.NET 的网页上找到。为了演示这种技术，我们将使用 WebSecurity 和 WebMail 助手进一步修改上一节中的注册页面。

![images](images/square.jpg) **提示**另一种防止欺诈性表单提交的有用方法是使用重新验证码帮助器，我们将在第 8 章的[中了解更多。](08.html#ch8)

###### 网络邮件助手

WebMail helper 需要一些初始设置，但是一旦完成，它提供了一种非常简单的方式来从 Razor 代码中发送电子邮件。

正如我们所预料的，WebMail 助手需要一些关于邮件服务器的初始信息。提供此信息的最佳位置是在 _AppStart.cshtml 文件中，以便使它对整个应用程序可用。

我们需要的具体信息可以从我们的虚拟主机提供商或系统管理员那里获得。出于开发和测试的目的，通常可以使用标准的 web 邮件服务。此代码示例显示了 _AppStart.cshtml 文件，该文件带有用于 Google Gmail 服务的 WebMail 助手设置。

`@{
    WebSecurity.InitializeDatabaseConnection("MembershipExample",
        "UserProfile", "UserId", "UserName", true);

**    WebMail.SmtpServer = "smtp.gmail.com";**
**    WebMail.SmtpPort = 587;**
**    WebMail.EnableSsl = true;**
**    WebMail.UserName = "wer_username_here@gmail.com";**
**    WebMail.From = "wer_username_here@gmail.com";**
**    WebMail.Password = "wer_password_here";**
}`

表 7-2 更详细地解释了这些设置。

T2】

初始设置完成后，发送电子邮件只需调用`WebMail.Send()`方法，传入要发送的电子邮件地址、电子邮件的主题行和正文即可:

`WebMail.Send(to: "user@example.com",
             subject: "Subject line goes here”,
             body: “Message text goes here” );`

![images](images/square.jpg) **注**欲了解更多关于网络邮件助手的信息，请访问 MSDN 网页[http://msdn . Microsoft . com/en-us/library/system . web . helpers . WebMail . aspx](http://msdn.microsoft.com/en-us/library/system.web.helpers.webmail.aspx)

###### 生成并发送确认电子邮件

现在我们已经初始化了 WebMail 助手，我们需要生成一封电子邮件发送给用户，要求他们确认他们新创建的帐户。我们可以使用`CreateUserAndAccount()`方法返回一个惟一的令牌，我们将在电子邮件中把它作为确认页面链接的一部分发送给用户。用户必须访问电子邮件中的链接 URL，以便确认他们的帐户。

通过将`WebSecurity.CreateUserAndAccount()`方法的`requireConfirmationToken`参数设置为`true,`，我们可以生成一个独特的确认令牌，看起来类似于`hYQSzXhwp6Se6mmPJ0KFoQ==`。该令牌也根据数据库中的用户记录进行存储。用户和帐户已创建，但处于未确认状态(即`webpages_Membership`表中的`IsConfirmed`列被设置为`false`)，在确认之前不能登录网站。

本示例基于本章前面“存储附加用户信息”一节中的示例，在该节中，我们修改了注册页面，除了标准用户名和密码之外，还接受和存储用户的电子邮件地址。因此，打开 register.cshtml 并修改 post 请求事件处理程序，如下所示:

`if(ModelState.IsValid)
{
    var token = WebSecurity.CreateUserAndAccount(userName: username,
                    password: password1,
                    propertyValues: new { emailAddress = email },
                    requireConfirmationToken: true);

    // Generate confirmation link URL
    var hostUrl = Request.Url.GetComponents(UriComponents.SchemeAndServer,
                                        UriFormat.Unescaped);
    var confirmAccountUrl = hostUrl +
                    "/confirmAccount?confirmationToken=" +
                    HttpUtility.UrlEncode(token);

    // Send confirmation email
    WebMail.Send(to: email,
        subject: "Thank we for registering - " + username,
        body: "Please visit <a href='" + confirmAccountUrl + "'>" + confirmAccountUrl +
            "</a> to activate wer account."
    );

    Response.Redirect("confirmSent");
}`

在这段代码中，我们调用`WebSecurity.CreateUserAndAccount()`并将`requireConfirmationParameter`设置为`true`。我们将得到的确认令牌存储在一个名为`token`的变量中。

接下来，我们构建链接的 URL，用户需要访问该链接来确认他们的帐户。我们通过从请求对象获取方案、主机和端口数据来实现这一点，这将使用 IIS Express 在本地开发机器上返回类似于`http://localhost:16458`的内容。然后，我们将确认页面的名称和一个包含令牌的 QueryString 追加到该页面中。令牌是 URL 编码的，以确保组成令牌的任何字符都不会被误解为 URL 中的保留字符。

`// Generate confirmation link URL
var hostUrl = Request.Url.GetComponents(UriComponents.SchemeAndServer,
                                    UriFormat.Unescaped);
var confirmAccountUrl = hostUrl +
                "/confirmAccount?confirmationToken=" +
                HttpUtility.UrlEncode(token);`

最后，我们使用 WebMail 助手向表单中提供的电子邮件地址发送一封包含短消息和确认 URL 的电子邮件，并将用户重定向到 confirmSent.cshtml。

confirmSent.cshtml 文件仅包含一条给用户的消息，感谢他们注册并提示他们检查他们的电子邮件帐户以获得进一步的指示。使用以下标记在网站的根目录中创建 confirmSent.cshtml:

`<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Confirmation Sent</title>
    </head>
    <body>
        <h1>Thanks For Registering</h1>
        <p>We have sent an email with instructions on how to activate wer account
        to the email address we supplied.</p>
    </body>
</html>`

###### 帐户确认页面

当用户收到他们的确认电子邮件时，他们将被指示访问我们网站的 URL 来验证他们的帐户；我们站点上的 URL 将是 confirmAccount.cshtml，在 QueryString 中使用键`confirmationToken`传递唯一的确认令牌。

当 confirmAccount.cshtml 被请求时，我们将注销任何经过身份验证的用户(因为除了我们正在尝试确认的用户之外，可能还有其他用户已经登录)，从 URL 获取确认令牌，并尝试通过将令牌传递给`WebSecurity.ConfirmAccount()`方法来确认帐户。`ConfirmAccount()`方法返回一个布尔值，表明确认是否成功。我们将使用这个布尔值向用户显示相关的消息。

将名为 confirmAccount.cshtml 的新文件添加到网站的根目录，并用以下内容替换默认标记:

`@{

    bool confirmed = false;
    var confirmationToken = Request["confirmationToken"];

    WebSecurity.Logout();

    // Attempt account confirmation
    if (!confirmationToken.IsEmpty()) {
        if (WebSecurity.ConfirmAccount(confirmationToken)) {
            confirmed = true;
        }
    }
}
<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="utf-8" />` `        <title>Registration Confirmation</title>
    </head>
    <body>
        <h1>Registration Confirmation</h1>

        @if (confirmed)
        {
            <p>
                Wer registration is confirmed.
                We can now <a href="login">login</a>.
            </p>
        }
        else
        {
            <p>Unable to confirm the registration.</p>
        }
    </body>
</html>`

如果确认成功，用户将会看到如图[图 7-16](#fig_7_16) 所示的页面:

![images](images/0716.jpg)

***图 7-16。**注册确认页面*

##### 处理忘记的密码

WebMatrix `WebSecurity`助手有一个处理忘记密码的内置方案。在许多方面，它类似于上一节中讨论的电子邮件注册确认过程。当用户忘记密码时，将会发送一封电子邮件，其中包含一个链接，指向带有唯一密码重置令牌的 URL。当他们访问 URL 时，代码会检查令牌，如果令牌有效，就会给他们提供重置密码的机会。

整个过程需要两个页面:一个收集用户名、生成重置令牌并发送电子邮件，另一个验证令牌并允许用户设置新密码。

第一个页面将被称为 forgotPassword.cshtml，我们应该将它添加到示例站点的根目录中。下面列出了该页面的代码和标记:

`@{
    var username = "";
    var message = "";

    if(IsPost)
    {
        username = Request["username"];` `// Validation
        if (username.IsEmpty()) {
            ModelState.AddError("username", "Username is required.");
        }

        // Generate and send password reset email
        if(ModelState.IsValid)
        {
            // Generate confirmation link URL
            var resetToken = WebSecurity.GeneratePasswordResetToken(username);
            var hostUrl = Request.Url.GetComponents(UriComponents.SchemeAndServer,
                                                    UriFormat.Unescaped);
            var passwordResetUrl = hostUrl +
                                "/passwordReset?resetToken=" +
                                HttpUtility.UrlEncode(resetToken);

            // Get email address for user
            var db = Database.Open("MembershipExample");
            var sqlCommand = "SELECT emailAddress FROM UserProfile WHERE UserName = @0";
            var userDetails = db.QuerySingle(sqlCommand, username);

            // Send email
            WebMail.Send(to: userDetails.emailAddress,
                subject: "Password Reset for " + username,
                body: "Please visit <a href='" + passwordResetUrl + "'>" + passwordResetUrl +
                    "</a> to reset wer password."
            );

            message = "An email has been sent to wer registered email address " +
                "with a password reset link.";
        }
    }
}

<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Forgot Password</title>
        <style>
            span.field-validation-error { color: #FF0000; }
            input.field-validation-error { border: 1px solid #FF0000;
                                           background-color: #FFCCCC; }
        </style>
    </head>
    <body>
        <h1>Forgotten Password</h1>
        @if (!message.IsEmpty()) {
            <p>@message</p>` `        }
        else
        {
            <form action="forgotPassword" method="post">
                <div>
                    @Html.Label("Username: ", "username")<br />
                    @Html.TextBox("username", username)
                    @Html.ValidationMessage("username")
                </div>
                <div>
                    <input type="submit" value="Reset Password" />
                </div>
            </form>
        }
    </body>
</html>`

在初始请求时，该页面向用户显示一个非常简单的表单，只要求输入用户名。提交表单时，post 请求处理程序会验证表单，如果有效，将生成密码重置页面的 URL，该页面将作为电子邮件中的链接发送给用户。密码重置 URL 由方案和服务器详细信息、页面名称(passwordReset.cshtml)和包含唯一重置令牌的 QueryString 组成。

重置令牌是一个加密的安全字符串，类似于我们前面看到的帐户确认令牌。我们通过调用`WebSecurity.GeneratePasswordResetToken()`方法生成令牌，将用户名作为参数传入。

一旦我们生成了 URL，我们就查询会员数据库的`UserProfile`表，以确定用户注册的电子邮件地址。然后，我们使用 WebMail 助手向用户发送一封电子邮件，其中包含一条短消息和一个到密码重置页面的链接。最后，我们向用户显示一条消息，让他们知道查看他们的电子邮件帐户以获得进一步的指示。

当用户收到他们的密码重置电子邮件时，他们将被要求访问特定的 URL 来重置他们的密码。在这种情况下，他们需要访问的页面将被称为 passwordReset.cshtml，我们应该在站点的根文件夹中创建它。

将 passwordReset.cshtml 的内容替换为以下内容:

`@{
    var resetToken = Request["resetToken"];
    var message = "";
    var newPassword1 = "";
    var newPassword2 = "";

    if(IsPost) {
        newPassword1 = Request["newPassword1"];
        newPassword2 = Request["newPassword2"];

        // Validation       
        if (newPassword1.IsEmpty()) {
            ModelState.AddError("newPassword1", "Required.");` `        }

        if (newPassword2.IsEmpty()) {
            ModelState.AddError("newPassword2", "Required.");
        }

        if(newPassword1 != newPassword2)
        {
            ModelState.AddError("newPassword1", "The passwords do not match.");
        }

        // Attempt password reset        
        if(ModelState.IsValid)
        {
            if (WebSecurity.ResetPassword(resetToken, newPassword1))
            {
                message = "Password changed successfully.";
            }
            else
            {
                message = "Unable to change password.";
            }
        }
  }
}

<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Reset Password</title>
    </head>
    <body>
        <h1>Reset Password</h1>
        @if (!message.IsEmpty()) {
            <p>@message</p>
        }
        else
        {
            <form action="passwordReset" method="post">
                @Html.Hidden("resetToken", resetToken)
                <div>
                    @Html.Label("New Password: ", "newPassword1")<br />
                    @Html.Password("newPassword1")
                    @Html.ValidationMessage("newPassword1")
                </div>
                <div>
                    @Html.Label("Confirm New Password: ", "newPassword2")<br />
                    @Html.Password("newPassword2")
                    @Html.ValidationMessage("newPassword2")
                </div>
                <div>
                    <input type="submit" value="Reset Password" />
                </div>
            </form>
        }
    </body>
</html>`

当用户点击 forgotPassword.cshtml 发送给他们的邮件中的链接时，他们将被直接带到 passwordReset.chtml，该页面显示如图[图 7-17](#fig_7_17) 所示的表单。密码重置令牌在 URL 中作为带有键`resetToken`的 QueryString 传递。

![images](images/0717.jpg)

***图 7-17。**重置密码表单*

然后，用户输入新密码两次，以确保输入正确并提交表单。如果表单验证通过，POST 请求处理程序试图通过调用`WebSecurity.ResetPassword()`方法来重置表单。如果该方法返回布尔值`true,`，则显示一条成功消息，否则用户会收到一条失败消息。

剩下的就是在登录页面上放置一个指向 forgotPassword.cshtml 的链接。将以下 html 添加到 login.cshtml 中的适当位置(参见[图 7-18](#fig_7_18) ):

`<div>
    </p><a href="forgotPassword">Forgotten password?</a></p>
</div>` ![images](images/0718.jpg)

***图 7-18。**“忘记密码了？”添加到登录页面的链接*

### 总结

WebMatrix 附带了一组助手，旨在帮助开发人员提供全面的安全性和成员资格流程。

在本章中，我们学习了如何初始化成员资格系统以使用 SQL Server Compact 数据库，以及如何利用数据库中可能已经存在的用户信息。我们还看到了如何为用户提供在站点上注册、登录、注销和更改密码的功能。我们创建了一个助手来在我们站点的任何页面中显示相关的帐户信息，并添加了代码来将单个页面和整个文件夹限制为经过身份验证的用户。

接下来，我们学习了如何使用角色来管理用户组，以及如何创建页面来帮助管理用户组。然后，我们看到了如何使用角色来限制对站点特定区域的访问。

最后，我们回顾了 ASP.NET 网页会员和安全系统的一些更高级的功能，包括存储额外的个人用户信息，通过电子邮件进行注册验证，以及处理忘记密码的用户。

在下一章中，我们将深入了解 WebMatrix 包管理器，以及如何使用它来实现第三方助手，以将社交网络和其他功能集成到我们的站点中。