# 23.过滤器第一部分

我在第 20 章中提到了过滤器，这样我就可以描述`ApiController`类实现的分派过程。在这一章中，我将深入描述过滤器是如何工作的，并演示如何使用它们来为 Web API 应用程序添加横切关注点。表 [23-1](#Tab1) 总结了本章内容。

表 23-1。

Chapter Summary

<colgroup><col> <col> <col></colgroup> 
| 问题 | 解决办法 | 列表 |
| --- | --- | --- |
| 向调度管道添加逻辑。 | 通过定义一个实现`IActionFilter`接口的属性来定义一个动作过滤器。将属性应用于需要逻辑的操作方法或控制器。 | 1–2 |
| 创建一个动作方法，而不必管理延续函数。 | 从`ActionFilterAttribute`类派生该类。 | three |
| 终止过滤器中的请求处理过程。 | 创建一个短路过滤器，生成一个`HttpResponseMessage`对象，而不是调用 continuation 函数。如果使用属性基类，那么设置`HttpActionContext.Response`属性。 | 4–6 |
| 列出已应用于操作方法的过滤器。 | 枚举筛选器管道。 | 7, 8, 14 |
| 对应用程序中的所有操作方法应用过滤器。 | 定义全局过滤器。 | 9, 10 |
| 将用户身份与请求相关联。 | 创建身份验证过滤器。 | 11–13 |

## 准备示例项目

我将继续使用我在第 19 章中创建的调度项目。本章不需要修改。

## 了解过滤器

过滤器将额外的逻辑注入到`ApiController`分派过程中，并提供一个简单而优雅的机制来实现在 MVC 模式中跨多个组件操作的特性，这被称为横切关注点。过滤器最常见的用途是应用身份验证和授权、处理错误以及测量性能。

过滤器是实现`IFilter`接口的属性，该接口在`System.Web.Http.` `Filters`名称空间中定义。以下是接口的定义:

`namespace System.Web.Http.Filters {`

`public interface IFilter {`

`bool AllowMultiple { get; }`

`}`

`}`

该接口定义的唯一成员是`AllowMultiple`属性，它指定是否可以使用特定过滤器的多个实例。直接使用`IFilter`接口是不常见的，因为有一组接口，它们都是从`IFilter`派生的，定义了不同种类的过滤器。表 [23-2](#Tab2) 列出了这些接口并描述了它们的使用方法。

Note

过滤器不应该用于执行属于动作方法的任务，这实质上意味着不要创建过滤器来处理请求，以便与存储库交互并生成结果。使用过滤器来替换或补充动作方法使得隔离特定的功能以进行单元测试变得更加困难。

表 23-2。

The Web API Filter Types and Interfaces

<colgroup><col> <col> <col></colgroup> 
| 过滤方式 | 连接 | 描述 |
| --- | --- | --- |
| 证明 | `IAuthenticationFilter` | 这种过滤器用于要求用户或客户端在执行操作方法之前进行身份验证。 |
| 批准 | `IAuthorizationFilter` | 这种过滤器用于限制特定用户或组对操作方法的访问。详见第 24 章。 |
| 行动 | `IActionFilter` | 这种过滤器用于操纵请求或响应。 |
| 例外 | `IExceptionFilter` | 这种过滤器用于处理由 action 方法或另一种过滤器抛出的异常。详见第 24 章。 |
| 推翻 | `IOverrideFilter` | 这种过滤器用于为单个操作方法定制其他过滤器的行为。详见第 24 章。 |

有相应的抽象属性类来实现表中列出的每一个接口，它们是开始使用过滤器的最简单的方法，尽管我也将向您展示如何直接从过滤器接口开始工作。我在本章中描述了动作和认证过滤器，在第 24 章中描述了其他类型。表 [23-3](#Tab3) 将过滤器放在上下文中。

表 23-3。

Putting Filters in Context

<colgroup><col> <col></colgroup> 
| 问题 | 回答 |
| --- | --- |
| 它们是什么？ | 过滤器允许在执行动作方法之前和之后将额外的逻辑插入到分派过程中。过滤器还可以缩短分派过程，以防止操作方法和其他过滤器被执行。有关详细信息，请参见“创建短路操作过滤器”一节。 |
| 你应该什么时候使用它们？ | 过滤器应该只用于包含不属于控制器或数据模型的逻辑，正如 MVC 模式在第 4 章中所描述的。 |
| 你需要知道什么？ | 过滤器可以作为属性应用于动作方法和控制器，或者通过`WebApiConfig.cs`文件全局应用。 |

## 使用动作过滤器

动作过滤器允许在动作方法执行前后执行额外的逻辑。这意味着您有机会更改`HttpRequestMessage`和`HttpResponseMessage`对象，或者执行跨越动作方法执行的任务，例如为调度过程计时，这是动作过滤器的标准示例(尽管我将在本章后面向您展示一些其他用途)。动作过滤器由`IActionFilter`接口定义，定义如下:

`using System.Diagnostics.CodeAnalysis;`

`using System.Net.Http;`

`using System.Threading;`

`using System.Threading.Tasks;`

`using System.Web.Http.Controllers;`

`namespace System.Web.Http.Filters {`

`public interface IActionFilter : IFilter {`

`Task<HttpResponseMessage> ExecuteActionFilterAsync(`

`HttpActionContext actionContext,`

`CancellationToken cancellationToken,`

`Func<Task<HttpResponseMessage>> continuation);`

`}`

`}`

在接下来的小节中，我将向您展示动作过滤器是如何工作的，以及创建动作过滤器的不同方法。在图 [23-1](#Fig1) 中，我已经更新了调度流程图，以显示动作过滤器和动作方法之间的关系。(在图中，我只展示了图的一部分，但是我将在本章的后面展示流程的完整视图。)

![A978-1-4842-0085-8_23_Fig1_HTML.jpg](A978-1-4842-0085-8_23_Fig1_HTML.jpg)

图 23-1。

Action filters and action methods in the ApiController dispatch process

关于这个图需要注意的重要一点是，动作过滤器在动作方法被调用之前被调用，之后，当`HttpResponseMessage`被创建并沿着组件链返回时被调用。表 [23-4](#Tab4) 将动作过滤器放入上下文中。

表 23-4。

Putting Action Filters in Context

<colgroup><col> <col></colgroup> 
| 问题 | 回答 |
| --- | --- |
| 它们是什么？ | 动作过滤器提供了一种在执行动作方法之前和之后修改`HttpRequestMessage`和`HttpResponseMessage`对象的机制。 |
| 你应该什么时候使用它们？ | 应该谨慎使用操作过滤器，并且仅用于执行不包含业务逻辑的任务、对数据模型进行操作或执行身份验证或授权(由其他过滤器类型处理)。 |
| 你需要知道什么？ | 在 Web API 中，动作过滤器结合了 MVC 框架中动作和结果过滤器的功能。 |

### 通过实现 IActionFilter 创建操作筛选器

正如我在上一节中解释的那样，`IActionFilter`接口定义了一个方法:`ExecuteActionFilterAsync`。这个方法看起来比实际更复杂，因为接口的目标是让您定义在调用 action 方法之前和之后要执行的工作。最好的解释方式是用一个例子，清单 23-1 显示了`TimeAttribute.cs`文件的内容，我把它添加到了`Infrastructure`文件夹中。

清单 23-1。时间属性. cs 文件的内容

`using System;`

`using System.Diagnostics;`

`using System.Net.Http;`

`using System.Threading;`

`using System.Threading.Tasks;`

`using System.Web.Http.Controllers;`

`using System.Web.Http.Filters;`

`namespace Dispatch.Infrastructure {`

`public class TimeAttribute : Attribute, IActionFilter {`

`public async Task<HttpResponseMessage> ExecuteActionFilterAsync(`

`HttpActionContext actionContext,`

`CancellationToken cancellationToken,`

`Func<Task<HttpResponseMessage>> continuation) {`

`Stopwatch sw = Stopwatch.StartNew();`

`HttpResponseMessage result = await continuation();`

`long elapsedTicks = sw.ElapsedTicks;`

`result.Headers.Add("Elapsed-Time", elapsedTicks.ToString());`

`System.Diagnostics.Debug.WriteLine("Elapsed time: {0} ticks, {1} {2}",`

`elapsedTicks, actionContext.Request.Method,`

`actionContext.Request.RequestUri);`

`return result;`

`}`

`public bool AllowMultiple {`

`get { return false; }`

`}`

`}`

`}`

`TimeAttribute`类是一个动作过滤器:它派生自`Attribute`类，并且实现了`IActionFilter`接口。这个过滤器使用`StopWatch`类来测量执行动作方法所花费的时间。(正如我在“理解过滤器范围”一节中解释的那样，这是对实际测量内容的简化。)

Tip

`StopWatch`类是一个高分辨率的计时器，对于测量少量的时间很有用，比如一个方法的调用。我在清单 23-1 中读取的`elapsedTicks`属性返回自计时器启动以来的滴答数，其中滴答是`StopWatch`类在当前系统上可以测量的最小持续时间。时钟周期的长度在不同的系统之间会有所不同，而`Frequency`字段会告诉您当前硬件上每秒钟有多少时钟周期。我很高兴在这一章中使用 ticks，因为我的重点是过滤器如何工作，但对于高分辨率计时的更多细节，请参见 [`http://msdn.microsoft.com/en-us/library/system.diagnostics.stopwatch.aspx`](http://msdn.microsoft.com/en-us/library/system.diagnostics.stopwatch.aspx) 。

为了执行我的测量，我需要利用在行动方法执行之前和之后执行工作的机会。在执行之前，我需要启动一个计时器。在执行之后，我需要读取计时器的值并报告运行时间，这是通过向`HttpResponseMessage`对象添加一个标题并向 Visual Studio 输出窗口写入一条消息来完成的。

当执行`ExecuteActionFilterAsync`方法时，你做的第一件事是在动作之前执行你想做的工作。清单 23-1 中的过滤器使用`StopWatch`类来测量时间，所以我要做的唯一工作就是创建并启动一个新的计时器实例，我只需一步就可以完成，如下所示:

`...`

`Stopwatch sw =``Stopwatch.StartNew()`T2】

`...`

在调用 action 方法之前，遵循要执行的语句，您可以使用`Func<Task<System.Net.Http.HttpResponseMessage>>`参数产生的`Task`。这是一个复杂的类型:它是一个函数，当被调用时，返回一个产生一个`HttpResponse`消息的`Task`。或者，换句话说，调用`continuation`参数执行动作方法，动作过滤器调用该方法来获得`HttpResponse`消息，如下所示:

`...`

`HttpResponseMessage result =``await continuation()`T2】

`...`

当延续`Task`完成时，动作过滤器可以操纵响应。对于这个动作过滤器，这意味着向`HttpResponse`消息添加一个头，并向 Visual Studio 输出窗口写出一条消息。

`...`

`long elapsedMs = sw.ElapsedMilliseconds;`

`result.Headers.Add("Elapsed-Time", elapsedMs.ToString());`

`System.Diagnostics.Debug.WriteLine("Elapsed time: {0} ms, {1} {2}",`

`elapsedMs,``actionContext.Request.Method, actionContext.Request.RequestUri`T2】

`return result;`

`...`

Tip

由`ExecuteFilterAsync`方法返回的结果是一个`Task`，当它完成时将产生一个`HttpResponseMessage`对象。我在方法实现中使用了`async`和`await`关键字，这意味着我能够返回一个`HttpResponseMessage`对象并依赖于。NET 运行时将其转换成一个`Task<HttpResponseMessage>`。

如果您需要关于请求的更多信息，比如控制器、动作方法或其参数的细节，那么您可以通过作为参数传递给`IActonFilter.ExecuteFilterAsync`方法的`HtpActionContext`对象来获得。`HttpActionContext`类定义了表 [23-5](#Tab5) 中所示的属性。在动作过滤器中，我使用`Request`属性来获取`HttpRequestMessage`对象，这样我就可以从请求中获取 HTTP 动词和 URL。

表 23-5。

The Properties Defined by the HttpActionContext ClassHttpActionContext Class

<colgroup><col> <col></colgroup> 
| 名字 | 描述 |
| --- | --- |
| `ActionArguments` | 返回一个`Dictionary<string, object>`，它将动作方法参数的名称映射到它们的类型。 |
| `ActionDescriptor` | 返回一个描述将要调用的动作方法的`HttpActionDescriptor`对象。 |
| `ControllerContext` | 返回一个描述控制器的`HttpControllerContext`对象，在该控制器中定义了动作方法。 |
| `ModelState` | 返回一个在模型验证过程中使用的`ModelStateDictionary`对象，我在第 18 章的[中描述过。](18.html) |
| `Request` | 返回描述当前请求的`HttpRequestMessage`对象。 |
| `RequestContext` | 返回提供请求补充信息的`HttpRequestContext`对象。 |
| `Response` | 返回将用于向客户端产生响应的`HttpResponseMessage`对象。这仅在调度过程的短路期间设置，如“创建短路操作过滤器”一节中所述。 |

#### 应用操作过滤器

动作过滤器作为属性应用于单个动作方法或控制器类。将过滤器应用于控制器相当于将其应用于控制器中的每一个动作方法，您可以看到我是如何将前一节中的`Time`属性应用于清单 23-2 中的`Products`控制器的。(您也可以全局应用过滤器，在这种情况下，它们将应用于所有控制器中的所有动作方法——有关详细信息，请参见“了解过滤器范围”一节。)

Tip

我已经将过滤器应用于 RESTful 控制器，但是它们可以在任何从`ApiController`类派生的 Web API 控制器上工作。当您直接从`IHttpController`界面创建自己的控制器时，过滤器不可用。

清单 23-2。对 ProductsController.cs 文件应用筛选器

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Web.Http;`

`using Dispatch.Models;`

`using Dispatch.Infrastructure;`

`namespace Dispatch.Controllers {`

`[Time]`

`public class ProductsController : ApiController {`

`private static List<Product> products = new List<Product> {`

`new Product {ProductID = 1, Name = "Kayak", Price = 275M },`

`new Product {ProductID = 2, Name = "Lifejacket", Price = 48.95M },`

`new Product {ProductID = 3, Name = "Soccer Ball", Price = 19.50M },`

`new Product {ProductID = 4, Name = "Thinking Cap", Price = 16M },`

`};`

`public IEnumerable<Product> Get() {`

`return products;`

`}`

`public Product Get(int id) {`

`return products.Where(x => x.ProductID == id).FirstOrDefault();`

`}`

`public Product Post(Product product) {`

`product.ProductID = products.Count + 1;`

`products.Add(product);`

`return product;`

`}`

`}`

`}`

您可以通过启动应用程序、导航到`/Home/Index` URL 并依次单击 Get All、Get One 和 Post 按钮来测试动作过滤器。除了响应中的标头之外，操作筛选器还会将消息写入 Visual Studio 输出窗口，如下所示:

`Elapsed time: 147 ticks, GET` `http://localhost:49412/api/products/`

`Elapsed time: 132 ticks, GET` `http://localhost:49412/api/products/2`

`Elapsed time: 89 ticks, POST` `http://localhost:49412/api/products/`

您将看到显示不同的持续时间，这取决于您的硬件每秒可以测量的节拍数以及处理请求的速度。

### 使用便利操作过滤器基类

不是每个开发人员都喜欢在同一个方法中定义 before 和 after 语句。另一种方法——也是创建动作过滤器最常见的方法——是从`ActionFilterAttribute`类派生，该类实现了`ExecuteActionFilterAsync`来调用分离 before 和 after 方法，从而允许您分离代码语句。`ActionFilterAttribute`类定义了表 [23-6](#Tab6) 中描述的方法。

Note

还有两个额外的方法，`OnActionExecuting`和`OnActionExecuted`，它们由表中所示方法的基本实现调用。这些方法允许您编写过滤器代码，而不必担心使用`Task`对象以及`async`和`await`关键字。使用这些伪同步方法没有任何好处，我强烈建议您避免使用它们。

表 23-6。

The Methods Defined by the ActionFilterAttribute Class

<colgroup><col> <col></colgroup> 
| 名字 | 描述 |
| --- | --- |
| `OnActionExecutingAsync` | 在执行操作方法之前调用 |
| `OnActionExecutedAsync` | 在执行操作方法后调用 |

在清单 23-3 中，你可以看到我是如何更新了`TimeAttribute`类，使其从`ActionFilterAttribute`类派生而来。(这类似于我在[第 22 章](22.html)中创建的过滤器。)

清单 23-3。从 TimeAttrribute.cs 文件中的 ActionFilterAttribute 类派生

`using System.Diagnostics;`

`using System.Threading;`

`using System.Threading.Tasks;`

`using System.Web.Http.Controllers;`

`using System.Web.Http.Filters;`

`namespace Dispatch.Infrastructure {`

`public class TimeAttribute : ActionFilterAttribute {`

`private static readonly string propKey =`

`"Dispatch.Infrastructure.TimeAttribute.StopWatch";`

`public override Task OnActionExecutingAsync(HttpActionContext actionContext,`

`CancellationToken cancellationToken) {`

`return Task.Factory.StartNew(() => {`

`actionContext.Request.Properties.Add(propKey, Stopwatch.StartNew());`

`});`

`}`

`public override Task OnActionExecutedAsync(HttpActionExecutedContext`

`actionExecutedContext, CancellationToken cancellationToken) {`

`return Task.Factory.StartNew(() => {`

`if (actionExecutedContext.Request.Properties.ContainsKey(propKey)) {`

`Stopwatch sw =`

`((Stopwatch)actionExecutedContext.Request.Properties[propKey]);`

`long elapsedTicks = sw.ElapsedTicks;`

`actionExecutedContext.Response.Headers.Add("Elapsed-Time",`

`elapsedTicks.ToString());`

`System.Diagnostics.Debug.WriteLine(`

`"Elapsed time: {0} ticks, {1} {2}", elapsedTicks,`

`actionExecutedContext.Request.Method,`

`actionExecutedContext.Request.RequestUri);`

`}`

`});`

`}`

`}`

`}`

从`ActionFilterAttribute`类派生一个过滤器允许你将之前和之后的代码分离到不同的方法中，但是这增加了它自身的复杂性。

Tip

直接使用`IActionFilter`接口会产生我认为更简单、更优雅的代码，但是在其他开发人员维护的项目中，我使用`ActionFilterAttribute`类，因为使用 before 和 after 方法比使用`async`和`await`关键字更容易理解，这些关键字在企业开发团队中还没有被广泛接受或理解。

为了提高性能，filters 类的实例用于处理多个请求，并且可以用于并发处理请求。这意味着如果您需要将上下文信息从`OnActionExecutingAsync`方法传递到`OnActionExecutedAsync`方法，您必须避免使用实例变量作为状态数据。在我的示例动作过滤器中，我需要的上下文是`StopWatch`对象，它在`OnActionExecutingAsync`中启动，在`OnActionExecutedAsync`中读取。

您可以使用`HttpRequestMessage.Properties`属性来访问用于存储特定于请求的状态数据的集合。`HttpRequestMessage`对象在整个调度过程中持续存在，这意味着您可以在执行 action 方法之前使用它存储对象，如下所示:

`...`

`actionContext.Request.Properties.Add(propKey, Stopwatch.StartNew());`

`...`

然后在执行操作方法后检索它们，如下所示:

`...`

`Stopwatch sw = ((Stopwatch)actionExecutedContext.Request.Properties[propKey]);`

`...`

处理请求的任何其他 Web API 组件都可以使用状态数据。这意味着您需要确保用于存储状态数据的键不太可能在其他地方被复制。我将状态数据键名基于存储它们的类，如下所示:

`...`

`private static readonly string propKey =`

`"Dispatch.Infrastructure.TimeAttribute.StopWatch";`

`...`

STATE DATA PROBLEMS

`HttpRequestMessage.Properties`集合很有用，因为 Web API 编程模型不提供遗留 ASP.NET 平台中可用的状态数据特性。

`HttpRequestMessage`对象不是唯一定义了`Properties`集合的类。类似的集合在 Web API 类层次结构中是可用的，包括`HttpActionDescriptor`、`HttpControllerDescriptor`和`HttpConfiguration`类。

当状态数据由同一个对象存储和检索时，使用这些属性集合就可以了，如清单 23-3 中的动作过滤器。这些集合的另一个用途是将数据从一个组件传递到另一个组件——这是我建议您避免的。

问题是属性集合中包含的状态数据在存储数据的组件和检索数据的组件之间产生了紧密耦合。在这种情况下，您必须在您的应用程序中使用这两个组件——这使得在没有弄清楚状态数据的私有含义并重新创建或替换它的情况下，很难创建单个接口的自定义实现。

我建议您避免使用这种状态数据，除非它包含在单个类中。事实上，我认为使用属性集合来协调组件是一种非常危险的技术，所以我在本书中描述的所有类中都省略了`Properties`属性。

`ActionFilterAttribute`类通过`HttpActionExecutedContext`类为`OnActionExecutedAsync`方法提供上下文信息。除了通过`HttpActionContext`类提供的上下文之外，`HttpActionExecutedContext`类还提供了由 continuation 类抛出的任何异常的详细信息。我将在第 24 章的[和第 25 章](24.html)的[中解释如何使用过滤器处理异常。表](25.html) [23-7](#Tab7) 显示了由`HttpActionExecutedContext`类定义的属性。

表 23-7。

The Properties Defined by the HttpActionExecutedContext Class

<colgroup><col> <col></colgroup> 
| 名字 | 描述 |
| --- | --- |
| `ActionContext` | 这将返回`ApiController`传递给`ExecuteActionFilterAsync`方法的`HttpActionContext`。 |
| `Exception` | 该属性设置为执行延续任务时发生的任何异常。 |
| `Request` | 这将返回与响应相关联的`HttpRequestMessage`对象。 |
| `Response` | 这将返回由延续任务生成的`HttpResponseMessage`对象。 |

在`TimeAttribute`类中，我使用`HttpActionExecutedContext.Request`属性来获取`HttpRequestMessage`和`HttpResponseMessage`对象。通过`HttpRequestMessage`对象，我可以访问作为状态数据存储的`StopWatch`对象，以及包含在写入 Visual Studio 输出窗口的消息中的请求 URL 和动词。对象允许我给响应添加一个头。

`...`

`actionExecutedContext.Response` `.Headers.Add("Elapsed-Time", elapsedTicks.ToString());`

`System.Diagnostics.Debug.WriteLine("Elapsed time: {0} ticks, {1} {2}",`

`elapsedTicks,``actionExecutedContext.Request`T2】

`actionExecutedContext.Request` `.RequestUri);`

`...`

### 创建短路动作过滤器

动作过滤器不必是分派过程的被动观察者；他们也可以是积极的参与者，尽管您必须小心不要使用动作过滤器来执行应该在动作方法中定义的工作。作为演示，我将`CounterAttribute.cs`文件添加到了`Infrastructure`文件夹中，并使用它来定义清单 23-4 中所示的动作文件管理器。

清单 23-4。CounterAttribute.cs 文件的内容

`using System;`

`using System.Diagnostics;`

`using System.Net;`

`using System.Net.Http;`

`using System.Threading;`

`using System.Threading.Tasks;`

`using System.Web.Http.Controllers;`

`using System.Web.Http.Filters;`

`namespace Dispatch.Infrastructure {`

`public class CounterAttribute : Attribute, IActionFilter {`

`private static int counter = 0;`

`private static int limit;`

`public CounterAttribute(int requestLimit) {`

`limit = requestLimit;`

`}`

`public Task<HttpResponseMessage> ExecuteActionFilterAsync(`

`HttpActionContext actionContext,`

`CancellationToken cancellationToken,`

`Func<Task<HttpResponseMessage>> continuation) {`

`if (counter < limit) {`

`Debug.WriteLine("Request {0} of {1}", counter, limit);`

`counter++;`

`return continuation();`

`} else {`

`HttpResponseMessage response = actionContext.Request.`

`CreateErrorResponse(HttpStatusCode.ServiceUnavailable,`

`"Limit Reached");`

`return Task.FromResult<HttpResponseMessage>(response);`

`}`

`}`

`public bool AllowMultiple {`

`get { return false; }`

`}`

`}`

`}`

我已经直接从`IActionFilter`接口实现了这个过滤器，并定义了一个计数器来指定允许的最大请求数，在此之后，错误消息将返回给客户端。这不是你在真实项目中会做的事情，但它让我演示了一些重要的动作过滤技术。(在“从 ActionFilterAttribute 类派生过滤器”一节中，我演示了如何在从`ActionFilterAttribute`类派生时创建相同的效果。)

Caution

通过应用动作过滤器来修补麻烦的动作方法可能很有诱惑力。作为一个快速解决方案，这很好，但是我建议谨慎地这样做，并确保您花时间回到代码中，并将逻辑集成到它所属的地方:动作方法或模型。依靠动作过滤器来执行属于动作方法的工作使得执行单元测试变得更加困难，因为您不能再只测试动作方法—您必须一起测试过滤器和动作方法的组合功能。这也使得其他开发人员更难管理代码，因为理解如何处理请求需要弄清楚动作方法和动作过滤器是如何交互的。

在`ExecuteActionFilterAsync`方法中，我检查当前请求是否超过了指定的限制。如果没有达到限制，那么我调用 continuation 函数来创建`Task<HttpResponseMessage>`，我将它作为方法结果返回。这是正常的请求分派过程，它会导致 action 方法被调用。

如果请求超出了限制，那么我创建一个状态代码为 503(服务不可用)的`HttpResponseMessage`对象，并将其作为`ExecuteActionFilterAsync`方法的结果返回，而不调用 continuation 函数。这是一条捷径——动作为请求生成响应，并且在这样做的时候，阻止动作方法被调用，如图 [23-2](#Fig2) 所示。

![A978-1-4842-0085-8_23_Fig2_HTML.jpg](A978-1-4842-0085-8_23_Fig2_HTML.jpg)

图 23-2。

Short-circuiting the dispatch process with an action filter

当达到请求限制时，动作过滤器开始缩短分派过程，并直接生成`HttpResponseMessage`。

#### 测试短路过滤器

为了测试过滤器，我需要将它应用于控制器类，如清单 23-5 所示。

清单 23-5。对 ProductsController.cs 文件应用筛选器

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Web.Http;`

`using Dispatch.Models;`

`using Dispatch.Infrastructure;`

`namespace Dispatch.Controllers {`

`[Time]`

`public class ProductsController : ApiController {`

`private static List<Product> products = new List<Product> {`

`new Product {ProductID = 1, Name = "Kayak", Price = 275M },`

`new Product {ProductID = 2, Name = "Lifejacket", Price = 48.95M },`

`new Product {ProductID = 3, Name = "Soccer Ball", Price = 19.50M },`

`new Product {ProductID = 4, Name = "Thinking Cap", Price = 16M },`

`};`

`[Counter(3)]`

`public IEnumerable<Product> Get() {`

`return products;`

`}`

`public Product Get(int id) {`

`return products.Where(x => x.ProductID == id).FirstOrDefault();`

`}`

`public Product Post(Product product) {`

`product.ProductID = products.Count + 1;`

`products.Add(product);`

`return product;`

`}`

`}`

`}`

我已经将过滤器直接应用于无参数的`Get`动作方法，而不是整个控制器。要执行测试，启动应用程序并使用浏览器导航到`/Home/Index` URL。单击“全部获取”按钮四次，您将在 Visual Studio 输出窗口中看到类似以下内容的消息:

`Request 0 of 3`

`Elapsed time: 86870 ticks, GET` `http://localhost:49412/api/products/`

`Request 1 of 3`

`Elapsed time: 3196 ticks, GET` `http://localhost:49412/api/products/`

`Request 2 of 3`

`Elapsed time: 2220 ticks, GET` `http://localhost:49412/api/products/`

`Elapsed time: 7077 ticks, GET` `http://localhost:49412/api/products/`

对于第四次及后续请求，客户端将显示 503(服务不可用)消息，如图 [23-3](#Fig3) 所示。

![A978-1-4842-0085-8_23_Fig3_HTML.jpg](A978-1-4842-0085-8_23_Fig3_HTML.jpg)

图 23-3。

The effect of a short-circuiting action filter

#### 从 ActionFilterAttribute 类派生筛选器

创建从`ActionFilterAttribute`类派生的短路过滤器的技术略有不同，因为您不负责执行 continuation 函数。清单 23-6 显示了我如何修改了`CounterAttribute`类，使其从`ActionFilterAttribute`派生而来。

清单 23-6。从 CounterAttribute.cs 文件中的 ActionFilterAttribute 类派生

`using System;`

`using System.Diagnostics;`

`using System.Net;`

`using System.Net.Http;`

`using System.Threading;`

`using System.Threading.Tasks;`

`using System.Web.Http.Controllers;`

`using System.Web.Http.Filters;`

`namespace Dispatch.Infrastructure {`

`public class CounterAttribute : ActionFilterAttribute {`

`private static int counter = 0;`

`private static int limit;`

`public CounterAttribute(int requestLimit) {`

`limit = requestLimit;`

`}`

`public override Task OnActionExecutingAsync(HttpActionContext actionContext,`

`CancellationToken cancellationToken) {`

`return Task.Factory.StartNew(() => {`

`if (counter < limit) {`

`Debug.WriteLine("Request {0} of {1}", counter, limit);`

`counter++;`

`} else {`

`actionContext.Response = actionContext.Request.CreateErrorResponse(`

`HttpStatusCode.ServiceUnavailable, "Limit Reached");`

`}`

`});`

`}`

`}`

`}`

我只需要重写`OnActionExecutingAsync`方法，因为我需要在请求到达 action 方法之前拦截它们。为了阻止动作方法被执行，我创建了一个`HttpResponseMessage`对象，并使用它来设置`HttpActionContext.Response`方法，如下所示:

`...`

`actionContext.Response` `= actionContext.Request.CreateErrorResponse(`

`HttpStatusCode.ServiceUnavailable, "Limit Reached");`

`...`

在调用了`OnActionExecutingAsync`方法之后，`ActionFilterAttribute`类实现检查是否已经设置了`HttpActionContext.Response`属性。如果`Response`属性是`null`，那么`OnActionExecutedAsync`方法被正常调用。如果`Response`属性不是`null`，那么它被设置的`HttpResponseMessage`对象被用作其`ExecuteActionFilterAsync`实现的结果，这就产生了短路效果。

## 了解过滤器管道

如果您眼尖的话，您会注意到上一节中两个动作过滤器的输出中的一些东西，这些东西提示了过滤器的执行方式。在我继续描述其他类型的过滤器之前，我将深入研究过滤器在执行时如何被排序到过滤器管道中的细节。以下是上一个示例的输出:

`Request 0 of 3`

`Elapsed time: 86870 ticks, GET` `http://localhost:49412/api/products/`

`Request 1 of 3`

`Elapsed time: 3196 ticks, GET` `http://localhost:49412/api/products/`

`Request 2 of 3`

`Elapsed time: 2220 ticks, GET` `http://localhost:49412/api/products/`

`Elapsed time: 7077 ticks, GET` `http://localhost:49412/api/products/`

线索是突出显示的语句，它表明尽管`Counter`过滤器返回 503(服务不可用)响应，但`Time`过滤器仍在处理请求。这是因为在调度管道中，`Time`过滤器出现在`Counter`过滤器之前，如图 [23-4](#Fig4) 所示。

![A978-1-4842-0085-8_23_Fig4_HTML.jpg](A978-1-4842-0085-8_23_Fig4_HTML.jpg)

图 23-4。

The sequence of action filters in the request pipeline

过滤器被组织成特定的序列，并且在过滤器管道中，`Time`过滤器出现在`Counter`过滤器之前。即使`Counter`过滤器缩短了分派过程，它创建的`HttpResponseMessage`对象还是会沿着管道传递回出现在它之前的过滤器。表 [23-8](#Tab8) 将过滤管道放入上下文中。

表 23-8。

Putting the Filter Pipeline in Context

<colgroup><col> <col></colgroup> 
| 问题 | 回答 |
| --- | --- |
| 这是什么？ | 筛选器管道提供有关应用于操作方法的筛选器的信息，按范围排序。 |
| 你应该什么时候使用它？ | 过滤器管道只对诊断目的或当向直接从`IHttpController`接口而不是`ApiController`类派生的控制器添加过滤器支持时感兴趣。 |
| 你需要知道什么？ | 过滤器管道考虑了范围对过滤器执行顺序的影响，但没有考虑`ApiController`类按类型组织过滤器的方式。在本章的最后，我将向您展示如何对管道进行重新排序。 |

### 显示过滤器管道

您可以通过`HttpActionContext.GetFilterPipeline`方法深入了解过滤器管道，该方法返回一个`FilterInfo`对象的枚举。每个`FilterInfo`对象使用表 [23-9](#Tab9) 中所示的属性提供一个过滤器的细节。

表 23-9。

The Properties Defined by the FilterInfo Class

<colgroup><col> <col></colgroup> 
| 名字 | 描述 |
| --- | --- |
| `Instance` | 返回过滤器对象，该对象实现了`IFilter`接口。 |
| `Scope` | 返回过滤器的范围，使用`FilterScope`枚举中的值表示。有关详细信息，请参见“了解过滤器范围”一节。 |

检查过滤器管道最简单的方法是通过从`ApiControllerActionSelector`类派生并覆盖`SelectAction`方法来显示关于过滤器的信息，从而创建一个自定义的`IHttpActionSelector`接口实现。清单 23-7 显示了我添加到`Infrastructure`文件夹中的`PipelineActionSelector.cs`文件的内容。

清单 23-7。PipelineActionSelector.cs 文件的内容

`using System.Collections.Generic;`

`using System.Diagnostics;`

`using System.Web.Http.Controllers;`

`using System.Web.Http.Filters;`

`namespace Dispatch.Infrastructure {`

`public class PipelineActionSelector : ApiControllerActionSelector {`

`public override HttpActionDescriptor SelectAction(HttpControllerContext`

`controllerContext) {`

`HttpActionDescriptor action = base.SelectAction(controllerContext);`

`IEnumerable<FilterInfo> filters = action.GetFilterPipeline();`

`foreach (FilterInfo filter in filters) {`

`Debug.WriteLine("Scope {0} Type: {1}",`

`filter.Scope, filter.Instance.GetType().Name);`

`}`

`return action;`

`}`

`}`

`}`

我仍然依赖于`SelectionAction`方法的基本实现，但是我也写出了描述每个过滤器的消息。清单 23-8 显示了我是如何将`PipelineActionSelector`类注册为 Web API 将使用的`IHttpActionSelector`接口的实现的。

清单 23-8。在 WebApiConfig.cs 文件中注册自定义操作选择器

`using System.Web.Http;`

`using System.Web.Http.Controllers;`

`using Dispatch.Infrastructure;`

`namespace Dispatch {`

`public static class WebApiConfig {`

`public static void Register(HttpConfiguration config) {`

`config.Routes.MapHttpRoute(`

`name: "ActionMethods",`

`routeTemplate: "api/nrest/{controller}/{action}/{day}",`

`defaults: new { day = RouteParameter.Optional }`

`);`

`config.Routes.MapHttpRoute(`

`name: "DefaultApi",`

`routeTemplate: "api/{controller}/{id}",`

`defaults: new { id = RouteParameter.Optional }`

`);`

`config.Services.Replace(typeof(IHttpActionSelector),`

`new PipelineActionSelector());`

`}`

`}`

`}`

要测试自定义操作选择器并获得过滤器管道的详细信息，请启动应用程序并使用浏览器导航到`/Home/Index` URL。单击“全部获取”按钮，您将在 Visual Studio 输出窗口中看到类似以下内容的消息:

`Scope Controller Type: TimeAttribute`

`Scope Action Type: CounterAttribute`

`Request 0 of 3`

`Elapsed time: 87523 ticks, GET` `http://localhost:49412/api/products/`

在接下来的部分中，我将解释为什么过滤器是这样组织的。当我继续描述不同种类的过滤器时，我将再次访问管道并演示它们是如何组织的。

Note

过滤器管道没有完全反映其他类型过滤器的执行顺序，但是我将在本章末尾修改代码，以便按类型对过滤器进行排序。

### 了解筛选器范围

有三种方法可以应用过滤器，这决定了它所应用到的请求，称为过滤器的范围。`FilterScope`枚举为每个作用域定义了一个值，如表 [23-10](#Tab10) 中所述。

表 23-10。

The Values Defined by the FilterScope Enumeration

<colgroup><col> <col></colgroup> 
| 范围 | 描述 |
| --- | --- |
| `Global` | 对所有请求执行过滤器。 |
| `Controller` | 对于以应用了该过滤器的控制器所定义的任何动作方法为目标的请求，执行该过滤器。 |
| `Action` | 对于以应用了过滤器的操作方法为目标的请求，将执行过滤器。 |

过滤器首先按类型排序，然后按范围排序。我在表 [23-2](#Tab2) 中列出了不同的过滤器类型，但以下是三种最常用类型的执行顺序:

Authentication filters   Authorization filters   Action filters  

这个顺序是由`ApiController`类执行的，并且不能通过实现我在[第 22 章](22.html)中描述的接口来改变。与 MVC 框架不同，没有办法控制具有相同范围的相同类型的过滤器的执行顺序。

Note

还有另外两种过滤器——错误过滤器和覆盖过滤器——它们的工作方式不同，我在第 24 章中进行了描述。

在分派过程中，`ApiController`按照类型对管道中的过滤器进行排序，然后按照范围进行排序。这就是为什么`Time`过滤器在过滤器管道中出现在`Counter`过滤器之前——它被应用于控制器，并且控制器范围的过滤器优先于那些直接应用于动作方法的过滤器。

Tip

范围优先规则的效果意味着我的`Time`过滤器不仅仅测量动作方法的执行；它还测量执行过滤器管道中随后出现的任何过滤器所花费的时间。

#### 创建全局过滤器

我演示了控制器和动作方法范围的过滤器；为了完成这一集，我需要向您展示如何创建一个全局特征。清单 23-9 显示了`SayHelloAttribute.cs`文件的内容，我将它添加到了`Infrastructure`文件夹中。

清单 23-9。SayHelloAttribute.cs 文件的内容

`using System.Diagnostics;`

`using System.Threading;`

`using System.Threading.Tasks;`

`using System.Web.Http.Controllers;`

`using System.Web.Http.Filters;`

`namespace Dispatch.Infrastructure {`

`public class SayHelloAttribute : ActionFilterAttribute {`

`public string Message { get; set; }`

`public override Task OnActionExecutingAsync(HttpActionContext actionContext,`

`CancellationToken cancellationToken) {`

`Debug.WriteLine("SayHello: {0}", (object)Message ?? "Hello");`

`return Task.FromResult<object>(null);`

`}`

`}`

`}`

该文件包含一个筛选器，它只是将一条消息写入 Visual Studio 输出窗口，以便我可以演示筛选器优先级。

Note

事实上，除了记录和测量性能之外，动作过滤器没有多少通用用途。这是一个理解起来很重要的特性，但是只有当您需要集成不完全适合 Web API/MVC 模型的功能时，这个特性才变得重要。

全局过滤器注册在`WebApiConfig.cs`文件中，如清单 23-10 所示。

清单 23-10。在 WebApiConfig.cs 文件中注册全局过滤器

`using System.Web.Http;`

`using System.Web.Http.Controllers;`

`using Dispatch.Infrastructure;`

`namespace Dispatch {`

`public static class WebApiConfig {`

`public static void Register(HttpConfiguration config) {`

`config.Routes.MapHttpRoute(`

`name: "ActionMethods",`

`routeTemplate: "api/nrest/{controller}/{action}/{day}",`

`defaults: new { day = RouteParameter.Optional }`

`);`

`config.Routes.MapHttpRoute(`

`name: "DefaultApi",`

`routeTemplate: "api/{controller}/{id}",`

`defaults: new { id = RouteParameter.Optional }`

`);`

`config.Services.Replace(typeof(IHttpActionSelector),`

`new PipelineActionSelector());`

`config.Filters.Add(new SayHelloAttribute { Message = "Global Filter" });`

`}`

`}`

`}`

要测试全局过滤器，启动应用程序并使用浏览器导航到`/Home/Index` URL。单击“全部获取”按钮，您将在 Visual Studio 输出窗口中看到类似以下内容的消息:

`Scope Global Type: SayHelloAttribute`

`Scope Controller Type: TimeAttribute`

`Scope Action Type: CounterAttribute`

`SayHello: Global Filter`

`Request 0 of 3`

`Elapsed time: 83963 ticks, GET` `http://localhost:49412/api/products/`

我已经强调了重要的信息。第一个显示`SayHelloAttribute`是管道中的第一个过滤器，第二个通过显示过滤器的输出出现在其他过滤器消息之前来确认这一点。

Tip

尽管我将全局过滤器创建为一个属性，但这不是必需的，因为过滤器没有直接应用于控制器或动作方法。然而，我更喜欢创建过滤器属性，因为这意味着我可以轻松地更改过滤器的范围，而不必修改其代码。

## 使用身份验证过滤器

顾名思义，身份验证过滤器允许您确保动作方法仅由已经过身份验证的客户端调用。大多数 Web API 应用程序将使用 ASP.NET 身份平台来执行身份验证，您在第 6 章中看到了如何使用过滤器来应用 ASP.NET 身份。表 [23-11](#Tab11) 将认证和过滤器放在上下文中。

无论作用域如何，在调用任何其他类型的过滤器和操作方法之前，都会首先调用身份验证过滤器。当认证失败时，分派过程被短路，并且从认证过滤器产生一个`HttpResponseMessage`,而不调用任何其他过滤器——或者目标动作方法。

Caution

在本节中，我创建了一些不安全的过滤器，只是为了演示这些类型的过滤器是如何工作的。不要在实际项目中使用这些过滤器。更一般地说，在创建自己的验证码之前，要深思熟虑——坚持使用 ASP.NET 提供的内置支持，除非你真的是编写安全代码的专家。很容易犯一个简单的错误，将您的 web 服务暴露给攻击者。我已经写了几十年的软件了(当然比我想叙述的时间要长)，在编写自定义安全代码之前，我仍然会犹豫不决。你也应该。

表 23-11。

Putting Authentication Filters in Context

<colgroup><col> <col></colgroup> 
| 问题 | 回答 |
| --- | --- |
| 它们是什么？ | 身份验证过滤器负责检查 HTTP 请求并识别与之相关的用户身份。没有用户可以关联的请求被短路。 |
| 你应该什么时候使用它们？ | 当您希望将对一个或多个操作方法的访问限制为由应用程序已知的用户发出的请求时，请应用身份验证筛选器。 |
| 你需要知道什么？ | 只要请求包含有效凭据，身份验证过滤器将允许所有用户访问。如第 24 章所述，如果您想限制特定用户的访问，请使用授权过滤器。 |

### 准备身份验证

如果您的应用程序需要定制交付给不同用户的功能和内容，那么您需要某种方式来管理用户的身份和安全凭证。这通常是通过 ASP.NET 身份系统(或者它的前身，ASP.NET 会员)来处理的，但是除了我为 SportsStore 应用程序给出的描述之外，我不想深入讨论身份的细节，所以在本章中，我将定义一个用户管理器类，我将用它来使用静态数据对用户进行身份验证和授权。清单 23-11 显示了我添加到`Infrastructure`文件夹中的`StaticUserManager.cs`类文件的内容。

清单 23-11。StaticUserManager.cs 文件的内容

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Security.Principal;`

`namespace Dispatch.Infrastructure {`

`public class StaticUserManager {`

`private static Dictionary<string, string[]> roles;`

`static StaticUserManager() {`

`roles = new Dictionary<string, string[]>();`

`roles.Add("admin", new string[] { "admins", "users" });`

`roles.Add("bob", new string[] { "users" });`

`}`

`public static IPrincipal AuthenticateUser(string user, string pass) {`

`if (roles.ContainsKey(user) && pass == "secret") {`

`return new StaticUser(user, roles[user]);`

`}`

`return null;`

`}`

`}`

`public class StaticUser: IIdentity, IPrincipal {`

`private string[] roles;`

`public StaticUser(string name, string[] rolesList) {`

`Name = name;`

`AuthenticationType = "Basic";`

`IsAuthenticated = true;`

`roles = rolesList;`

`}`

`public string AuthenticationType { get; private set; }`

`public bool IsAuthenticated { get; private set; }`

`public string Name { get; private set; }`

`public IIdentity Identity {`

`get { return this; }`

`}`

`public bool IsInRole(string role) {`

`return roles.Any(x => x == role);`

`}`

`}`

`}`

ASP.NET 使用两个接口来标识用户，`IPrincipal`和`IIdentity`，这两个接口都在`System.Security.Principal`名称空间中定义。`IIdentity`接口用于表示特定的用户，定义了表 [23-12](#Tab12) 所示的属性。

表 23-12。

The Properties Defined by the IIdentity Interface

<colgroup><col> <col></colgroup> 
| 名字 | 描述 |
| --- | --- |
| `AuthenticationType` | 返回一个字符串，该字符串指定用于创建标识的身份验证类型 |
| `IsAuthenticated` | 如果用户已经通过验证，则返回`true` |
| `Name` | 返回用户的名称 |

`IPrincipal`接口是一个`IIdentity`对象的包装器，提供关于用户所属角色的信息(角色用于授权，正如我在[第 24 章](24.html)中解释的)。`IPrincipal`接口定义了表 [23-13](#Tab13) 所示的属性和方法。

表 23-13。

The Properties Defined by the IPrincipal Interface

<colgroup><col> <col></colgroup> 
| 名字 | 描述 |
| --- | --- |
| `Identity` | 返回描述用户的`IIdentity`接口的实现 |
| `IsInRole(role)` | 如果用户被分配了指定的角色，则返回`true`,否则返回`false` |

用户管理系统通常提供它们自己的这些接口的实现，在清单 23-11 中，我定义了`StaticUser`类，它实现了这两个接口。`StaticUserManager`类提供了一个静态的`AuthenticateUser`方法，该方法接受用户名和密码作为其参数，并为已知用户返回一个`StaticUser`类的实例。我已经定义了两个用户和一些角色，创建了如表 [23-14](#Tab14) 所示的用户集合。当我描述授权过滤器时，我使用第 24 章中的角色。

表 23-14。

The Users, Passwords, and Roles Defined by the StaticUser Class

<colgroup><col> <col> <col></colgroup> 
| 用户 | 密码 | 角色 |
| --- | --- | --- |
| `admin` | `secret` | `admins`，`users` |
| `bob` | `secret` | `users` |

Caution

我已经将用户名、密码和角色硬编码到了`StaticUserManager`类中，这对于一个简单的例子来说很好，但在实际项目中会产生问题，因为这意味着每次有新用户或现有用户发生变化时，您都必须部署新版本的应用程序。

### 了解身份验证过滤器

身份验证过滤器负责确定发出请求的用户的身份。Web API 不指定如何识别用户，这意味着身份验证过滤器可用于将任何用户管理系统集成到您的 Web 服务中。对于大多数应用程序来说，ASP.NET 身份系统是处理认证(和授权，我在第 24 章中描述过)的最佳方式，但即使如此，理解 Web API 认证过程是如何工作的也是有用的，尤其是当您在自己的项目中没有得到预期的结果时。

认证过滤器由`IAuthenticationFilter`接口定义，定义如下:

`using System.Threading;`

`using System.Threading.Tasks;`

`namespace System.Web.Http.Filters {`

`public interface IAuthenticationFilter : IFilter {`

`Task AuthenticateAsync(HttpAuthenticationContext context,`

`CancellationToken cancellationToken);`

`Task ChallengeAsync(HttpAuthenticationChallengeContext context,`

`CancellationToken cancellationToken);`

`}`

`}`

认证过滤器有点奇怪。在请求被其他过滤器处理之前，`AuthenticateAsync`方法被调用，它的工作是识别与请求相关联的用户，或者创建一个向客户端报告错误的`IHttpActionResult`对象。

Note

在 MVC 框架应用程序中，通常通过将客户端重定向到应用程序的登录 URL 来处理身份验证失败。这种技术不适用于 HTTP web 服务，在这种情况下，不能假定客户端能够解析 HTML 或提示用户输入凭据。Web 服务可以用来认证用户——正如我在第 24 章中演示的那样——但是失败的认证应该通过向客户端返回 401(未授权)响应来处理。

奇怪的是由`AuthenticateAsync`方法产生的`IHttpActionResult`并不用于创建发送给客户端的响应。相反，这是`ChallengeAsync`方法的责任，该方法在请求被处理后被调用，即使用户已经被正确认证。通过一个例子，这将开始变得有意义——但不完全是，因为，正如我所说的，认证过滤器是奇怪的。

UNDERSTANDING BASIC HTTP AUTHENTICATION

我在本节中描述的示例身份验证过滤器使用基本的身份验证机制，该机制被定义为 HTTP 规范的一部分。它实现起来非常简单，但没有得到广泛应用，因为它有一些深刻的局限性，尤其是在没有 SSL 的情况下。

为了验证自身，客户端向请求添加一个`Authorization`报头，如下所示:

`Authorization: Basic YWRtaW46YWRtaW5TZWNyZXRY`

头的值是单词`Basic`，后跟一个 Base64 编码的字符串，其中包含由冒号(`:`字符)分隔的用户名和密码。解码字符串`YWRtaW46YWRtaW5TZWNyZXRY`会显示`admin:adminsecret`，这意味着客户端使用密码`adminSecret`将自己认证为用户`admin`。

如果客户端发送一个没有`Authorization`头或凭证不正确(指定不存在的用户或无效密码)的请求，那么 web 服务将返回一个 401(未授权)响应，其中包含一个指定基本身份验证机制的`WWW-Authenticate`，如下所示:

`WWW-Authenticate: Basic`

基本身份验证要求客户端以易于解码的格式向 web 服务发送用户凭证和每个请求。如果您发现自己正在使用基本身份验证(我真诚地希望您不要这样做)，那么请确保您的所有请求都通过 SSL 处理。

### 创建身份验证过滤器

为了演示认证过滤器如何工作，我在`Infrastructure`文件夹中创建了一个名为`CustomAuthenticationFilter.cs`的类文件，并用它来创建如清单 23-12 所示的过滤器。

Caution

这个过滤器依赖于基本的 HTTP 身份验证方案，除非使用 SSL，否则它完全不适合在实际项目中使用。使用这个示例只是为了理解身份验证过滤器机制是如何工作的，有关如何在实际项目中使用 ASP.NET 身份来处理用户身份验证的详细信息，请参见第 1 部分。

清单 23-12。CustomAuthenticationFilter.cs 文件的内容

`using System;`

`using System.Net;`

`using System.Net.Http;`

`using System.Net.Http.Headers;`

`using System.Text;`

`using System.Threading;`

`using System.Threading.Tasks;`

`using System.Web.Http.Filters;`

`using System.Web.Http.Results;`

`namespace Dispatch.Infrastructure {`

`public class CustomAuthenticationAttribute : Attribute, IAuthenticationFilter {`

`public Task AuthenticateAsync(HttpAuthenticationContext context,`

`CancellationToken cancellationToken) {`

`context.Principal = null;`

`AuthenticationHeaderValue authentication =`

`context.Request.Headers.Authorization;`

`if (authentication != null && authentication.Scheme == "Basic") {`

`string[] authData`

`= Encoding.ASCII.GetString(Convert.FromBase64String(`

`authentication.Parameter)).Split(':');`

`context.Principal`

`= StaticUserManager.AuthenticateUser(authData[0], authData[1]);`

`}`

`if (context.Principal == null) {`

`context.ErrorResult`

`= new UnauthorizedResult(new AuthenticationHeaderValue[] {`

`new AuthenticationHeaderValue("Basic") }, context.Request);`

`}`

`return Task.FromResult<object>(null);`

`}`

`public Task ChallengeAsync(HttpAuthenticationChallengeContext context,`

`CancellationToken cancellationToken) {`

`return Task.FromResult<object>(null);`

`}`

`public bool AllowMultiple {`

`get { return false; }`

`}`

`}`

`}`

这堂课有很多内容，所以我将在接下来的章节中分解细节。当我深入讨论细节时，要记住的最重要的事情是身份验证过滤器负责从请求中识别用户，而不是从用户那里获取凭证。

Tip

在你阅读完第 24 章之前，不要在你的项目中实现认证过滤器，在那一章中，我解释了如何创建一个消息处理程序来认证请求并重构过滤器以使用它生成的数据。

#### 正在检查请求

`AuthenticateAsync`方法的工作是检查请求，看它是否包含识别用户所需的信息。关于请求的信息通过`HttpAuthenticationContext`类的实例提供，该类定义了表 [23-15](#Tab15) 中所示的属性。

表 23-15。

The Properties Defined by the HttpAuthenticationContext Class

<colgroup><col> <col></colgroup> 
| 名字 | 描述 |
| --- | --- |
| `ActionContext` | 该属性返回描述被选择来执行请求的动作方法的`HttpActionContext`对象。 |
| `ErrorResult` | 如果请求不能被认证，这个属性被设置为`IHttpActionResult`接口的实现。 |
| `Principal` | 如果请求已经被认证，该属性被设置为`IPrincipal`接口的实现。设置`Principal`属性导致`HttpContext.Principal`属性也被设置，这使得认证过程的细节对其他组件可用——包括我在第 24 章的[中描述的授权过滤器。](24.html) |
| `Request` | 该属性返回描述当前请求的`HttpRequestMessage`对象。 |

为了创建一个有效的认证过滤器，`AuthenticateAsync`必须执行以下操作之一:

*   如果请求通过了身份验证，则将`HttpAuthenticationContext.Principal`属性设置为`IPrincipal`接口的一个实现。
*   如果请求不能被认证，将`HttpAuthenticationContext.ErrorResult`属性设置为`IHttpActionResult`接口的实现，这将产生 401(未授权)结果。

Web API 没有指定`AuthenticateAsync`方法用来认证用户的机制，但是对于 Web 服务来说，最常见的技术包括检查请求 cookies 或头部。对于 HTTP 基本认证，我需要寻找`Authorization`头，我是这样做的:

`...`

`context.Principal = null;`

`AuthenticationHeaderValue authentication = context.Request.Headers.Authorization;`

`if (authentication != null``&&`T2】

`string[] authData = Encoding.ASCII.GetString(Convert.FromBase64String(`

`authentication.Parameter)).Split(':');`

`context.Principal = StaticUserManager.AuthenticateUser(authData[0], authData[1]);`

`}`

`...`

`Authorization`标头由`AuthenticationHeaderValue`类表示，该类解析标头值并呈现`Scheme`和`Parameter`属性。当使用 HTTP 基本认证时，`Scheme`属性返回`Basic`，而`Parameter`属性将返回 Base64 编码的用户名和密码，我对其进行解码并传递给`StaticUserManager`类以认证用户并获得`IPrincipal`对象。

Tip

注意，在尝试验证请求之前，我显式地将`HttpAuthenticationContext.Principal`属性设置为`null`。如果 Web API 应用程序运行在传统的 ASP.NET 平台上，那么在调用`AuthenticateAsync`方法来表示来自 Windows 或其他地方的凭证时，`Principal`属性可能已经设置好了。可以定位并禁用其他来源的`IPrincipal`对象，但是我发现将`Principal`属性显式设置为`null`更加可靠。

为`Principal`值获取正确的值很重要，因为我用它来检查是否需要通过`ErrorResult`属性报告错误，如下所示:

`...`

`if (``context.Principal`T2】

`context.ErrorResult = new UnauthorizedResult(`

`new AuthenticationHeaderValue[] { new AuthenticationHeaderValue("Basic") },`

`context.Request);`

`}`

`...`

如果对`StaticUserManager.AuthenticateUser`方法的调用没有产生`IPrincipal`或者如果因为请求没有包含我需要的认证信息而没有调用该方法，那么我将`HttpAuthenticationContext.ErrorResult`属性设置为`UnauthorizedResult`类的一个实例。`UnauthorizedResult`类允许我指定`WWW-Authenticate`头，它告诉客户端应该使用哪个认证方案来认证用户。

#### 添加响应挑战

对于每个请求都调用`ChallengeAsync`方法，但是有两种情况需要处理。第一个是`AuthenticateAsync`方法已经为`HttpAuthenticationContext.ErrorResult`属性设置了一个值，它的作用是缩短调度过程并调用`ChallengeAsync`方法，而不调用任何其他过滤器或动作方法。

第二个场景是身份验证成功，调用了`ChallengeAsync`方法，这样过滤器就可以修改`HttpResponse`对象，通常是为了更容易对后续请求进行身份验证。

对于我的 HTTP 基本认证方案，我根本不需要采取任何行动，因为我在`AuthenticateAsync`方法中创建了失败认证所需的响应，这是我更喜欢创建认证过滤器的方式。您有时会遇到这样的代码，其中执行了`IHttpActionResult`,检查了状态代码，然后用新的结果替换，但这并不是真正必需的。如果您确实需要修改结果，您可以使用`HttpAuthenticationChallengeContext`参数，该参数定义了表 [23-16](#Tab16) 中所示的属性。

表 23-16。

The Properties Defined by the HttpAuthenticationChallengeContext Class

<colgroup><col> <col></colgroup> 
| 名字 | 描述 |
| --- | --- |
| `ActionContext` | 该属性返回描述被选择来执行请求的动作方法的`HttpActionContext`对象。 |
| `Request` | 该属性返回描述当前请求的`HttpRequestMessage`对象。 |
| `Result` | 该属性用于指定为请求生成`HttpResponseMessage`对象所要执行的`IHttpActionResult`。 |

#### 应用和测试身份验证过滤器

身份验证过滤器的应用方式与任何其他过滤器一样，可以指定全局、控制器和操作范围。清单 23-13 显示了我如何将我的示例过滤器应用于`Products`控制器。

清单 23-13。在 ProductsController.cs 文件中应用身份验证筛选器

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Web.Http;`

`using Dispatch.Models;`

`using Dispatch.Infrastructure;`

`namespace Dispatch.Controllers {`

`public class ProductsController : ApiController {`

`private static List<Product> products = new List<Product> {`

`new Product {ProductID = 1, Name = "Kayak", Price = 275M },`

`new Product {ProductID = 2, Name = "Lifejacket", Price = 48.95M },`

`new Product {ProductID = 3, Name = "Soccer Ball", Price = 19.50M },`

`new Product {ProductID = 4, Name = "Thinking Cap", Price = 16M },`

`};`

`[Time]`

`[Counter(3)]`

`public IEnumerable<Product> Get() {`

`return products;`

`}`

`[CustomAuthentication]`

`public Product Get(int id) {`

`return products.Where(x => x.ProductID == id).FirstOrDefault();`

`}`

`public Product Post(Product product) {`

`product.ProductID = products.Count + 1;`

`products.Add(product);`

`return product;`

`}`

`}`

`}`

我已经将过滤器应用于接受参数的`Get`方法版本。这样做的效果是允许控制器定义的所有其他动作方法成为任何请求的目标，但是将`Get`动作限制为已经被认证的请求。

Tip

认证过滤器不会限制特定用户的访问——这是授权过滤器的工作，我在第 24 章中描述过。身份验证过滤器将向任何经过身份验证的请求授予访问权限，而不考虑与之关联的用户身份。

要测试过滤器，启动应用程序并使用浏览器导航到`/Home/Index` URL。首先，单击 Get All 或 Post 按钮，确保未经身份验证的请求得到正确处理。要检查身份验证过程，请单击“获取一个”按钮。

客户端代码将通过向`/api/products/2` URL 发送一个 Ajax 请求来响应按钮的按下，这个请求将与接受`Products`控制器中的一个参数的`Get`方法相匹配。由`CustomAuthentication`过滤器定义的`AuthenticateAsync`方法将被调用，如果找不到`Authorization`头，将向客户端返回 401(未授权)响应。

几乎所有的浏览器都内置了对基本认证的支持，并会在收到包含设置为`Basic`的`WWW-Authenticate`报头的 401(未授权)响应时提示用户输入凭证，如图 [23-5](#Fig5) 所示。

![A978-1-4842-0085-8_23_Fig5_HTML.jpg](A978-1-4842-0085-8_23_Fig5_HTML.jpg)

图 23-5。

Chrome prompting the user for credentials

输入表 [23-14](#Tab14) 中的一个用户名和密码(或者是`admin`或者是`bob`，密码是`secret`)，Chrome 将重新向`/api/products/2` URL 发送它的 Ajax 请求，但这一次是使用所需的头。结果是认证过滤器会将`IPrincipal`对象设置在`HttpRequestMessage`对象上，调度管道不会短路。或者，您可以单击 Cancel 按钮，在这种情况下，401 状态代码被报告给客户端 JavaScript 代码，它将显示错误。

### 查看过滤器管道

如果你查看 Visual Studio 输出窗口，你会看到我在本章前面创建的`PipelineActionSelector`类已经写出了请求的过滤器管道。对于以我应用了身份验证过滤器的`Get`方法为目标的请求，输出如下所示:

`Scope Global Type: SayHelloAttribute`

`Scope Controller Type: TimeAttribute`

`Scope Action Type: CustomAuthenticationAttribute`

这个动作方法有三个过滤器:我在“创建全局过滤器”一节中设置的全局`SayHelloAttribute`过滤器，我在“使用动作过滤器”一节中创建的`TimeAttribute`过滤器，以及上一节中的`CustomAuthenticationAttribute`过滤器。

由`HttpActionContext.GetFilterPipeline`方法返回的管道考虑了范围对过滤器顺序的影响，但没有考虑过滤器类型的影响。正如我前面解释的，过滤器按以下顺序执行:

Authentication filters   Authorization filters   Action filters  

我在第 24 章的[中描述了两种特殊的过滤器——错误过滤器和覆盖过滤器，但是现在只关注列表中的三种过滤器就足够了。清单 23-14 显示了我如何更新了`PipelineActionSelector`类来处理过滤器管道并根据过滤器类型对其进行排序。](24.html)

Tip

请记住，过滤器管道是一个过滤器列表，只有当没有过滤器选择缩短调度过程时，才会执行该列表。

清单 23-14。在 PipelineActionSelector.cs 文件中按过滤器类型对管道进行排序

`using System.Collections.Generic;`

`using System.Diagnostics;`

`using System.Web.Http.Controllers;`

`using System.Web.Http.Filters;`

`using System.Linq;`

`namespace Dispatch.Infrastructure {`

`public class PipelineActionSelector : ApiControllerActionSelector {`

`public override HttpActionDescriptor SelectAction(HttpControllerContext`

`controllerContext) {`

`HttpActionDescriptor action = base.SelectAction(controllerContext);`

`IEnumerable<FilterInfo> filters = action.GetFilterPipeline();`

`IEnumerable<FilterInfo> orderedFilters =`

`GetFilters<IAuthenticationFilter>(filters)`

`.Concat(GetFilters<IAuthorizationFilter>(filters))`

`.Concat(GetFilters<IActionFilter>(filters));`

`foreach (FilterInfo filter in orderedFilters) {`

`Debug.WriteLine("Scope {0} Type: {1}", filter.Scope,`

`filter.Instance.GetType().Name);`

`}`

`return action;`

`}`

`private IEnumerable<FilterInfo> GetFilters<T>(IEnumerable<FilterInfo> filters) {`

`return filters.Where(f => f.Instance is T);`

`}`

`}`

`}`

我使用 LINQ 按类型排列过滤器，当您启动应用程序，导航到`/Home/Index` URL，并单击 Get One 按钮时，它会在 Visual Studio 输出窗口中产生以下消息:

`Scope Action Type: CustomAuthenticationAttribute`

`Scope Global Type: SayHelloAttribute`

`Scope Controller Type: TimeAttribute`

## 摘要

在本章中，我解释了过滤器在调度过程中的作用，并向您展示了两种类型的过滤器:动作过滤器和认证过滤器。我演示了如何读取过滤器管道，并解释了如何使用作用域和过滤器类型来为过滤器执行排序。在下一章中，我将继续描述 Web API 对过滤器的支持，并向您展示授权、异常和覆盖过滤器是如何工作的。