## 21

## Web 窗体 Triathlon 应用程序

在本章中，我们将使用它来重新创建我们在本书第二部分中看到的 triathlon 应用程序，从而完成我们的 Web 表单之旅。在这样做的时候，我们可以看到前面章节中的一些主题被具体应用并组合起来创建一个应用程序(尽管是一个简单的应用程序)。提醒一下，[图 21-1](#fig_21_1) 显示了 triathlon 应用程序的主页面。

![images](images/2101.jpg)

***图 21-1。**本书第二部分的铁人三项网络应用*

在我们构建应用程序时，有几点需要注意。首先，我故意不使用 jQuery，尽管我在前面的章节中敦促您利用它的特性。我这样做是因为 jQuery 对 web 应用程序生成的 HTML 进行操作，当考虑 Web 表单时，我们会考虑生成 HTML 的工具。添加 jQuery 可能会成为一个更好的应用程序，但却是一个更差的例子。

要注意的第二点是，使用 Web 窗体控件有许多不同的方式。不仅控件具有重叠的功能和特性，而且将 Web 窗体控件与 HTML 控件和静态 HTML 混合的能力为解决每个问题提供了广泛的方法。在这一章中，您将看到的方法是我的个人偏好(喜欢一种控件胜过另一种，或者我喜欢直接使用 LINQ)和我想要演示的技术(比如用 DataList 控件显示复杂的模板)的混合。你不应该把这些技术当成经典。相反，使用它们作为开发您自己的风格、偏好您自己的组件以及以最适合您的项目的方式获取和处理数据的起点。

### 创建项目

我们将从创建项目和设置基础开始。使用 Visual Studio 空 ASP.NET Web 应用程序模板创建一个名为 TriathlonApp 的项目。

#### 添加数据模型

接下来，按照第 9 章中的步骤创建一个实体框架数据模型。不要忘记导入存储过程，因为我们将在这个项目中使用它们。

#### 添加图像和样式

因为我不会像在第 10 章中那样使用 jQuery 为页面创建按钮，所以我创建了一组图像，这样我们就可以使用 Web Forms ImageButton 控件实现类似的外观。创建这些按钮图像并不容易，但是它们可以作为本书附带的免费源代码下载的一部分从 Apress.com 获得。我创建了一个名为`Images`的项目文件夹，并导入图像文件。

为了使用 CSS 设计内容更容易，我创建了一个`Styles`文件夹，并复制了我们在前面章节中使用的`Site.css`文件。我不会在这里列出这些样式(事实上，我们不会使用大多数样式)，但是您可以在源代码下载中看到这些内容。

#### 添加母版页和 Web 窗体页

我们将使用一个母版页来为应用程序中的页面提供一致的外观。你可以在第 9 章中了解更多关于母版页及其工作方式的信息。向应用程序添加一个新的母版页，并将其命名为`Site.master`。

现在我们已经创建了母版页，我们可以创建将使用它的页面。使用使用母版页模板的 Web 表单来创建名为`Events.aspx`、`EventEditor.aspx`、`Calculator.aspx`和`Performance.aspx`的页面。选择`Site.master`作为所有这些 Web 表单页面的母版页。

编辑 ea m，mch 的 ASPX 网页，这样就可以很明显的从内容中看出哪个是哪个。清单 21-1 展示了我对`Events.aspx`页面所做的添加。

***清单 21-1。**区分空白页面*

`<%@ Page Title="" Language="C#" MasterPageFile="~/Site.Master" AutoEventWireup="true"
CodeBehind="Events.aspx.cs" Inherits="TriathlonApp.Events" %>
<asp:Content ID="Content1" ContentPlaceHolderID="head" runat="server">
    **<title>Triathlon Events</title>**
</asp:Content>
<asp:Content ID="Content2" ContentPlaceHolderID="ContentPlaceHolder1" runat="server">
    **<h2>This is the Events.aspx page</h2>**
</asp:Content>`

在处理页面之前，我们将创建用于在页面之间切换的选项卡，这些更改将使我们更容易确定选项卡是否正常工作。

#### 检查项目

如果你已经完成了我们需要的所有添加，那么你的项目的解决方案浏览器窗口应该看起来与图 21-2 中所示的非常相似。

![images](images/2102.jpg)

***图 21-2。**示例项目的解决方案资源管理器窗口*

如果您在浏览器中查看其中一个页面，那么您应该会看到图 21-3 中所示的内容。

![images](images/2103.jpg)

***图 21-3。**events . aspx 页面的起点*

目前看起来不太像，但是我们会很快了解它的一些基本结构。

### 构建母版页

这个项目的母版页中有三个元素:页面顶部的静态图像横幅、允许用户选择应用程序中不同页面的选项卡，以及页面底部显示总计的页脚。我们将从最简单的开始，按照复杂程度来解决它们。

#### 添加横幅

横幅是页面的一个非常简单的附加物。它跨越页面宽度，显示一个简单的图像和一些文本。您可以在清单 21-2 中看到定义横幅的标记。

***清单 21-2。**给主页添加横幅*

`<%@ Master Language="C#" AutoEventWireup="true" CodeBehind="Site.master.cs"
Inherits="TriathlonApp.Site" %>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"![images](images/U002.jpg)
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html >
<head runat="server">
    <title></title>
    <asp:ContentPlaceHolder ID="head" runat="server">
    </asp:ContentPlaceHolder>
    **<link href="Styles/Site.css" rel="stylesheet" type="text/css" />**
</head>
<body>
<div style="background-color:White">
<form id="form1" runat="server">
<div>

    **<div class="header">**
        **<div class="title" id="titleDiv" runat="server">**
            **<asp:Image ID="Image1" runat="server" ImageUrl="~/Images/triathlon.png" />**
            **<h1>Triathlon Training Data</h1>**
        **</div>**
    **</div>**

    <div class="clear"></div>

*    <!-- tabs will go here -->*

    <asp:ContentPlaceHolder ID="ContentPlaceHolder1" runat="server">
    </asp:ContentPlaceHolder>

    <div class="clear"></div>

*    <-- footer will go here -->*

</div>
</form>
</div>
</body>
</html>`

我在页面上添加了一些基本的结构，但是最重要的添加内容是我用粗体标记的。我已经添加了对`Site.css`样式表的引用，这样我就可以引用它定义的 CSS 样式。

横幅本身包含一个图像控件。通常，我不会使用该控件，除非我需要在代码隐藏类中以编程方式更改图像的某些方面，但由于我们正在查看 Web 窗体和 Web 窗体控件，我想我应该在这里包含它。

我还添加了一些注释来显示我将在哪里添加标签和页脚的标记。这是因为当我们添加新元素时，我不必复制整个标记。

#### 添加页脚

页脚是另一个简单的添加。它只显示事件的总数、行驶的总距离和事件时间的总和。除了为应用程序提供一些视觉一致性和修饰之外，它没有任何价值。清单 21-3 显示了支持页脚的标记。

***清单 21-3。**为页脚添加标记*

`...
<div class="clear"></div>

**<div class="footer" id="footerDiv" runat="server">**
    **<h2>**
        **<asp:Label ID="footerLabel" runat="server"></asp:Label>**
    **</h2>**
**</div>**
...`

关键元素是标签控件，我们将使用它来显示摘要，我们将在代码隐藏类中计算它，如清单 21-4 所示。

***清单 21-4。**填充母版页代码隐藏类中的页脚*

`using System;
using System.Linq;

namespace TriathlonApp {
    public partial class Site : System.Web.UI.MasterPage {

        protected void Page_Load(object sender, EventArgs e) {

            using (TrainingDataEntities entities = new TrainingDataEntities()) {

                int eventCount = entities.Events.Count();
                TimeSpan time = new TimeSpan();
                float distance = 0;

                foreach (EventType ev in entities.Events.Select(ev => ev.EventType)) {
                    distance += (ev.SwimMiles + ev.CycleMiles + ev.RunMiles);
                }

                foreach (TimeSpan ts in entities.Events.Select(ev => ev.OverallTime)) {
                    time += ts;
                }

                footerLabel.Text
                    = string.Format("{0} Events, {1:F1} Miles, {2} Hours and {3} Minutes",
                    eventCount.ToString(), distance, time.Hours, time.Minutes);
            }
        }
    }
}`

我创建了一个新的实体框架上下文，并使用它来查询我需要的信息，包括事件的数量、距离的总和以及总时间。使用数据源控件无法管理这些类型的查询，您将看到，在整个项目中，我在使用数据源控件和使用代码隐藏类中的数据之间切换。在我们将横幅和页脚添加到母版页后，各个 ASPX 页面看起来就像图 21-4 中所示的那样。

![images](images/2104.jpg)

***图 21-4。**母版页中横幅和页脚的效果*

#### 添加标签页

我们将创建一个处理选项卡的用户控件。这是一种创建简单且可重用的控件的简单方法，并使添加自定义事件等功能变得简单方便。你可以在第 16 章中了解更多关于用户控件的信息。

首先使用 Web 用户控件模板向名为`TabButtons.ascx`的项目添加一个新项。清单 21-5 显示了这个控件的标记。

***清单 21-5。**标签页用户控件的标记*

`<%@ Control Language="C#" AutoEventWireup="true" CodeBehind="TabButtons.ascx.cs"
Inherits="TriathlonApp.TabButtons" %>

<style type="text/css">
    div.tabcontainer {float:left; clear:both; background-color:#ECE8DA;
                      width:100%; padding:5px}
    .tabbutton {margin: 2px 0px 2px 1px; float:left; z-index:2; position:relative }
    .tabstrip {margin: 2px 0px 2px 1px; width:100%; height:37px; position:absolute;
               left:0px; z-index:1; padding: 0 0px 0 5px}
</style>

<div class="tabcontainer">

    <asp:Image ID="Image1" runat="server"
        ImageUrl="~/Images/btn-backing-strip.png" CssClass="tabstrip" />

    <asp:ImageButton ID="EventButton" CssClass="tabbutton" runat="server" CommandName="Tab"
        CommandArgument="Events" ImageUrl="~/Images/btn-off-event.png" />
    <asp:ImageButton ID="PerfButton" CssClass="tabbutton" runat="server"
        CommandName="Tab" CommandArgument="Performance"
        ImageUrl="~/Images/btn-off-perf.png" />
    <asp:ImageButton ID="CalcButton" CssClass="tabbutton" runat="server"
        CommandName="Tab" CommandArgument="Calculator"
        ImageUrl="~/Images/btn-off-calc.png" />
</div>`

我在第 10 章中用 jQuery 创建的标签中尽可能接近地模拟了这个控件的外观。有三个 ImageButton 控件代表我们需要的三个选项卡，每个控件都被设置为显示与未被选中的选项卡相对应的图像。还有一个图像控件。我使用这张图片和一些 CSS 来创建一个贯穿页面的条，给标签按钮一种连续性的感觉。

我们分两部分将选项卡控件添加到母版页。第一种是使用`Register`指令，如[清单 21-6](#list_21_6) 所示。

***清单 21-6。**注册用户控件*

`<%@ Master Language="C#" AutoEventWireup="true" CodeBehind="Site.master.cs"![images](images/U002.jpg)
 Inherits="TriathlonApp.Site" %>
**<%@ Register Src="~/TabButtons.ascx" TagName="TabButtonPanel" TagPrefix="Custom" %>**
...`

第二部分是为控件本身添加标记，如[清单 21-7](#list_21_7) 所示。

***清单 21-7。**为选项卡用户控件添加标记*

...
`<div>
    **<Custom:TabButtonPanel ID="TabPanel" runat="server"**
        OnTabSelectionChanged="HandleTabChange"/>
</div>
...`

注意，我已经为一个名为`TabSelectionChanged`的事件注册了一个处理程序。这是在用户控件的代码隐藏类中定义的，你可以在清单 21-8 中看到。

***清单 21-8。**选项卡用户控件的代码隐藏类*

`using System;
using System.Web.UI.WebControls;

namespace TriathlonApp {

    public class TabSelectedEventArgs : EventArgs {
        public string SelectedTab { get; set; }
    }

    public partial class TabButtons : System.Web.UI.UserControl {
        public event EventHandler<TabSelectedEventArgs> TabSelectionChanged;

        protected void Page_Load(object sender, EventArgs e) {
            switch (Request.FilePath) {
                case "/Events.aspx":
                    EventButton.ImageUrl = "~/Images/btn-on-event.png";
                    break;
                case "/Performance.aspx":
                    PerfButton.ImageUrl = "~/Images/btn-on-perf.png";
                    break;
                case "/Calculator.aspx":
                    CalcButton.ImageUrl = "~/Images/btn-on-calc.png";
                    break;
            }
        }

        protected override bool OnBubbleEvent(object source, EventArgs args) {

            if (args is CommandEventArgs) {
                CommandEventArgs ce = (CommandEventArgs)args;
                if (ce.CommandName == "Tab" && TabSelectionChanged != null) {
                    TabSelectionChanged(this,
                            new TabSelectedEventArgs {
                                SelectedTab = ce.CommandArgument.ToString()
                            });
                    return true;
                }
            }
            return false;
        }
    }
}`

在`Page_Load`方法中，我使用了`Request.FilePath`属性来确定哪个页面正在被加载，因此更改了代表当前页面的 ImageButton 控件的`ImageUrl`属性。

每个 ImageButton 控件都定义有一个值为`Tab`的`CommandName`和一个表示用户想要转到的页面的`CommandArgument`值(`Events`、`Performance`和`Calculator`)。我已经覆盖了`OnBubbleEvent`方法，这样我就可以轻松地从 ImageButton 控件接收事件。在这个方法的实现中，我调用了在类的头部定义的`TabSelectionChanged`事件。当调用事件时，我传入一个`TabSelectedEventArgs`对象，该对象扩展了基类`EventArgs`来添加一个指示用户选择的页面的属性。

剩下的工作就是实现`HandleTabChange`方法来处理用户控件发出的事件。我在母版页的代码隐藏类中这样做，以便可以将选项卡与它们被选中时发生的操作分开。你可以在清单 21-9 中看到这个方法的实现。

***清单 21-9。**实现用户控件事件的处理程序*

`using System;
using System.Linq;

namespace TriathlonApp {
    public partial class Site : System.Web.UI.MasterPage {

        protected void Page_Load(object sender, EventArgs e) {
*            ...contents of this method shown previously...*
        }

        **protected void HandleTabChange(object sender, TabSelectedEventArgs e) {**
            **Response.Redirect(string.Format("~/{0}.aspx", e.SelectedTab));**
        **}**
    }
}`

当用户控件发出它的事件时，这个方法被调用，我简单地从`TabSelectedEventArgs`对象中获取值，并使用它将用户重定向到适当的页面。我可以很容易地在用户控件本身中完成这个简单的任务，但是我喜欢这种分离，它提供了一个很好的例子，说明如何将用户控件集成到 Web 窗体应用程序的其他部分。

如果我们现在查看任何 ASPX 页面，主页将包含这些选项卡。如果我们单击选项卡，浏览器将被定向到相应的页面。由于目前没有任何页面有自己的内容，我们不得不依赖添加的占位符文本。在[图 21-5](#fig_21_5) 中可以看到页面之间的过渡。

![images](images/2105.jpg)

***图 21-5。**使用选项卡用户控件在页面间移动*

我对选项卡采用的方法的主要缺点是选项卡本身被硬编码到用户控件中。更灵活的方法是使用我们可以在标记中设置的属性来指定它们对应的选项卡和页面。尽管如此，简单也有它的优点，这种方法完全可以满足我们在本章中的需求。

### 构建事件页面

现在我们已经有了母版页，我们可以开始填充构成应用程序主干的各个页面，从`Event.aspx`开始。此页面显示数据库中的事件列表以及排名信息。可以根据事件类型过滤事件。有一个添加新事件的按钮，每个事件都有编辑或删除记录的按钮。清单 21-10 显示了我为这个页面添加的标记。只是一些基本的 CSS。

***清单 21-10。**events . aspx 标记*

`<%@ Page Title="" Language="C#" MasterPageFile="~/Site.Master" AutoEventWireup="true"
CodeBehind="Events.aspx.cs" Inherits="TriathlonApp.Events" %>

<asp:Content ID="Content1" ContentPlaceHolderID="head" runat="server">
    <title>Triathlon Events</title>
    <style type="text/css">
        .dataview { margin:0px;  border-spacing:0px; border:
            thin black solid; border-top: none}
        th { color:#696969; font-weight:bold; padding:0 5px 0 5px;
             border-top:thin black solid; padding-top:2px }
        .dataitem {padding: 0 5px 0 5px; margin:0px;display:table-cell}
        #eventselector {margin-top:10px}
    </style>
</asp:Content>
<asp:Content ID="Content2" ContentPlaceHolderID="ContentPlaceHolder1" runat="server">

    <div class="main">

    </div>
</asp:Content>`

#### 添加事件表

此页面中的关键控件是一个数据列表。我可以使用其他控件来达到同样的效果，但是我发现我通常使用 DataList 而不是其他控件。这只是个人喜好。例如，我更喜欢使用那些使用模板的数据控件，而不是像 GridView 那样使用`BoundField`元素的数据控件。您可以在清单 21-11 中看到数据表的标记。

***清单 21-11。**向 Events.aspx 页面添加 DataList 控件*

`...
<asp:DataList ID="DataList1" runat="server" CssClass="dataview" rules="cols"
        ExtractTemplateRows="True">
    <HeaderTemplate>
        <asp:Table ID="Table1" runat="server">
            <asp:TableHeaderRow>
            <asp:TableHeaderCell>Date</asp:TableHeaderCell>
            <asp:TableHeaderCell>Athlete</asp:TableHeaderCell>
            <asp:TableHeaderCell>Event Type</asp:TableHeaderCell>
            <asp:TableHeaderCell>Swim</asp:TableHeaderCell>
            <asp:TableHeaderCell>Cycle</asp:TableHeaderCell>
            <asp:TableHeaderCell>Run</asp:TableHeaderCell>
            <asp:TableHeaderCell>Overall</asp:TableHeaderCell>
            <asp:TableHeaderCell>Rank</asp:TableHeaderCell>
            <asp:TableHeaderCell>Ref Rank</asp:TableHeaderCell>
            <asp:TableHeaderCell>Edit</asp:TableHeaderCell>
            <asp:TableHeaderCell>Delete</asp:TableHeaderCell>
            </asp:TableHeaderRow>
        </asp:Table>
    </HeaderTemplate>
    <ItemTemplate>
        <asp:Table ID="Table2" runat="server">
            <asp:TableRow>
            <asp:TableCell CssClass="dataitem"><%# Eval("Date",
                                                "{0:MM/dd}")%></asp:TableCell>
            <asp:TableCell CssClass="dataitem"><%# Eval("Athlete")%></asp:TableCell>
            <asp:TableCell CssClass="dataitem"><%# Eval("Type")%></asp:TableCell>
            <asp:TableCell CssClass="dataitem"><%# Eval("SwimTime")%></asp:TableCell>
            <asp:TableCell CssClass="dataitem"><%# Eval("CycleTime")%></asp:TableCell>
            <asp:TableCell CssClass="dataitem"><%# Eval("RunTime")%></asp:TableCell>
            <asp:TableCell CssClass="dataitem"><%# Eval("OverallTime")%></asp:TableCell>
            <asp:TableCell CssClass="dataitem"
                style="text-align:right"><%# Eval("PRank") %></asp:TableCell>
            <asp:TableCell CssClass="dataitem"
                style="text-align:right"><%# Eval("RRank") %></asp:TableCell>
            <asp:TableCell CssClass="dataitem"><asp:ImageButton ID="ImageButton1"
                runat="server" ImageUrl="~/Images/btn-edit-off.png" Height="25"
                PostBackUrl='<%# "~/EventEditor.aspx?mode=edit&id="
                    + Eval("ID") %>' /></asp:TableCell>
            <asp:TableCell CssClass="dataitem"><asp:ImageButton ID="ImageButton2"
                runat="server" ImageUrl="~/Images/btn-delete-off.png" Height="25"
                PostBackUrl='<%# "~/EventEditor.aspx?mode=delete&id="
                    + Eval("ID") %>'/></asp:TableCell>
            </asp:TableRow>
        </asp:Table>
    </ItemTemplate>
</asp:DataList>
...`

`HeaderTemplate`和`ItemTemplate`都包含表格控件。这似乎是一件奇怪的事情，但是请注意，我已经将`ExtractTemplateRows`属性设置为`true`，如下所示:

`...
<asp:DataList ID="DataList1" runat="server" CssClass="dataview" rules="cols"
    **ExtractTemplateRows="True"**>
...`

这是 DataList 提供的一个巧妙的技巧。默认情况下，DataList 呈现一个外部 HTML `table`元素，并将来自`ItemTemplate`的输出插入到一个表格单元格(`td`)元素中，该元素又被插入到一个表格行(`tr`)元素中。如果您只想显示简单的值，这很好。DataList 创建一个一列的表格，`ItemTemplate`的内容显示在该列的每一行中。

![images](images/square.jpg) **提示**您会注意到我没有在 DataList 控件中添加分页。这是为了简单起见，因为我们重新创建的应用程序也没有分页。你可以在第 20 章的[中看到富数据控件分页的例子。](20.html#ch20)

如果我们试图添加自己的`table`或`tr`元素来显示更复杂的值，那么我们会得到一个奇怪的效果，如图 21-6 中的[所示。现在，一列外部表格的每一行都包含一个单独的表格，就像`HeaderTemplate`一样，它们都根据内容调整自己的大小。](#fig_21_6)

![images](images/2106.jpg)

***图 21-6。**在 DataList ItemTemplate 中嵌入表格元素*

如果我们在模板中定义自己的`tr`元素，也会产生类似的效果。在这两种情况下，为 DataList 定义的任何边框都不会围绕外部表，并且包含连续性中断。我们可以通过在 DataList 控件的标记中将`ExtractTemplateRows`属性设置为`true`，并在我们的`ItemTemplate`和`HeaderTemplate`定义中使用表格控件来解决这个问题。DataList 控件找到单个的`TableHeaderRow`和`TableRow`元素，并将它们直接添加到外部表中，而不进行任何包装。这意味着模板生成的 HTML 出现在同一个表中，不会出现边框和对齐问题。不会呈现单个表格控件。它们只是一个方便的容器，以便 DataList 可以从模板中找到并提取行。

##### 了解 DataList 模板

一旦我们理解了表格控件的用途，模板本身就非常简单了。`HeaderTemplate`定义了一个单独的标题行，为每一列提供一个标签。`ItemTemplate`使用标准数据绑定来表示数据项中的字段。

在`ItemTemplate`中有几点需要注意。第一个是我绑定到不在实体框架数据模型中定义的`Event`对象中的值，如下所示:

`...<%# Eval("PRank") %>...
...<%# Eval("RRank") %>...`

我们需要这个控件的数据不能直接从数据库中获得，这就是我没有使用数据源控件的原因。相反，我使用了一个 LINQ 查询，您很快就会看到。第二点需要注意的是`ItemTemplate`中包含的两个 ImageButton 控件，如下所示:

`<asp:ImageButton ID="ImageButton2" runat="server"
    ImageUrl="~/Images/btn-delete-off.png" Height="25"
    PostBackUrl='<%# "~/EventEditor.aspx?mode=delete&id=" + Eval("ID")%>'/>`

我使用`PostBackUrl`属性指定当单击这些按钮时调用`EventEditor`页面，使用查询字符串指定两个参数:`mode`，用于区分编辑和删除记录，以及`id`，用于指定我们想要编辑或删除的`Entity`对象的 ID 字段的值。在本章的后面你会看到我是如何实现`EventEditor.aspx`页面的。

#### 添加其他 UI 元素

我们需要向`Events.aspx`页面添加另外两个 UI 元素:允许用户按类型过滤事件的下拉列表和启动向数据库添加新事件的过程的按钮。你可以在清单 21-12 中看到这两个标签。

***清单 21-12。**添加滤镜选择器和添加按钮*

...
`<table id="eventselector">
    <tr>
    <td>Event Type:</td>
    <td>
        <asp:DropDownList ID="DropDownList1" runat="server" AutoPostBack="True" />
    </td>
    <td><asp:ImageButton ID="AddEventButton" runat="server"
        ImageUrl="~/Images/btn-add-event-off.png" Height="25"
        PostBackUrl="~/EventEditor.aspx?mode=add" /></td>
    </tr>
</table>
...`

正如您可能想到的，我已经为第一个 UI 元素使用了 DropDownList 控件。我已经将`AutoPostBack`属性设置为`true`,这样一旦用户选择了一个值，表单就会被发送回 ASP.NET 服务器。

该按钮由另一个 ImageButton 控件处理，也配置为回发到`EventEditor`页面，就像 DataList 控件中的编辑和删除按钮一样。在本例中，我使用查询字符串将`mode`参数设置为`add`，这是给`EventEditor.aspx`页面的一个信号，表明我们想要创建一个新记录。

#### 获取数据和配置控件

我还没有向`Events.aspx`页面添加任何数据源控件。这是因为 DataList 和 DropDownList 控件所需的数据不能直接从单个数据库表中获得，每当我必须操作数据时，我更喜欢使用 LINQ(如前所述，我真的很喜欢 LINQ，对我来说使用它不需要太多的借口)。[清单 21-13](#list_21_13) 显示了我在`Events.aspx`代码隐藏类中使用的查询。

***清单 21-13。**事件代码隐藏类*

`using System;
using System.Collections.Generic;
using System.Linq;

namespace TriathlonApp {
    public partial class Events : System.Web.UI.Page {

        protected void Page_Load(object sender, EventArgs args) {

            using (TrainingDataEntities entities = new TrainingDataEntities()) {

                if (!IsPostBack) {
                    DropDownList1.DataSource
                        = new[] { "All" }.Concat(entities.EventTypes.Select(e => e.Name));
                }

                string selectedEventType
                    = string.IsNullOrEmpty(DropDownList1.SelectedValue)
                        ? "All" : DropDownList1.SelectedValue;

                IEnumerable<Event> events = selectedEventType == "All" ?
                    entities.Events :
                        entities.Events.Where(e => e.Type == selectedEventType);

                DataList1.DataSource = events.Select(e => new {
                    e.ID,
                    e.Date,
                    e.Athlete,
                    e.Type,
                    e.SwimTime,
                    e.CycleTime,
                    e.RunTime,
                    e.OverallTime,
                    PRank = entities.GetPersonalRanking(e.Athlete, e.Type, e.SwimTime,
                        e.CycleTime, e.RunTime, e.OverallTime)
                        .Where(r => r.Activity == "Overall")
                        .Select(r => r.Pos).FirstOrDefault(),
                    RRank = entities.GetReferenceRanking(e.Type, e.SwimTime, e.CycleTime,
                        e.RunTime, e.OverallTime)
                        .Where(r => r.Activity == "Overall")
                        .Select(r => r.Pos).FirstOrDefault()
                });

                DataBind();
            }
        }
    }
}`

我首先设置 DropDownList 控件中的项目。只有当请求不是回发到服务器时，我才这样做。这意味着当页面更新时，DropDownList 控件可以使用视图状态功能来维护用户选择的值。如果我在每次加载页面时重置数据源，那么要么我必须小心地保留选择，要么我们必须接受下拉菜单显示的值和 DataList 控件显示的项目不协调。

我想为`EventTypes`表中的每条记录提供值，再加上一个代表整个可用事件集的值，我将它表示为`All`。为此，我使用 LINQ `Concat`方法来组合两个序列，就像这样:

`DropDownList1.DataSource = new[] { "All" }.Concat(entities.EventTypes.Select(e => e.Name));`

第一个序列只包含值`All`，它与实体框架产生的每个`EventType`对象的`Name`字段的值相结合。

下一个任务是使用从 DropDownList 控件中选择的值来选择我们需要显示的`Events`。我分两个阶段做这件事。第一个是获取选定的值，如下所示:

`string selectedEventType = string.IsNullOrEmpty(DropDownList1.SelectedValue)
    ? "All" : DropDownList1.SelectedValue;`

当页面第一次加载时，DropDownList 控件不会绑定到 LINQ 结果产生的数据项，因此`SelectedValue`属性不会返回有意义的值。当这种情况发生时，我假设我们需要显示所有的事件并默认使用`All`值。

然后，我使用选择的值执行 LINQ 查询，如下所示:

`IEnumerable<Event> events = selectedEventType == "All" ?
    entities.Events :
    entities.Events.Where(e => e.Type == selectedEventType);`

没有`All`事件类型，所以当这是选择的值时，我使用不同的 LINQ 查询。否则，我使用标准的`where`子句来过滤数据库中包含的项目。

下一步是从 LINQ 结果中投影一系列匿名类型的对象，并将它们设置为 DataList 控件的数据源:

`DataList1.DataSource = events.Select(e => new {
    e.ID,
    e.Date,
    e.Athlete,
    e.Type,
    e.SwimTime,
    e.CycleTime,
    e.RunTime,
    e.OverallTime,
    PRank = entities.GetPersonalRanking(e.Athlete, e.Type, e.SwimTime,
        e.CycleTime, e.RunTime, e.OverallTime)
        .Where(r => r.Activity == "Overall")
        .Select(r => r.Pos).FirstOrDefault(),
    RRank = entities.GetReferenceRanking(e.Type, e.SwimTime, e.CycleTime,
        e.RunTime, e.OverallTime)
        .Where(r => r.Activity == "Overall")
        .Select(r => r.Pos).FirstOrDefault()
});`

我需要为控件模板中绑定的`PRank`和`RRank`字段生成值。不幸的是，这些值是通过为每个事件记录调用存储过程而产生的，这意味着我们为所需的事件集发出一个请求，然后为将要显示的每个事件发出两个额外的请求。

这可能看起来不必要的不雅，但它准确地反映了程序员经常面临的困境。数据库的结构很少能完全匹配页面所需的数据，因此我们要么发出额外的请求，要么以某种方式修改数据库。在这种情况下，我选择提出额外的要求。

代码隐藏类中的最后一条语句是:

`DataBind();`

我们不必在页面上的每个单独的数据绑定控件上调用`DataBind`。相反，我们可以调用代码隐藏类上的方法，它将确保数据控件正确绑定到它们的数据源。一旦我们实现了代码隐藏类，我们就可以看到`Events.aspx`页面的样子。应该类似于[图 21-7](#fig_21_7) 。

![images](images/2107.jpg)

***图 21-7。**被填充的 Events.aspx 页面*

图中所示的页面只显示通过下拉列表选择的奥运赛事。

### 构建事件编辑器页面

`Events.aspx`页面中的 Add New Event、Edit 和 Delete 按钮都会加载`EventEditor.aspx`页面，使用查询字符串提供关于需要什么操作的上下文。我们可以预期处理三种类型的 URL:

`/EventEditor.aspx?mode=add
/EventEditor.aspx?mode=edit&id=3
/EventEditor.aspx?mode=delete&id=3`

第一种是当用户想要添加一个新事件时我们可以预期的，另外两种分别是当用户想要编辑或删除一个事件时。对于这个页面，我从定义数据源控件开始，如[清单 21-14](#list_21_14) 所示。

***清单 21-14。**event editor . aspx 页面中的数据源控件*

`<%@ Page Title="" Language="C#" MasterPageFile="~/Site.Master" AutoEventWireup="true"
CodeBehind="EventEditor.aspx.cs" Inherits="TriathlonApp.EventEditor" %>
<asp:Content ID="Content1" ContentPlaceHolderID="head" runat="server">
    <title>Event Editor</title>
    <style type="text/css">
        table.centerTable {border:thin solid black; margin: 10px auto 10px auto}
    </style>
</asp:Content>
<asp:Content ID="Content2" ContentPlaceHolderID="ContentPlaceHolder1" runat="server">

    <!-- other controls will go here -->

    <asp:EntityDataSource ID="EntityDataSource1" runat="server"
        ConnectionString="name=TrainingDataEntities"
        DefaultContainerName="TrainingDataEntities" EnableDelete="True"
        EnableFlattening="False" EnableInsert="True" EnableUpdate="True"
        EntitySetName="Events">
    </asp:EntityDataSource>
    <asp:EntityDataSource ID="EntityDataSource2" runat="server"
        ConnectionString="name=TrainingDataEntities"
        DefaultContainerName="TrainingDataEntities" EnableFlattening="False"
        EntitySetName="Athletes">
    </asp:EntityDataSource>
    <asp:EntityDataSource ID="EntityDataSource3" runat="server"
        ConnectionString="name=TrainingDataEntities"
        DefaultContainerName="TrainingDataEntities" EnableFlattening="False"
        EntitySetName="EventTypes" Select="it.[Name]">
    </asp:EntityDataSource>
</asp:Content>`

有三种数据源控件。第一个检索我们想要编辑或删除的`Event`,并负责对数据库进行修改，包括添加新记录。

第二个数据源检索`Athletes`表的内容，第三个数据源对`EventTypes`表进行同样的操作。我将使用这两个数据源控件来填充 DropDownList 控件，以约束用户在创建或编辑记录时可以选择的值的范围。

该页面中的繁重工作由一个 FormView 控件来处理，其标记如清单 21-15 所示。

***清单 21-15。**表单视图控件的标记*

`<asp:FormView ID="FormView1" runat="server" DataSourceID="EntityDataSource1"
    RenderOuterTable="False" DefaultMode="Edit"
    onitemupdated="ItemChanged" DataKeyNames="ID"
    onitemdeleted="ItemChanged" oniteminserted="ItemChanged">
    <EditItemTemplate>
        <table class="centerTable">
            <colgroup>
            <col />
            <col width="100" />
            </colgroup>
        <tr><th colspan="4">Event Details</th></tr>
        <tr>
            <td>Date:</td>
            <td>
                <asp:TextBox ID="TextBox1" runat="server"
                    Text='<%# Bind("Date", "{0:d}") %>' />
            </td>
            <td>Swim Time:</td>
            <td>
                <asp:TextBox ID="TextBox2" runat="server" Text='<%# Bind("SwimTime") %>'/>   
            </td>
        </tr>  
        <tr>
            <td>Athlete:</td>
            <td>
                <asp:DropDownList ID="DropDownList1" runat="server"
                    DataSourceID="EntityDataSource2"
                    SelectedValue='<%# Bind("Athlete") %>' DataTextField="Name"/>
            </td>
            <td>Cycle Time:</td>
            <td>
                <asp:TextBox ID="TextBox4" runat="server" Text='<%# Bind("CycleTime") %>'/>   
            </td>
        </tr>
        <tr>
            <td>Event Type:</td>
            <td>
                <asp:DropDownList ID="DropDownList2" runat="server"
                    DataSourceID="EntityDataSource3" SelectedValue='<%# Bind("Type") %>'
                    DataTextField="Name"/>
            </td>
            <td>Run Time:</td>
            <td>
                <asp:TextBox ID="TextBox5" runat="server" Text='<%# Bind("RunTime") %>'/>   
            </td>
        </tr>
        <tr>
            <td colspan="2" />
            <td>Overall Time:</td>
            <td>
                <asp:TextBox ID="TextBox6" runat="server" Text='<%# Bind("OverallTime")%>'/>   
            </td>
        </tr>
        <tr>
            <td colspan="4" style="text-align:center">
                <asp:Button ID="EditButton" runat="server" Text="Update"
                    CommandName="Update"/>
                <asp:Button ID="DeleteButton" runat="server" Text="Delete"
                    CommandName="Delete"/>
        </td>
        </tr>
        </table>
    </EditItemTemplate>
    <InsertItemTemplate>
        <table class="centerTable">
            <colgroup>
            <col />
            <col width="100" />
            </colgroup>
        <tr><th colspan="4">Event Details</th></tr>
        <tr>
            <td>Date:</td>
            <td>
                <asp:TextBox ID="TextBox1" runat="server"
                    Text='<%# Bind("Date", "{0:d}") %>' />
            </td>
            <td>Swim Time:</td>
            <td>
                <asp:TextBox ID="TextBox2" runat="server" Text='<%# Bind("SwimTime") %>'/>   
            </td>
        </tr>  
        <tr>
            <td>Athlete:</td>
            <td>
                <asp:DropDownList ID="DropDownList1" runat="server" DataTextField="Name"
                    DataSourceID="EntityDataSource2" SelectedValue='<%# Bind("Athlete")%>'/>
            </td>
            <td>Cycle Time:</td>
            <td>
                <asp:TextBox ID="TextBox4" runat="server" Text='<%# Bind("CycleTime") %>'/>   
            </td>
        </tr>
        <tr>
            <td>Event Type:</td>
            <td>
                <asp:DropDownList ID="DropDownList2" runat="server" DataTextField="Name"
                    DataSourceID="EntityDataSource3" SelectedValue='<%# Bind("Type") %>' />
            </td>
            <td>Run Time:</td>
            <td>
                <asp:TextBox ID="TextBox5" runat="server" Text='<%# Bind("RunTime") %>'/>   
            </td>
        </tr>
        <tr>
            <td colspan="2" />
            <td>Overall Time:</td>
            <td><asp:TextBox ID="TextBox6" runat="server"
                Text='<%# Bind("OverallTime") %>'/>   </td>
        </tr>
        <tr><td colspan="4" style="text-align:center">
            <asp:Button ID="Button1" runat="server" Text="Create" CommandName="Insert"/>
        </td></tr>
        </table>
    </InsertItemTemplate>
</asp:FormView>`

这有很多标记，但是结果非常简单。我已经定义了`InsertItemTemplate`和`EditItemTemplate`元素。当用户想要创建一个事件时，将使用`InsertItemTemplate`。该模板定义了一个简单的表布局，并使用数据绑定来显示事件记录的值。有两个绑定到数据源的 DropDownList 控件来限制用户对`Athlete`和`Type`字段的选择。

![images](images/square.jpg) **注意**为了保持例子的简单，我省略了表单控件的任何验证。我不建议你在真实项目中这样做。参见[第 17 章](17.html#ch17)了解网络表单验证控件的细节和使用示例。

这个模板还包括两个按钮控件，它们使用`Update`和`Delete`的`CommandName`值。这将导致 FormView 控件推送用户对数据库所做的任何更改，或者完全删除记录，具体取决于单击了哪个按钮。

`InsertItemTemplate`在结构上与`EditItemTemplate`相似，除了只有一个按钮控制，并且有`CommandName`值`Insert`。请注意，我仍然对各个字段使用了数据绑定，尽管这是一条新记录，不会有任何值要显示。这样我就可以依靠 FormView 控件来获取用户输入的值，并自动处理插入操作。

FormView 控件对它将响应哪个`CommandName`值很挑剔，这就是为什么我基本上复制了同一个模板。如果我们用来自`EditItemTemplate`的`CommandName`的`Insert`值发送一个气泡事件，FormView 控件将忽略这个动作，什么也不做。

#### 添加代码隐藏类

剩下的工作就是在代码隐藏类中管理 FormView 控件，以便我们响应查询字符串中提供的参数值。清单 21-16 显示了代码隐藏类。

***清单 21-16。**事件编辑器代码隐藏类*

`using System;
using System.Web.UI.WebControls;

namespace TriathlonApp {
    public partial class EventEditor : System.Web.UI.Page {
        private string mode;

        protected void Page_Load(object sender, EventArgs e) {

            mode = Request.QueryString["mode"];
            string id =  Request.QueryString["id"];

            if (string.IsNullOrEmpty(mode)) {
                Response.Redirect("~/Events.aspx");
            } else {
                if (mode == "add") {
                    FormView1.ChangeMode(FormViewMode.Insert);
                } else if (mode == "edit" || mode == "delete") {
                    EntityDataSource1.Where = "it.ID = " + id;
                    FormView1.ChangeMode(FormViewMode.Edit);
                }
            }
        }
        protected void ItemChanged(object sender, EventArgs e) {
            Response.Redirect("~/Events.aspx");
        }

        protected void Page_PreRender(object sender, EventArgs e) {
            if (mode == "edit" || mode == "delete") {
                FormView1.FindControl("EditButton").Visible = mode == "edit";
                FormView1.FindControl("DeleteButton").Visible = mode == "delete";
            }
        }
    }
}`

我使用`Page_Load`方法来获取`mode`和`id`参数的值，并使用它们来配置数据控件和数据源控件。对于 FormView 控件，我需要调用`ChangeMode`方法来选择`Insert`(用于添加新记录)或`Edits`(用于修改或删除记录)模式。这确保了显示正确的模板，关键的是，这意味着 FormView 将响应模板中按钮控件产生的气泡事件。

对于`EntityDataSource`控件，我设置了`Where`属性来过滤数据项，这样只有我们想要处理的项才可用，如下所示:

`EntityDataSource1.Where = "it.ID = " + id;`

当设置这些属性时，我们实际上是在定义 LINQ 查询，`it`引用源序列中的当前项。这相当于这样的查询:

`new TrainingEntities().Events.Where(it => it.ID == id)`

然而，请注意，当在一个`EntityDataSource`上设置`Where`属性时，我们不使用 C#相等运算符(`==`)。相反，我们必须使用赋值操作符(`==`)。

##### 处理控制事件

在`FormView`控件的标记中，我将`ItemChanged`方法注册为`ItemUpdated`、`ItemInserted`和`ItemDeleted`事件的处理程序。这确保了每当用户使用 FormView 控件完成一个操作时，都会调用`ItemChanged`方法。这个方法的实现很简单:

`protected void ItemChanged(object sender, EventArgs e) {
    Response.Redirect("~/Events.aspx");
}`

我简单地使用`Redirect`方法将用户返回到`Events.aspx`页面。

##### 调整按钮

代码隐藏类中剩下的方法是`Page_PreRender`，正如你在[第 5 章](05.html#ch5)中回忆的那样，它在页面呈现为 HTML 之前被调用。下面是该方法的实现:

`protected void Page_PreRender(object sender, EventArgs e) {
    if (mode == "edit" || mode == "delete") {
        FormView1.FindControl("EditButton").Visible = mode == "edit";
        FormView1.FindControl("DeleteButton").Visible = mode == "delete";
    }
}`

我根据作为查询字符串的一部分接收到的模式参数设置了`EditItemTemplate`中按钮控件的可见性。我这样做是为了让用户只看到与他们正在执行的操作相关的按钮。

我必须这样做来响应`PreRender`事件，因为 FormView 控件在数据绑定之前不会加载模板，这发生在`Load`事件之后。一旦发生这种情况，我们可以使用`FindControl`方法来定位按钮控件并设置`Visible`属性。您可以在[图 21-8](#fig_21_8) 中看到完成的`EventEditor.aspx`页面。

![images](images/2108.jpg)

***图 21-8。**使用 EventEditor.aspx 页面编辑事件*

这个页面特别展示了 Web 表单在处理数据方面的优势。我们只是使用数据源控件选择了我们想要的数据，设置了以不同方式显示数据的模板，并定义了一些按钮控件来触发操作。我们根本不需要处理加载、更新、删除或添加记录。一切都为我们处理好了。

### 构建绩效页面

我们已经处理了这个应用程序的所有复杂部分。剩下的只是一些与第二部分的实现非常相似的页面。性能页面比较简单；您可以在清单 21-17 中看到这个标记。我使用数据源控件将数据库中运动员的名字填充到 DropDownList 中，并使用常规 HTML `table`中的单个标签控件来显示数据值。这是我经常使用的一种方法，当我需要在代码隐藏类中设置一个值或者当我想要接收和处理事件时，对不改变的元素和 Web 窗体控件使用常规 HTML。

***清单 21-17。**performance . aspx 页面的标记*

`<%@ Page Title="" Language="C#" MasterPageFile="~/Site.Master" AutoEventWireup="true"
CodeBehind="Performance.aspx.cs" Inherits="TriathlonApp.Performance" %>

<asp:Content ID="Content1" ContentPlaceHolderID="head" runat="server">
    <title>Performance</title>
    <style type="text/css">
        table.centerTable {margin-left:auto;margin-right:auto;
                           border:thin solid black; margin-bottom:10px}
    </style>
</asp:Content>

<asp:Content ID="Content2" ContentPlaceHolderID="ContentPlaceHolder1" runat="server">

<div style="width:100%; text-align:center; padding:10px">
    <asp:Label ID="Label1" runat="server" Text="Athlete:"></asp:Label>
    <asp:DropDownList ID="DropDownList1" runat="server"
        DataSourceID="EntityDataSource1" DataTextField="Name" DataValueField="Name"
        AutoPostBack="True"/>
</div>

<table class="centerTable">
   <colgroup><col /><col width="100px" /><col /><col width="40px" /></colgroup>
   <tr><th colspan="4">Sprint Results</th></tr>
   <tr>
    <td>Best Swim Time:</td><td><asp:Label ID="sbstLabel" runat="server" Text="--"/></td>
    <td>Best Swim Rank:</td><td><asp:Label ID="sbsrLabel" runat="server" Text="--"/></td>
   </tr>
   <tr>
    <td>Best Cycle Time:</td><td><asp:Label ID="sbctLabel" runat="server" Text="--"/></td>
    <td>Best Cycle Rank:</td><td><asp:Label ID="sbcrLabel" runat="server" Text="--"/></td>
   </tr>
   <tr>
    <td>Best Run Time:</td>
    <td><asp:Label ID="sbrtLabel" runat="server" Text="--"/></td>
    <td>Best Run Rank:</td>
    <td><asp:Label ID="sbrrLabel" runat="server" Text="--"/></td>
   </tr>
   <tr>
    <td>Best Overall Time:</td><td><asp:Label ID="sbotLabel" runat="server" Text="--"/></td>
    <td>Best Overall Rank:</td><td><asp:Label ID="sborLabel" runat="server" Text="--"/></td>
   </tr>
</table>

<table class="centerTable">
   <colgroup><col /><col width="100px" /><col /><col width="40px" /></colgroup>
  <tr><th colspan="4">Olympic Results</th></tr>
  <tr>
   <td>Best Swim Time:</td><td><asp:Label ID="obstLabel" runat="server" Text="--"/></td>
   <td>Best Swim Rank:</td><td><asp:Label ID="obsrLabel" runat="server" Text="--"/> </td>
  </tr>
  <tr>
   <td>Best Cycle Time:</td><td><asp:Label ID="obctLabel" runat="server" Text="--"/></td>
   <td>Best Cycle Rank:</td><td><asp:Label ID="obcrLabel" runat="server" Text="--"/></td>
  </tr>
  <tr>
   <td>Best Run Time:</td><td><asp:Label ID="obrtLabel" runat="server" Text="--"/></td>
   <td>Best Run Rank:</td><td><asp:Label ID="obrrLabel" runat="server" Text="--"/></td>
  </tr>
  <tr>
   <td>Best Overall Time:</td><td><asp:Label ID="obotLabel" runat="server" Text="--"/></td>
   <td>Best Overall Rank:</td><td><asp:Label ID="oborLabel" runat="server" Text="--"/> </td>
  </tr>
</table>

<asp:EntityDataSource ID="EntityDataSource1" runat="server"
    ConnectionString="name=TrainingDataEntities"
    DefaultContainerName="TrainingDataEntities" EnableFlattening="False"
    EntitySetName="Athletes" Select="it.[Name]"/>
</asp:Content>`

我需要的两个`table`元素的数据需要一些处理，所以我在代码隐藏类中使用 LINQ，如清单 21-18 所示。

***清单 21-18。**性能代码隐藏类*

`using System;
using System.Collections.Generic;
using System.Linq;
using System.Web.UI.WebControls;

namespace TriathlonApp {
    public partial class Performance : System.Web.UI.Page {

        protected void Page_Load(object sender, EventArgs args) {

            using (TrainingDataEntities entities = new TrainingDataEntities()) {
                // get the selected athlete
                string athlete = DropDownList1.SelectedValue;
                if (string.IsNullOrEmpty(athlete)) {
                    athlete = entities.Athletes.First().Name;
                }

                ProcessFieldSet(entities, athlete, "Sprint",
                    new Label[] { sbstLabel, sbctLabel, sbrtLabel, sbotLabel },
                    new Label[] { sbsrLabel, sbcrLabel, sbrrLabel, sborLabel });

                ProcessFieldSet(entities, athlete, "Olympic",
                  new Label[] { obstLabel, obctLabel, obrtLabel, obotLabel  },
                  new Label[] { obsrLabel, obcrLabel, obrrLabel, oborLabel  });
            }
        }

        private void ProcessFieldSet(TrainingDataEntities entities, string athlete,
            string eventType, Label[] personaLabels, Label[] overallLabels) {

            Event bestTimes = new Event();
            IEnumerable<Event> classEvents = entities.Events
                .Where(e => e.Athlete == athlete && e.Type == eventType);

            if (classEvents.Count() > 0) {

                bestTimes.SwimTime = classEvents.Select(e => e.SwimTime).Min();
                bestTimes.CycleTime = classEvents.Select(e => e.CycleTime).Min();
                bestTimes.RunTime = classEvents.Select(e => e.RunTime).Min();
                bestTimes.OverallTime = classEvents.Select(e => e.OverallTime).Min();

                personaLabels[0].Text = bestTimes.SwimTime.ToString();
                personaLabels[1].Text = bestTimes.CycleTime.ToString();
                personaLabels[2].Text = bestTimes.RunTime.ToString();
                personaLabels[3].Text = bestTimes.OverallTime.ToString();

                // get the ranking for the sprint events
                IEnumerable<Ranking> ranks = entities.GetReferenceRanking(eventType,
                    bestTimes.SwimTime, bestTimes.CycleTime,
                    bestTimes.RunTime, bestTimes.OverallTime);

                foreach (Ranking rank in ranks) {
                    switch (rank.Activity) {
                        case "Swim":
                            overallLabels[0].Text = rank.Pos.ToString();
                            break;
                        case "Cycle":
                            overallLabels[1].Text = rank.Pos.ToString();
                            break;
                        case "Run":
                            overallLabels[2].Text = rank.Pos.ToString();
                            break;
                        case "Overall":
                            overallLabels[3].Text = rank.Pos.ToString();
                            break;
                    }
                }

            } else {
                foreach (Label lab in personaLabels.Concat(overallLabels)) {
                    lab.Text = "--";
                }
            }
        }
    }
}`

我不打算深入研究这段代码的细节。这个类中没有你在前面章节中没有见过的东西，因为我们不需要任何特殊的 Web 表单特性来处理或显示数据。您可以在[图 21-9](#fig_21_9) 中看到浏览器显示的已完成的`Performance.aspx`页面。

![images](images/2109.jpg)

***图 21-9。**已完成 Performance.aspx 页面*

### 构建计算器页面

剩下的页面甚至更简单。然而，为了多样化，我使用了一个 Web 表单表格控件，如清单 21-19 所示。

***清单 21-19。**calculator . aspx 页面的标记*

`<%@ Page Title="" Language="C#" MasterPageFile="~/Site.Master" AutoEventWireup="true"
CodeBehind="Calculator.aspx.cs" Inherits="TriathlonApp.Calculator" %>

<asp:Content ID="Content1" ContentPlaceHolderID="head" runat="server">
    <title>Calculator</title>
    <style type="text/css">
        table.CalcTable {margin:20px;float:left}
    </style>
</asp:Content>

<asp:Content ID="Content2" ContentPlaceHolderID="ContentPlaceHolder1" runat="server">

<asp:Table ID="Table1" runat="server" CssClass="CalcTable">
   <asp:TableRow>
        <asp:TableCell>Laps:</asp:TableCell>
        <asp:TableCell>
            <asp:TextBox ID="LapsTextBox" runat="server">80</asp:TextBox>
        </asp:TableCell>
    </asp:TableRow>
    <asp:TableRow>
        <asp:TableCell>Pool Length:</asp:TableCell>
        <asp:TableCell>
            <asp:TextBox ID="LengthTextBox" runat="server">20</asp:TextBox>
        </asp:TableCell>
    </asp:TableRow>
    <asp:TableRow>
        <asp:TableCell>Minutes:</asp:TableCell>
        <asp:TableCell>
            <asp:TextBox ID="MinutesTextBox" runat="server">60</asp:TextBox>
        </asp:TableCell>
    </asp:TableRow>
    <asp:TableRow>
        <asp:TableCell>Calories/Hour:</asp:TableCell>
        <asp:TableCell>
            <asp:TextBox ID="CaloriesTextBox" runat="server">1070</asp:TextBox>
        </asp:TableCell>
    </asp:TableRow>
    <asp:TableFooterRow>
        <asp:TableCell ColumnSpan="2" HorizontalAlign="Center">
            <asp:ImageButton ID="CalculateButton" runat="server"
                ImageUrl="~/Images/btn-calculate-off.png" Height="25"/>
        </asp:TableCell>
    </asp:TableFooterRow>
</asp:Table>
<asp:Table ID="ResultsTable" runat="server" CssClass="CalcTable" Visible="False">
    <asp:TableHeaderRow>
        <asp:TableHeaderCell ColumnSpan="2">Results</asp:TableHeaderCell>
    </asp:TableHeaderRow>
    <asp:TableRow>
        <asp:TableCell>Distance:</asp:TableCell>
        <asp:TableCell><asp:Label ID="DistanceLabel" runat="server"
            ForeColor="Black" /> miles</asp:TableCell></asp:TableRow>
    <asp:TableRow>
        <asp:TableCell>Calories:</asp:TableCell>
        <asp:TableCell>
            <asp:Label ID="CalsLabel" runat="server" ForeColor="Black"/>
        </asp:TableCell>
    </asp:TableRow>
    <asp:TableRow>
        <asp:TableCell>Pace:</asp:TableCell>
        <asp:TableCell>
            <asp:Label ID="PaceLabel" runat="server" ForeColor="Black"/> seconds/lap
        </asp:TableCell>
    </asp:TableRow>
</asp:Table>

</asp:Content>`

我再次省略了任何验证控件，但是您不应该在真实的项目中这样做。清单 21-20 展示了`Calculator.aspx`页面的代码隐藏类。这和本书第二部分对应页面的实现非常相似。

***清单 21-20。**计算器代码隐藏类*

`using System;

namespace TriathlonApp {
    public partial class Calculator : System.Web.UI.Page {
        private const float metersToMiles = 0.00062137119223733f;
        private const float minsPerHour = 60f;

        protected void Page_Load(object sender, EventArgs e) {

            if (IsPostBack) {

                // parse the input values
                int laps = int.Parse(LapsTextBox.Text);
                int length = int.Parse(LengthTextBox.Text);
                int minutes = int.Parse(MinutesTextBox.Text);
                int calories = int.Parse(CaloriesTextBox.Text);

                // perform the calculation and set the result values
                DistanceLabel.Text = ((laps * length) * metersToMiles).ToString("F2");
                CalsLabel.Text = ((minutes / minsPerHour) * calories).ToString("F0");
                PaceLabel.Text = ((minutes * minsPerHour) / laps).ToString("F0");

                // make the results table visible
                ResultsTable.Visible = true;
            }
        }
    }
}`

有了这个类，我们就完成了这个应用程序，增加了前面章节中提到的一些关键的 Web 表单功能。在[图 21-10](#fig_21_10) 中可以看到完成的`Calculator.aspx`页面。

![images](images/2110.jpg)

***图 21-10。**已完成 Calculator.aspx 页面*

### 总结

在本章中，我们使用 Web 表单控件和特性实现了 triathlon 应用程序。在这个简单的应用程序中，我们看到了 Web 表单的优点和缺点。优势在于我们创建包含数据的页面的速度和简单性，以及我们操作数据来编辑、删除或向底层数据库添加记录的容易程度。我们还将 Web 表单控件与静态 HTML 结合起来，这是我经常做的事情。

缺点也同样明显，比如使 Web 窗体控件按要求运行所需的小调整和小技巧，以及数据源控件在复杂数据操作方面的局限性。然而，总的来说，Web 窗体控件做得很好，尽管可能需要一些尝试和错误来让控件按照我们想要的那样工作，但是考虑到结果的丰富性和灵活性，花费的时间是值得的。

我回到了我打开这本书的这一部分时的主题。Web Forms 光滑、灵活、功能丰富，如果用在合适的项目上，可以产生很好的效果。根据你所面临的情况，抛开 MVC 框架的光芒，拥抱强大而有用的 Web 表单是值得的。