# 10.构建协作绘图应用程序

本章开发了一个具有深入细节的协作绘图应用程序。对于此应用，需要满足以下应用要求:

*   实时交互式绘图
*   实时聊天
*   限制授权用户的访问
*   按需轻松扩展

该项目将包括一个服务器，将能够支持多种类型的客户端。该项目的托管将在 Microsoft Azure 中完成，因为它拥有所有必要的 PaaS 来支持所有需要的功能。为了确保服务器可以扩展项目，我们将能够通过负载平衡作为多个实例运行，并使用 Azure Redis 缓存作为背板。

## 项目概述

在这个项目中，我们将创建一个协作聊天和绘图应用程序。该应用程序允许您创建自己的画布/聊天室，我们将在后面的代码中称之为画布室。在 canvas room 中，您将有一个 canvas 和聊天会话，仅与 canvas room 中的人员共享。你会在用户在线部分看到加入和离开画布室的人。

关于画布室需要注意的一件重要事情是绘制的方式。您可以从四个必须选择的笔刷动作中选择一个:笔刷、橡皮擦、填充和全部清除。还有八种颜色和尺寸可供选择。在您单击画布之前，不会发生任何绘图操作。只有在使用画笔或填充时，颜色才是重要的，只有在使用画笔或橡皮擦时，大小才是重要的。

Note

在这一章中，我们经常一节一节地描述一个大类，给你一个它是如何工作的分解。然后，我们将整个类作为一个单独的步骤添加到项目中，以确保分步说明清晰易懂。

现在我们已经讨论了项目的需求，让我们从开发服务器开始。

## 开发服务器

这个项目中的服务器将是所有客户端的主要中心。我们将讨论以下组件和技术，并展示它们的使用方法:

*   报告情况
*   Web API
*   OWIN 主持
*   OWIN 安全 cookies
*   一致
*   Azure 云服务(工作者角色)
*   微软 SQL 数据库
*   蓝色里兹高速缓存

随着我们对每个组件或技术的了解，我们会将其添加到我们的服务器解决方案中。为了保持命名简单，我们将使用`GroupBrush`作为项目的解决方案名称和前缀。解决方案中将有六个项目:`BL`、`DL`、`Entity`、`Web`、`Cloud`和`Worker`。为了开始服务器开发，我们按照以下步骤设置解决方案和项目:

Create a new solution named `GroupBrush` using the `Blank Solution` template.   Add a class library project named `GroupBrush.Web`.   Add a class library project named `GroupBrush.BL`.   Add a class library project named `GroupBrush.DL`.   Add a class library project named `GroupBrush.Entity`.   Remove any unneeded `Class1.cs` files that were added with the class libraries.   Add a new Windows Azure Cloud Service project named `GroupBrush.Cloud` and a worker role that will create a project that should be named `GroupBrush.Worker`.  

现在我们已经将项目添加到了我们的解决方案中，让我们快速回顾一下每个项目的用途。项目包含了 OWIN 组件和 Unity。`GroupBrush.BL`包含封装到服务中的业务逻辑。这些服务中的许多将依赖于下一个项目，`GroupBrush.DL`，它包含了数据库逻辑。`Web`、`BL`和`DL`项目都从`GroupBrush.Entity`项目中引用它们的实体对象。`GroupBrush.Cloud`项目是用于云配置的项目，`GroupBrush.Worker`项目将在 Azure 上以`Worker`角色托管应用程序。

现在我们已经创建了解决方案，并且对每个项目有了一个大致的概念，我们可以开始检查组件和相关代码了。第一个组件是 SignalR，它使服务器能够提供实时交互性。

### 使用 SignalR 实现实时交互

实时交互性是项目吸引人的关键要求。我们通过使用 SignalR Hub 来增加这种交互性，它将提供服务器和客户机之间的实时连接。

我们将使用清单 10-1 所示的定义，通过创建一个从 hub 类派生的名为`CanvasHub`的类来添加一个 Hub 到我们的项目中。我们很快会将这个类添加到项目中。

清单 10-1。CanvasHub 类定义

`public class CanvasHub : Hub`

为了给我们的类添加一些额外的功能，我们将在类构造函数中注入一些服务，这些服务将提供用户和画布服务。其余的`CanvasHub`类将由几个助手函数、连接事件和服务器端方法组成。

在实现 SignalR 代码之前，通过以下步骤实现项目文件夹结构:

Run the following command from the Package Manager Console for the `Default` package of `GroupBrush.Web` and `GroupBrush.Worker`:  

`Install-Package` `Microsoft.AspNet.SignalR.Core`

Add a solution folder named `Hubs` to the `GroupBrush.Web` project.   Add a solution folder named `Users` to the `GroupBrush.BL` and `GroupBrush.DL` projects.   Add a solution folder named `Canvases` to the `GroupBrush.BL` and `GroupBrush.DL` projects.   Add a solution folder named `Storage` to the `GroupBrush.BL` project.  

抛开结构和依赖关系，我们先来看看清单 10-2 中的构造函数。构造函数非常简单；它接受`IUserService`和`ICanvasRoomService`参数，并将它们分配给各自的私有变量。

清单 10-2。CanvasHub 类的构造函数和私有变量

`private IUserService _userService;`

`private ICanvasRoomService _canvasRoomService;`

`public CanvasHub(IUserService userService, ICanvasRoomService canvasRoomService)`

`{`

`_userService = userService;`

`_canvasRoomService = canvasRoomService;`

`}`

构造函数的第一个依赖项是清单 10-3 中所示的`IUserService`，它为用户服务提供了签名。这些服务提供用户的创建、用户登录的验证以及从 ID 中检索用户名。集线器在这个接口中只使用`GetUserNameFromId`方法。

清单 10-3。IUserService 接口

`public interface IUserService`

`{`

`int? CreateAccount(string userName, string password);`

`bool ValidateUserLogin(string userName, string password, out int? userId);`

`string GetUserNameFromId(int id);`

`}`

第二个依赖项是清单 10-4 所示的提供画布房间服务的`ICanvasRoomService`接口。该接口提供的服务允许将用户执行的画笔动作添加到画布空间，数据检索以同步到最后已知的命令位置，以及从画布空间添加/移除用户的能力。

清单 10-4。ICanvasRoomService 接口

`public interface ICanvasRoomService`

`{`

`CanvasBrushAction AddBrushAction(string canvasId, CanvasBrushAction brushData);`

`CanvasSnapshot SyncToRoom(string canvasId, int currentPosition);`

`void AddUserToCanvas(string canvasId, string id);`

`void RemoveUserFromCanvas(string canvasId, string id);`

`}`

这些服务的实现将在本章后面添加。接下来，通过以下步骤添加接口:

Add an interface named `IUserService` to the `GroupBrush.BL` project in the `Users` folder with the contents of Listing 10-3.   Add an interface named `ICanvasRoomService` to the `GroupBrush.BL` project in the `Canvases` folder with the contents of Listing 10-4.  

在`CanvasHub`类构造函数之后，这个类中有两个助手方法、两个事件和四个服务器端方法，我们将在把它们添加到我们的项目之前讨论它们。这两个助手方法是`GetCanvasIdFromQueryString`和`GetUserNameFromContext`。添加它们是为了使特定于`CanvasHub`类的公共代码不会在该类的多个地方重复。

清单 10-5 所示的第一个助手方法`GetCanvasIdFromQueryString`在查询字符串中查找关键字 canvasid 如果找到并有效，Guid 将返回该 canvasid。

清单 10-5。GetCanvasIdFromQueryString 帮助器方法

`private string GetCanvasIdFromQueryString()`

`{`

`Guid validationGuid = Guid.Empty;`

`string groupId = Context.QueryString["canvasid"];`

`if (!string.IsNullOrWhiteSpace(groupId) && Guid.TryParse(groupId,out validationGuid))`

`{`

`return groupId;`

`}`

`throw new ArgumentException("Invalid Canvas Id");`

`}`

清单 10-6 所示的第二个助手方法`GetUserNameFromContext`从请求中获取当前用户的用户名。这是通过从`Context.Request.User.Identity.Name`中检索 ID 来完成的，它是当前请求的身份对象`Name`属性，由 OWIN 安全中间件填充(本章稍后讨论)。一旦获得了这个 ID，就将它传递给`IUserService`来查找这个 ID 的用户名。如果找到该名称，则返回该名称；否则，该方法将为用户名返回一个空字符串。

清单 10-6。GetUserNameFromContext 帮助器方法

`private string GetUserNameFromContext()`

`{`

`string strUserId = Context.Request.User.Identity.Name;`

`int userId = 0;`

`if (int.TryParse(strUserId, out userId))`

`{`

`return _userService.GetUserNameFromId(userId);`

`}`

`return string.Empty;`

`}`

接下来是清单 10-7 和 10-8 中分别显示的`OnConnected`和`OnDisconnected`事件。这些事件覆盖基类事件，有三个主要动作:在画布中添加或删除用户，在画布组中添加或删除连接 ID，以及通知所有画布组成员用户连接或断开连接。

清单 10-7。on 关联事件

`public override Task OnConnected()`

`{`

`_canvasRoomService.AddUserToCanvas(GetCanvasIdFromQueryString(), GetUserNameFromContext());`

`Groups.Add(Context.ConnectionId.ToString(), GetCanvasIdFromQueryString());`

`Clients.Group(GetCanvasIdFromQueryString()).UserConnected(GetUserNameFromContext());`

`return base.OnConnected();`

`}`

清单 10-8。OnDisconnected 事件

`public override Task OnDisconnected(bool stopCalled)`

`{`

`_canvasRoomService.RemoveUserFromCanvas(GetCanvasIdFromQueryString(), GetUserNameFromContext());`

`Groups.Remove(Context.ConnectionId.ToString(), GetCanvasIdFromQueryString());`

`Clients.Group(GetCanvasIdFromQueryString()).UserDisconnected(GetUserNameFromContext());`

`return base.OnDisconnected(stopCalled);`

`}`

`CanvasHub`类的最后一部分是四个服务器端方法，它们是向 SignalR 客户端公开的方法。

清单 10-9 所示的`MoveCursor`有两个参数:当前用户的光标值`x`和`y`。该方法用当前用户的`x`和`y`光标坐标和用户名向画布组的所有成员发送客户端消息`MoveOtherCursor`。

清单 10-9。MoveCursor 方法

`public void MoveCursor(double x, double y)`

`{`

`Clients.Group(GetCanvasIdFromQueryString()).MoveOtherCursor(GetUserNameFromContext(), x, y);`

`}`

清单 10-10 所示的第二个方法`SendChatMessage`有一个参数:要发送的消息。该方法在消息前添加用户名和冒号，并通过`UserChatMessage`客户端方法将其发送给 canvas 组的所有成员。

清单 10-10。SendChatMessage 方法

`public void SendChatMessage(string message)`

`{`

`Clients.Group(GetCanvasIdFromQueryString()).UserChatMessage(GetUserNameFromContext() + ": " + message);`

`}`

第三种方法是清单 10-10 中的`SendDrawCommand`，它有一个在清单 10-12 中定义的参数`CanvasBrushAction`。它包含笔刷信息和受影响的笔刷位置，如清单 10-13 中的`Position`类所定义的。这个方法的第一步是通过调用`ICanvasRoomService`服务上的`AddBrushAction`方法来保存参数提供的信息。一旦保存了信息，我们就可以通过使用`DrawCanvasBrushAction`客户端方法将参数信息发送给所有的画布组用户。

清单 10-11。SendDrawCommand 方法

`public void SendDrawCommand(CanvasBrushAction brushData)`

`{`

`CanvasBrushAction canvasBrushAction = _canvasRoomService.AddBrushAction(GetCanvasIdFromQueryString(), brushData);`

`Clients.Group(GetCanvasIdFromQueryString()).DrawCanvasBrushAction(canvasBrushAction);`

`}`

清单 10-12。CanvasBrushAction 实体类

`public class CanvasBrushAction`

`{`

`public int Sequence { get; set; }`

`public Int64 ClientSequenceId { get; set; }`

`public int Type { get; set; }`

`public string Color { get; set; }`

`public int Size { get; set; }`

`public List<Position> BrushPositions { get; set; }`

`}`

清单 10-13。位置实体类

`public class Position`

`{`

`public double X { get; set; }`

`public double Y { get; set; }`

`}`

清单 10-14 中显示的最后一个方法`SyncToRoom`接受一个参数:客户端最后已知的绘图历史位置。它以清单 10-15 中定义的一个`CanvasSnapshot`的形式返回所有画布画笔数据，从位置参数的值到存储器中最新的条目。通过使用`ICanvasRoomService`服务上的`SyncToRoom`方法来检索信息，并且只将信息返回给调用用户。

清单 10-14。同步方法

`public CanvasSnapshot SyncToRoom(int currentPosition)`

`{`

`return _canvasRoomService.SyncToRoom(GetCanvasIdFromQueryString(), currentPosition);`

`}`

清单 10-15。CanvasSnapshot 实体类

`public class CanvasSnapshot`

`{`

`public string CanvasName { get; set; }`

`public string CanvasDescription { get; set; }`

`public List<string> Users { get; set; }`

`public List<CanvasBrushAction> Actions { get; set; }`

`}`

清单 10-16 所示的`CanvasHub`类是我们项目的主要 SignalR 类。它将为画布房间的绘图、聊天和在线用户状态提供实时功能。

清单 10-16。完整的 CanvasHub 类

`public class CanvasHub : Hub`

`{`

`private IUserService _userService;`

`private ICanvasRoomService _canvasRoomService;`

`public CanvasHub(IUserService userService, ICanvasRoomService canvasRoomService)`

`{`

`_userService = userService;`

`_canvasRoomService = canvasRoomService;`

`}`

`private string GetCanvasIdFromQueryString()`

`{`

`Guid validationGuid = Guid.Empty;`

`string groupId = Context.QueryString["canvasid"];`

`if (!string.IsNullOrWhiteSpace(groupId) && Guid.TryParse(groupId,out validationGuid))`

`{`

`return groupId;`

`}`

`throw new ArgumentException("Invalid Canvas Id");`

`}`

`private string GetUserNameFromContext()`

`{`

`string strUserId = Context.Request.User.Identity.Name;`

`int userId = 0;`

`if (int.TryParse(strUserId, out userId))`

`{`

`return _userService.GetUserNameFromId(userId);`

`}`

`return string.Empty;`

`}`

`public override Task OnConnected()`

`{`

`_canvasRoomService.AddUserToCanvas(GetCanvasIdFromQueryString(), GetUserNameFromContext());`

`Groups.Add(Context.ConnectionId.ToString(), GetCanvasIdFromQueryString());`

`Clients.Group(GetCanvasIdFromQueryString()).UserConnected(GetUserNameFromContext());`

`return base.OnConnected();`

`}`

`public override Task OnDisconnected(bool stopCalled)`

`{`

`_canvasRoomService.RemoveUserFromCanvas(GetCanvasIdFromQueryString(), GetUserNameFromContext());`

`Groups.Remove(Context.ConnectionId.ToString(), GetCanvasIdFromQueryString());`

`Clients.Group(GetCanvasIdFromQueryString()).UserDisconnected(GetUserNameFromContext());`

`return base.OnDisconnected(stopCalled);`

`}`

`public void MoveCursor(double x, double y)`

`{`

`Clients.Group(GetCanvasIdFromQueryString()).MoveOtherCursor(GetUserNameFromContext(), x, y);`

`}`

`public void SendChatMessage(string message)`

`{`

`Clients.Group(GetCanvasIdFromQueryString()).UserChatMessage(GetUserNameFromContext() + ": " + message);`

`}`

`public void SendDrawCommand(CanvasBrushAction brushData)`

`{`

`CanvasBrushAction canvasBrushAction = _canvasRoomService.AddBrushAction(GetCanvasIdFromQueryString(), brushData);`

`Clients.Group(GetCanvasIdFromQueryString()).DrawCanvasBrushAction(canvasBrushAction);`

`}`

`public CanvasSnapshot SyncToRoom(int currentPosition)`

`{`

`return _canvasRoomService.SyncToRoom(GetCanvasIdFromQueryString(), currentPosition);`

`}`

`}`

`Now that we have discussed the sections that make up the CanvasHub class, they need to be added to our project by following these steps:`

Add a class named `CanvasBrushAction` to the `GroupBrush.Entity` project with the contents of Listing 10-12.   Add a class named `Position` to the `GroupBrush.Entity` project with the contents of Listing 10-13.   Add a class named `CanvasSnapshot` to the `GroupBrush.Entity` project with the contents of Listing 10-15.   Add a class named `CanvasHub` to the `GroupBrush.Web` project under the `Hubs` folder with the contents of Listing 10-16.  

`CanvasHub`的服务提供了允许画布空间和用户数据被检索和持久化的内部工作。(我们将在下一节讨论用户服务实现，并在这一节关注画布数据。)`ICanvasRoomService`在这个项目中被实现为一个名为`CanvasRoomService`的类，如清单 10-17 所示。

清单 10-17。CanvasRoomService 类定义

`public class CanvasRoomService : ICanvasRoomService`

`CanvasRoomService`需要额外的依赖项，这些依赖项将被注入到构造函数中，如清单 10-18 所示，就像`CanvasHub`一样。依赖关系由`IMemStorage`和`IGetCanvasDescriptionData`接口表示，它们分别在清单 10-19 和 10-20 中定义。与`CanvasHub`中的构造函数一样，依赖项将被分配给构造函数中的局部变量。

清单 10-18。CanvasRoomService 的构造函数和私有变量

`IMemStorage _ memStorage;`

`IGetCanvasDescriptionData _getCanvasDescriptionData;`

`public CanvasRoomService(IMemStorage memStorage, IGetCanvasDescriptionData getCanvasDescriptionData)`

`{`

`_ memStorage = memStorage;`

`_getCanvasDescriptionData = getCanvasDescriptionData;`

`}`

清单 10-19。IMemStorage 接口

`public interface IMemStorage`

`{`

`CanvasBrushAction AddBrushAction(string canvasId, CanvasBrushAction brushData);`

`List<CanvasBrushAction> GetBrushActions(string canvasId, int currentPosition);`

`List<string> GetCanvasUsers(string canvasId);`

`void AddUserToCanvas(string canvasId, string id);`

`void RemoveUserFromCanvas(string canvasId, string id);`

`string GetUserName(int id);`

`void StoreUserName(int id, string userName);`

`}`

清单 10-20。IGetCanvasDescriptionData 接口

`public interface IGetCanvasDescriptionData`

`{`

`CanvasDescription GetCanvasDescription(Guid canvasId);`

`}`

清单 10-21 显示了大多数`CanvasRoomService`方法的逻辑是调用依赖`IMemStorage`的相应方法。例外情况是`SyncToRoom`方法，它调用`IGetCanvasDescriptionData`依赖项来检索`CanvasDescription`对象(在清单 10-22 中定义)，调用`IMemStorage`依赖项来检索画布数据。来自这三个调用的数据被组合到一个类中并被返回。存储逻辑是从这个类中抽象出来的，因为我们希望提供两种不同的存储实现:一种是只为一个实例工作的内存存储，另一种是基于 Redis 的内存存储，它允许扩展到多个实例。

清单 10-21。完整的 CanvasRoomService 类

`public class CanvasRoomService : ICanvasRoomService`

`{`

`IMemStorage _memStorage;`

`IGetCanvasDescriptionData _getCanvasDescriptionData;`

`public CanvasRoomService(IMemStorage memStorage, IGetCanvasDescriptionData getCanvasDescriptionData)`

`{`

`_memStorage = memStorage;`

`_getCanvasDescriptionData = getCanvasDescriptionData;`

`}`

`public CanvasBrushAction AddBrushAction(string canvasId, CanvasBrushAction brushData)`

`{`

`return _memStorage.AddBrushAction(canvasId, brushData);`

`}`

`public CanvasSnapshot SyncToRoom(string canvasId, int currentPosition)`

`{`

`CanvasDescription canvasDescription = _getCanvasDescriptionData.GetCanvasDescription(Guid.Parse(canvasId));`

`List<CanvasBrushAction> actions = new List<CanvasBrushAction>();`

`actions = _memStorage.GetBrushActions(canvasId, currentPosition);`

`List<string> users = new List<string>();`

`users = _memStorage.GetCanvasUsers(canvasId);`

`return new CanvasSnapshot() { Users = users, Actions = actions, CanvasName = canvasDescription.Name, CanvasDescription = canvasDescription.Description };`

`}`

`public void AddUserToCanvas(string canvasId, string id)`

`{`

`_memStorage.AddUserToCanvas(canvasId, id);`

`}`

`public void RemoveUserFromCanvas(string canvasId, string id)`

`{`

`_memStorage.RemoveUserFromCanvas(canvasId, id);`

`}`

`}`

清单 10-22。CanvasDescription 实体类

`public class CanvasDescription`

`{`

`public string Name { get; set; }`

`public string Description { get; set; }`

`}`

在我们深入了解更多细节之前，让我们回顾一下迄今为止我们所做的工作:

Added an interface named `IMemStorage` to the `GroupBrush.BL` project under the `Storage` folder with the contents of Listing 10-19.   Added an interface named `IGetCanvasDescriptionData` to the `GroupBrush.DL` project under the `Canvases` folder with the contents of Listing 10-20.   Added a class named `CanvasRoomService` to the `GroupBrush.BL` project under the `Canvases` folder with the contents of Listing 10-21.   Added a class named `CanvasDescription` to the `GroupBrush.Entity` project with the contents of Listing 10-22.  

根据我们想要部署的实例数量，`IMemStorage`接口有两种可能的实现。我们将在这里讨论内存解决方案，并在本章后面的“扩展服务器”一节中讨论 Redis 实现。

我们称之为`MemoryStorage`的这个类的第一个要求是实现`IMemStorage`，如清单 10-23 所示。与我们到目前为止讨论的大多数其他类不同，这个类没有在构造函数中注入任何依赖项。然而，它有四个`ConcurrentDictionary`集合，我们将用它们来保存画布房间数据(见清单 10-24)。

清单 10-23。MemoryStorage 类定义

`public class MemoryStorage : IMemStorage`

清单 10-24。内存存储私有变量

`private ConcurrentDictionary<string, int> canvasTransactions = new ConcurrentDictionary<string, int>();`

`private ConcurrentDictionary<string, ConcurrentBag<CanvasBrushAction>> canvasActions = new ConcurrentDictionary<string, ConcurrentBag<CanvasBrushAction>>();`

`private ConcurrentDictionary<string, ConcurrentDictionary<string,string>> canvasUsers = new ConcurrentDictionary<string, ConcurrentDictionary<string,string>>();`

`private ConcurrentDictionary<int, string> userNames = new ConcurrentDictionary<int, string>();`

该类包含七个满足`IMemStorage`接口契约的公共方法。两种方法，`AddBrushAction`和`GetBrushActions`，专门用于画布房间数据；三种方法适用于画布房间中的用户；两种方法用于用户名数据。

清单 10-25 中的`AddBrushAction method shown`将特定画布空间的客户端笔刷动作存储到内存中。为了让绘图看起来正确，我们需要确保画笔动作按顺序应用。为了确保这个顺序，我们需要将序列存储为每个`CanvasBrushAction`的唯一编号。所以在方法的顶部，我们检查是否有画布 ID 的`canvasTransactions`条目。如果没有现有条目，我们从 0 开始添加一个。

清单 10-25。AddBrushAction 方法

`public CanvasBrushAction AddBrushAction(string canvasId, CanvasBrushAction brushData)`

`{`

`if (!canvasTransactions.ContainsKey(canvasId))`

`{`

`canvasTransactions[canvasId] = 0;`

`}`

`int transactionNumber = canvasTransactions[canvasId] = canvasTransactions[canvasId]++;`

`if (!canvasActions.ContainsKey(canvasId))`

`{`

`canvasActions[canvasId] = new ConcurrentBag<CanvasBrushAction>();`

`}`

`brushData.Sequence = transactionNumber;`

`canvasActions[canvasId].Add(brushData);`

`return brushData;`

`}`

我们获取该条目，将其递增 1，并将其用作`transactionNumber`变量。现在我们有了一个事务，我们必须查看是否有一个`canvasActions`条目来存储客户端的刷机操作。如果没有条目，我们向集合中添加一个新的条目`ConcurrentBag<CanvasBrushAction>`。

接下来我们将`transactionNumber`加到`brushData`上。我们现在将更新后的`brushData`添加到`canvasActions`条目中。最后我们返回更新后的`brushData`。

第二个方法是清单 10-26 中的`GetBrushActions`,获取从画布历史中的某个位置开始特定画布发生的画笔动作。该方法首先创建一个名为`actions`的`List<CanvasBrushAction>`来存储返回的画笔动作条目。该方法的下一部分检查是否存在用于`canvasId`参数的`canvasActions`集合条目。如果条目存在，所有大于或等于`currentPosition`参数的条目都被添加到`actions`集合中，然后该集合按序号排序。最后，不管一个条目是否存在，都会返回`actions`集合。

清单 10-26。GetBrushActions 方法

`public List<CanvasBrushAction> GetBrushActions(string canvasId, int currentPosition)`

`{`

`List<CanvasBrushAction> actions = new List<CanvasBrushAction>();`

`if (canvasActions.ContainsKey(canvasId))`

`{`

`ConcurrentBag<CanvasBrushAction> storedActions = canvasActions[canvasId];`

`actions.AddRange(storedActions.Where(x => x.Sequence >= currentPosition));`

`actions.Sort(new Comparison<CanvasBrushAction>((a, b) => { return a.Sequence.CompareTo (b.Sequence); }));`

`}`

`return actions;`

`}`

清单 10-27 所示的第三个方法`GetCanvasUsers`获取画布中当前的用户名列表。这个方法也从创建一个名为`returnValue`的`List<string>`开始，它将在方法结束时返回。这个方法的所有逻辑依赖于在`canvasUsers`集合中有一个条目。如果找到一个条目，将枚举集合，并将作为键存储的用户名数据添加到一个`HashSet`中，以确保唯一性。然后用从`HashSet`生成的新列表覆盖`returnValue`集合。最后，返回`returnValue`参数。

清单 10-27。GetCanvasUsers 方法

`public List<string> GetCanvasUsers(string canvasId)`

`{`

`List<string> returnValue = new List<string>();`

`if (canvasUsers.ContainsKey(canvasId))`

`{`

`HashSet<string> uniqueList = new HashSet<string>();`

`ConcurrentDictionary<string, string> users = canvasUsers[canvasId];`

`foreach (KeyValuePair<string, string> user in users)`

`{`

`uniqueList.Add(user.Key);`

`}`

`returnValue = uniqueList.ToList<string>();`

`}`

`return returnValue;`

`}`

清单 10-28 所示的第四种方法`AddUserToCanvas`将用户添加到一个画布房间。这个方法首先检查在`canvasUsers`集合中是否存在一个条目。如果一个条目不存在，它会为`canvasId`参数向`canvasUsers`集合添加一个新的`ConcurrentDictionary<string,string>`。这确保了`canvasId`在`canvasUsers`中的查找总是为指定的画布返回一个`ConcurrentDictionary<string, string>`。检查返回的集合是否存在`id`参数。如果它不在集合中，则将其添加到集合中。

清单 10-28。AddUserToCanvas 方法

`public void AddUserToCanvas(string canvasId, string id)`

`{`

`if (!canvasUsers.ContainsKey(canvasId))`

`{`

`canvasUsers[canvasId] = new ConcurrentDictionary<string, string>();`

`}`

`ConcurrentDictionary<string, string> users = canvasUsers[canvasId];`

`if (!users.ContainsKey(id))`

`{`

`users[id] = id;`

`}`

`}`

清单 10-29 中显示的第五种方法`RemoveUserFromCanvas`将用户从画布房间中移除。它首先检查`canvasUsers`集合中是否存在一个条目。如果一个条目确实存在并且包含一个用于`id`参数的键，该方法试图从该条目中移除`id`。

清单 10-29。RemoveUserFromCanvas 方法

`public void RemoveUserFromCanvas(string canvasId, string id)`

`{`

`if (canvasUsers.ContainsKey(canvasId))`

`{`

`ConcurrentDictionary<string, string> users = canvasUsers[canvasId];`

`if (users.ContainsKey(id))`

`{`

`string tempValue = null;`

`users.TryRemove(id, out tempValue);`

`}`

`}`

`}`

方法`GetUserName`和`StoreUserName`是简单的方法，如清单 10-30 所示，根据用户 ID 存储和检索用户名。这些方法并不依赖于`canvasId`。`GetUserName`方法检查`userNames`集合的 ID；如果存在，则返回用户名；否则返回`null`。`StoreUserName`方法将用户名存储在集合中指定的键处。

清单 10-30。get 用户名和 StoreUserName 方法

`public string GetUserName(int id)`

`{`

`if (userNames.ContainsKey(id))`

`{`

`return userNames[id];`

`}`

`return null;`

`}`

`public void StoreUserName(int id, string userName)`

`{`

`userNames[id] = userName;`

`}`

现在，让我们通过以下步骤将该类添加到我们的项目中:

Add a class named `MemoryStorage` to the `GroupBrush.BL` project under the `Storage` folder with the contents of Listing 10-31.  

清单 10-31。完整的内存存储类

`public class MemoryStorage : IMemStorage`

`{`

`private ConcurrentDictionary<string, int> canvasTransactions = new ConcurrentDictionary<string, int>();`

`private ConcurrentDictionary<string, ConcurrentBag<CanvasBrushAction>> canvasActions = new ConcurrentDictionary<string, ConcurrentBag<CanvasBrushAction>>();`

`private ConcurrentDictionary<string, ConcurrentDictionary<string,string>> canvasUsers = new ConcurrentDictionary<string, ConcurrentDictionary<string,string>>();`

`private ConcurrentDictionary<int, string> userNames = new ConcurrentDictionary<int, string>();`

`public CanvasBrushAction AddBrushAction(string canvasId, CanvasBrushAction brushData)`

`{`

`if (!canvasTransactions.ContainsKey(canvasId))`

`{`

`canvasTransactions[canvasId] = 0;`

`}`

`int transactionNumber = canvasTransactions[canvasId] = canvasTransactions[canvasId]++;`

`if (!canvasActions.ContainsKey(canvasId))`

`{`

`canvasActions[canvasId] = new ConcurrentBag<CanvasBrushAction>();`

`}`

`brushData.Sequence = transactionNumber;`

`canvasActions[canvasId].Add(brushData);`

`return brushData;`

`}`

`public List<CanvasBrushAction> GetBrushActions(string canvasId, int currentPosition)`

`{`

`List<CanvasBrushAction> actions = new List<CanvasBrushAction>();`

`if (canvasActions.ContainsKey(canvasId))`

`{`

`ConcurrentBag<CanvasBrushAction> storedActions = canvasActions[canvasId];`

`actions.AddRange(storedActions.Where(x => x.Sequence >= currentPosition));`

`}`

`actions.Sort(new Comparison<CanvasBrushAction>((a, b) => { return a.Sequence.CompareTo(b.Sequence); }));`

`return actions;`

`}`

`public List<string> GetCanvasUsers(string canvasId)`

`{`

`List<string> returnValue = new List<string>();`

`if (canvasUsers.ContainsKey(canvasId))`

`{`

`HashSet<string> uniqueList = new HashSet<string>();`

`ConcurrentDictionary<string, string> users = canvasUsers[canvasId];`

`foreach (KeyValuePair<string, string> user in users)`

`{`

`uniqueList.Add(user.Key);`

`}`

`returnValue = uniqueList.ToList<string>();`

`}`

`return returnValue;`

`}`

`public void AddUserToCanvas(string canvasId, string id)`

`{`

`if (!canvasUsers.ContainsKey(canvasId))`

`{`

`canvasUsers[canvasId] = new ConcurrentDictionary<string, string>();`

`}`

`ConcurrentDictionary<string, string> users = canvasUsers[canvasId];`

`if (!users.ContainsKey(id))`

`{`

`users[id] = id;`

`}`

`}`

`public void RemoveUserFromCanvas(string canvasId, string id)`

`{`

`if (canvasUsers.ContainsKey(canvasId))`

`{`

`ConcurrentDictionary<string, string> users = canvasUsers[canvasId];`

`if (users.ContainsKey(id))`

`{`

`string tempValue = null;`

`users.TryRemove(id, out tempValue);`

`}`

`}`

`}`

`public string GetUserName(int id)`

`{`

`if (userNames.ContainsKey(id))`

`{`

`return userNames[id];`

`}`

`return null;`

`}`

`public void StoreUserName(int id, string userName)`

`{`

`userNames[id] = userName;`

`}`

`}`

SignalR 实现的最后一个类是清单 10-32 所示的`GetCanvasDescriptionData`类。这个类提供数据层访问来检索`CanvasDescription`数据。这个类在构造函数中有一个字符串依赖项，我们将用它来注入连接字符串。

清单 10-32。GetCanvasDescriptionData 类

`public class GetCanvasDescriptionData : IGetCanvasDescriptionData`

`{`

`private string _connectionString;`

`public GetCanvasDescriptionData(string connectionString)`

`{`

`_connectionString = connectionString;`

`}`

`public CanvasDescription GetCanvasDescription(Guid canvasId)`

`{`

`CanvasDescription returnValue = null;`

`using(SqlConnection connection = new SqlConnection(_connectionString))`

`using (SqlCommand command = new SqlCommand())`

`{`

`command.Connection = connection;`

`command.CommandText = "dbo.GetCanvasDescription";`

`command.CommandType = System.Data.CommandType.StoredProcedure;`

`SqlParameter prmCanvasId = new SqlParameter("@CanvasId", SqlDbType.UniqueIdentifier) { Direction = ParameterDirection.Input, Value = canvasId };`

`SqlParameter prmCanvasName = new SqlParameter("@CanvasName", SqlDbType.NVarChar, 100) { Direction = ParameterDirection.Output};`

`SqlParameter prmCanvasDescription = new SqlParameter("@CanvasDescription", SqlDbType.NVarChar, 100) { Direction = ParameterDirection.Output };`

`command.Parameters.Add(prmCanvasId);`

`command.Parameters.Add(prmCanvasName);`

`command.Parameters.Add(prmCanvasDescription);`

`connection.Open();`

`command.ExecuteNonQuery();`

`returnValue = new CanvasDescription();`

`if (prmCanvasName != null && prmCanvasName.Value != DBNull.Value && prmCanvasName.Value is string)`

`{`

`returnValue.Name = (string)prmCanvasName.Value;`

`}`

`if (prmCanvasDescription != null && prmCanvasDescription.Value != DBNull.Value && prmCanvasDescription.Value is string)`

`{`

`returnValue.Description = (string)prmCanvasDescription.Value;`

`}`

`}`

`return returnValue;`

`}`

`}`

该方法是一个非常简单的数据层类:它在`using`语句中创建了一个新的`SqlConnection`和`SqlCommand`，这将正确地处理这些类并关闭连接。`SqlConnection`是用注入的连接字符串创建的。

该类的下一部分设置带有连接的命令的参数、存储过程名称以及要执行的命令的类型。我们添加`canvasId`作为 SQL 输入参数，并为画布名称和画布描述创建一个输出 SQL 参数。一旦一切都设置好了，我们就打开连接并执行查询。创建一个`CanvasDescription`返回值，如果`CanvasName`和`CanvasDescription`参数返回正确的值和类型，则设置`Name`和`Description`值。然后返回这个返回值。

需要通过以下步骤将该类添加到我们的项目中:

Add a class named `GetCanvasDescriptionData` to the `GroupBrush.DL` project under the `Canvases` folder with the contents of Listing 10-32.   In `GroupBrush.BL`, add a project reference to the `GroupBrush.Entity` project.   In `GroupBrush.DL`, add a project reference to the `GroupBrush.Entity` project.   In `GroupBrush.BL`, add a project reference to the `GroupBrush.DL` project.   In `GroupBrush.Web`, add a project reference to the `GroupBrush.BL` project.   In `GroupBrush.Web`, add a project reference to the `GroupBrush.En`tity project.  

我们现在已经创建了支持实时功能的类，但是我们仍然需要一种方法来提供其他非实时且不经常调用的数据。为此，我们可以使用 Web API 来提供创建和加入画布所需的端点。

### 添加 API 端点

有时我们没有到集线器的连接，或者想要创建一个，但是我们仍然需要从应用程序访问数据。我们不需要每次都创建一个集线器连接，而是需要数据来为一些请求保持集线器连接打开。我们可以使用 Web API 端点来进行数据访问。

在本节中，我们将添加用于创建和连接画布的端点。为了创建这些端点，我们必须在我们的项目中添加一些东西。以下步骤添加更多文件夹结构并安装所需的依赖项:

Add a solution folder named `Public` to the `GroupBrush.Web` project.   Add a solution folder named `Controllers` to the `Public` folder in the `GroupBrush.Web` project.   Run the following command from the Package Manager Console for the `Default` package of the `GroupBrush.Web` and `GroupBrush.Worker` projects:  

`Install-Package` `Microsoft.AspNet.WebApi.Owin`

Run the following command from the Package Manager Console for the `Default` package of the `GroupBrush.Web` and `GroupBrush.Worker` projects:  

`Install-Package` `Microsoft.AspNet.WebApi.SelfHost`

从 Web API 端点开始的第一个地方是控制器类，它派生自让我们创建 Web API 端点的`ApiController`类。我们将创建一个名为`CanvasController`的类，从`ApiController`派生而来(见清单 10-33)。

清单 10-33。CanvasController 类

`public class CanvasController : ApiController`

`{`

`ICanvasService _canvasService;`

`public CanvasController(ICanvasService canvasService)`

`{`

`_canvasService = canvasService;`

`}`

`[Route("api/canvas")]`

`[HttpPost]`

`public Guid? CreateCanvas(CanvasDescription canvasDescription)`

`{`

`Guid? canvasId = null;`

`if (canvasDescription != null)`

`{`

`canvasId = _canvasService.CreateCanvas(canvasDescription);`

`}`

`return canvasId;`

`}`

`[Route("api/canvas")]`

`[HttpPut]`

`public Guid? LookUpCanvas(CanvasName canvasName)`

`{`

`Guid? canvasId = null;`

`if (canvasName != null)`

`{`

`canvasId = _canvasService.LookUpCanvas(canvasName.Name);`

`}`

`return canvasId;`

`}`

`}`

像许多其他类一样，这个类在构造函数中注入了依赖关系。注入到`CanvasController`类的构造函数中的依赖项是清单 10-34 中的`ICanvasService`接口，它将允许我们从 Web API 端点创建和加入画布。这个注入的依赖项被设置为`CanvasController`类中的私有变量。

清单 10-34。ICanvasService 接口

`public interface ICanvasService`

`{`

`Guid? CreateCanvas(CanvasDescription canvasDescription);`

`Guid? LookUpCanvas(string canvasName);`

`}`

控制器相当简单，只包含两个方法，`CreateCanvas`和`LookUpCanvas,`，它们从注入的服务返回数据。

因为我们为 Web API 控制器使用属性路由，所以这两种方法都可以通过 URL `hostname` `+ /api/canvas`访问。但是为了给我们的 API 更多 rest 的感觉，我们使用`HttpPost`和`HttpPut`属性来限制对这些方法的访问。只有当请求中的 HTTP 动词是`Post`或`Put`时，这些属性才允许访问。(`Post`和`Put`动词分别用于创建和连接。)

类型映射将在后台发生，以填充传递给方法的数据。有时数据不明确，控制器无法正确映射值类型。我们用`LookUpCanvas`方法给它一点帮助。在这个方法中，我们告诉控制器我们期待一个类型的`CanvasName`，它只是一个字符串(见清单 10-35)。

清单 10-35。CanvasName 实体类

`public class CanvasName`

`{`

`public string Name;`

`}`

现在我们知道控制器只是调用了`ICanvasService`接口，我们需要看看实现。为了实现，在清单 10-36 中有一个名为`CanvasService (shown`的类，它从`ICanvasService`接口派生而来。它还有两个注入到构造函数中的依赖项:分别是清单 10-37 和 10-38 中的`ICreateCanvasData`和`ILookUpCanvasData (shown`。这些依赖项分别是访问数据库以创建或加入画布的接口，它们设置了类使用的私有变量。

清单 10-36。CanvasService 类

`public class CanvasService : ICanvasService`

`{`

`ICreateCanvasData _createCanvasData;`

`ILookUpCanvasData _lookUpCanvasData;`

`public CanvasService(ICreateCanvasData createCanvasData,ILookUpCanvasData lookUpCanvasData)`

`{`

`_createCanvasData = createCanvasData;`

`_lookUpCanvasData = lookUpCanvasData;`

`}`

`public Guid? CreateCanvas(CanvasDescription canvasDescription)`

`{`

`Guid? canvasId = null;`

`if (canvasDescription != null && !string.IsNullOrWhiteSpace(canvasDescription.Name) && !string.IsNullOrWhiteSpace(canvasDescription.Description))`

`{`

`canvasId = _createCanvasData.CreateCanvas(canvasDescription.Name, canvasDescription.Description);`

`}`

`return canvasId;`

`}`

`public Guid? LookUpCanvas(string canvasName)`

`{`

`Guid? canvasId = null;`

`if(!string.IsNullOrWhiteSpace(canvasName))`

`{`

`canvasId = _lookUpCanvasData.LookUpCanvas(canvasName);`

`}`

`return canvasId;`

`}`

`}`

清单 10-37。ICreateCanvasData 接口

`public interface ICreateCanvasData`

`{`

`Guid? CreateCanvas(string canvasName, string Description);`

`}`

清单 10-38。ILookUpCanvasData 接口

`public interface ILookUpCanvasData`

`{`

`Guid? LookUpCanvas(string canvasName);`

`}`

这个类中方法的逻辑进行检查，以确保传递给它们的数据不是有效的`null`或空字符串。如果数据有效，它们调用各自的数据层服务，并从这些服务返回值。

清单 10-39 中的`CreateCanvasData`类实现了我们的项目用来创建新画布的`ICreateCanvasData`接口。这个类非常简单:它在构造函数中注入了连接字符串，构造函数将连接字符串设置为一个局部变量。`CreateCanvas`方法有两个参数，`canvasName`和`canvasDescription`，它将这两个参数直接传递给存储过程。如果返回值为`0`，表示画布创建成功，并且为`canvasId`参数返回有效的`Guid`，则返回`canvasId`参数，表示画布创建成功。如果返回值不是`0`或者`canvasId`参数是`null`，则没有创建画布，对于`Guid`值返回一个`null`。

清单 10-39。CreateCanvasData 类

`public class CreateCanvasData : ICreateCanvasData`

`{`

`private string _connectionString;`

`public CreateCanvasData(string connectionString)`

`{`

`_connectionString = connectionString;`

`}`

`public Guid? CreateCanvas(string canvasName, string description)`

`{`

`Guid? returnValue = null;`

`using(SqlConnection connection = new SqlConnection(_connectionString))`

`using (SqlCommand command = new SqlCommand())`

`{`

`command.Connection = connection;`

`command.CommandText = "dbo.CreateCanvas";`

`command.CommandType = System.Data.CommandType.StoredProcedure;`

`SqlParameter prmReturnValue = new SqlParameter("@ReturnValue", SqlDbType.Int) { Direction = ParameterDirection.ReturnValue };`

`SqlParameter prmCanvasName = new SqlParameter("@CanvasName", SqlDbType.NVarChar, 100) { Direction = ParameterDirection.Input, Value = canvasName };`

`SqlParameter prmCanvasDescription = new SqlParameter("@CanvasDescription", SqlDbType.NVarChar, 255) { Direction = ParameterDirection.Input, Value = description };`

`SqlParameter prmCanvasId = new SqlParameter("@CanvasId", SqlDbType.UniqueIdentifier) { Direction = ParameterDirection.Output };`

`command.Parameters.Add(prmReturnValue);`

`command.Parameters.Add(prmCanvasName);`

`command.Parameters.Add(prmCanvasDescription);`

`command.Parameters.Add(prmCanvasId);`

`connection.Open();`

`command.ExecuteNonQuery();`

`if (prmReturnValue != null && prmReturnValue.Value != DBNull.Value && prmReturnValue.Value is int && (int)prmReturnValue.Value == 0)`

`{`

`if (prmCanvasId != null && prmCanvasId.Value != DBNull.Value && prmCanvasId.Value is Guid)`

`{`

`returnValue = (Guid)prmCanvasId.Value;`

`}`

`}`

`}`

`return returnValue;`

`}`

`}`

清单 10-40 所示的`LookUpCanvasData`类实现了我们的项目用来连接画布的`ILookUpCanvas`数据接口。这个类非常简单:连接字符串被注入到构造函数中，构造函数将连接字符串设置为一个局部变量。当调用`LookUpCanvas`方法时，它会将`canvasName`参数传递给数据库，以查看是否存在具有该名称的画布。如果返回值为`0`(表示成功找到画布，为`canvasId`参数返回有效的`Guid`)，则返回`canvasId`参数的值；否则，返回一个`null`值。

清单 10-40。LookUpCanvasData 类

`public class LookUpCanvasData : ILookUpCanvasData`

`{`

`private string _connectionString;`

`public LookUpCanvasData(string connectionString)`

`{`

`_connectionString = connectionString;`

`}`

`public Guid? LookUpCanvas(string canvasName)`

`{`

`Guid? returnValue = null;`

`using(SqlConnection connection = new SqlConnection(_connectionString))`

`using (SqlCommand command = new SqlCommand())`

`{`

`command.Connection = connection;`

`command.CommandText = "dbo. LookUpCanvas";`

`command.CommandType = System.Data.CommandType.StoredProcedure;`

`SqlParameter prmReturnValue = new SqlParameter("@ReturnValue", SqlDbType.Int) { Direction = ParameterDirection.ReturnValue };`

`SqlParameter prmCanvasName = new SqlParameter("@CanvasName", SqlDbType.NVarChar, 100) { Direction = ParameterDirection.Input, Value = canvasName };`

`SqlParameter prmCanvasId = new SqlParameter("@CanvasId", SqlDbType.UniqueIdentifier) { Direction = ParameterDirection.Output };`

`command.Parameters.Add(prmReturnValue);`

`command.Parameters.Add(prmCanvasName);`

`command.Parameters.Add(prmCanvasId);`

`connection.Open();`

`command.ExecuteNonQuery();`

`if (prmReturnValue != null && prmReturnValue.Value != DBNull.Value && prmReturnValue.Value is int && (int)prmReturnValue.Value == 0)`

`{`

`if (prmCanvasId != null && prmCanvasId.Value != DBNull.Value && prmCanvasId.Value is Guid)`

`{`

`returnValue = (Guid)prmCanvasId.Value;`

`}`

`}`

`}`

`return returnValue;`

`}`

`}`

现在是更新我们的项目以包含我们讨论过的类的好时机。我们可以通过以下步骤实现这一点:

Add the `ICanvasService` interface with the contents in Listing 10-34 to the `GroupBrush.BL` project in the `Canvases` folder.   Add the `CanvasController` class with the contents in Listing 10-33 to the `GroupBrush.Web` project in the `Controllers` folder nested under the `Public` folder.   Add the `CanvasName` class with the contents in Listing 10-35 to the `GroupBrush.Entity` project.   Add the `ICreateCanvasData` interface with the contents in Listing 10-36 to the `GroupBrush.DL` project in the `Canvases` folder.   Add the `ILookUpCanvasData` interface with the contents in Listing 10-37 to the `GroupBrush.DL` project in the `Canvases` folder.   Add the `CanvasService` class with the contents in Listing 10-38 to the `GroupBrush.BL` project in the `Canvases` folder.   Add the `CreateCanvasData` class with the contents in Listing 10-39 to the `GroupBrush.DL` project in the `Canvases` folder.   Add the `LookUpCanvasData` class with the contents in Listing 10-40 to the `GroupBrush.DL` project in the `Canvases` folder.  

下一步是添加要验证的用户。我们可以通过 ASP.NET Web API 设置用户注册和认证访问，这将在下一节中介绍。

### 保护服务器

为了保护服务器，我们添加了两个 Web API 控制器，这允许我们注册和验证用户。这两个控制器都有清单所示的`IUserService`接口，其中注入了 10-41。这两个控制器都来自于`ApiController`类。依赖注入将提供创建帐户和验证用户登录所需的用户服务，而`ApiController`类将允许这些类实现 Web API 端点。

列出 10-41。IUserService 接口

`public interface IUserService`

`{`

`int? CreateAccount(string userName, string password);`

`bool ValidateUserLogin(string userName, string password, out int? userId);`

`string GetUserNameFromId(int id);`

`}`

我们必须通过以下步骤添加一些必需的依赖项:

Run the following command from the Package Manager Console for the `Default` package of `GroupBrush.Web` and `GroupBrush.Worker`.  

`Install-Package` `Microsoft.Owin.Security.Cookies`

第一个控制器类是清单 10-42 所示的`RegisterController`类。这个类有一个由`CreateUser`方法表示的端点。这个方法的目的是创建一个新用户，并返回一个带有登录 cookie 的成功消息。通过`hostname` `+ /public/api/user`的 URL 访问端点。这个 URL 的重要之处在于，在我们锁定服务器后，没有有效的 cookie，只有根目录为`public`的条目才可以访问。

清单 10-42。RegisterController 类

`public class RegisterController : ApiController`

`{`

`IUserService _userService;`

`public RegisterController(IUserService userService)`

`{`

`_userService = userService;`

`}`

`[Route("public/api/user")]`

`[HttpPost]`

`public HttpResponseMessage CreateUser(User user)`

`{`

`HttpResponseMessage response = new HttpResponseMessage();`

`response.StatusCode = System.Net.HttpStatusCode.Forbidden;`

`if (user != null)`

`{`

`int? userId = null;`

`userId = _userService.CreateAccount(user.UserName, user.Password);`

`if(userId.HasValue && userId.Value > -1)`

`{`

`var identity = new ClaimsIdentity(CookieAuthenticationDefaults.AuthenticationType);`

`identity.AddClaim(new Claim(ClaimTypes.Name, userId.ToString()));`

`OwinHttpRequestMessageExtensions.GetOwinContext(this.Request).Authentication.SignIn(identity);`

`response.StatusCode = System.Net.HttpStatusCode.OK;`

`response.Content = new StringContent("Success");`

`}`

`}`

`return response;`

`}`

`}`

`CreateUser`方法采用清单 10-43 中定义的一个实体类`User (`,这样 Web API 将把来自请求的数据绑定到一个可用的对象。一旦我们有了用户对象，我们就使用用户服务来验证用户名和密码。如果用户服务返回一个正的用户 ID，我们将它作为一个成功创建帐户的标志，并返回一个带有登录 cookie 的`"Success"`消息。如果用户是`null`或者返回一个负的用户 ID，我们将返回一个 HTTP 状态代码`Forbidden`。(当我们讨论登录端点时，将检查创建 cookie 的逻辑)。

清单 10-43。用户实体类

`public class User`

`{`

`public string UserName { get; set; }`

`public int UserId { get; set; }`

`public string Password { get; set; }`

`}`

现在我们可以注册用户了，我们需要创建一些端点来登录、注销和验证当前的 cookie。为了将我们的登录端点合并到一个控制器，我们将创建一个`LoginController`类，它将注入`IUserService`依赖，如清单 10-44 所示。我们将使用这个用户服务来验证登录请求。

清单 10-44。LoginController 类构造函数

`IUserService _userService;`

`public LoginController(IUserService userService)`

`{`

`_userService = userService;`

`}`

查看清单 10-45 中的登录端点/方法，我们看到这个端点将接受来自 URL `hostname` `+ /public/api/login`的`Post`请求。这个方法使用清单 10-46 所示的`UserLogin`实体来获取所需的登录信息。如果用户服务可以从`UserLogin`对象中的数据验证登录，它将返回一条带有登录 cookie 的`"Success"`消息。如果`UserLogin`对象无效或者用户服务无法验证登录，则返回一个 HTTP 状态代码`Unauthorized`。

清单 10-45。登录方法

`[Route("public/api/login")]`

`[HttpPost]`

`public HttpResponseMessage Login(UserLogin login)`

`{`

`HttpResponseMessage response = new HttpResponseMessage();`

`response.StatusCode = System.Net.HttpStatusCode.Unauthorized;`

`if (login != null)`

`{`

`int? userId;`

`if (_userService.ValidateUserLogin(login.UserName, login.Password, out userId))`

`{`

`var identity = new ClaimsIdentity(CookieAuthenticationDefaults.AuthenticationType);`

`identity.AddClaim(new Claim(ClaimTypes.Name, userId.ToString()));`

`OwinHttpRequestMessageExtensions.GetOwinContext(this.Request).Authentication.SignIn(identity);`

`response.StatusCode = System.Net.HttpStatusCode.OK;`

`response.Content = new StringContent("Success");`

`}`

`}`

`return response;`

`}`

清单 10-46。用户登录实体

`public class UserLogin`

`{`

`public string UserName { get; set; }`

`public string Password { get; set; }`

`}`

如果登录成功，就会为 cookies 创建一个新的`ClaimsIdentity`。接下来，将带有密钥`"Name"`和用户 ID 数据的声明添加到`ClaimsIdentity`中，并将其传递给 OWIN 认证中间件的`SignIn`方法。对于这个例子，认证中间件是微软 OWIN 安全 cookies。因此调用的`SignIn`方法将创建一个 cookie，并在响应中返回。

有时客户端可能有一个 cookie，但这并不意味着 cookie 仍然有效。为了允许客户端查看登录是否仍然有效，我们为`Get`请求公开了 URL `hostname + /public/api/loginStatus`。如果服务器可以验证请求中的 cookie，则返回一条消息`"loggedIn"`；否则，返回一条消息`"loggedOut"`(见清单 10-47)。

清单 10-47。GetLoginStatus 方法

`[Route("public/api/loginStatus")]`

`[HttpGet]`

`public string GetLoginStatus()`

`{`

`if (User != null && User.Identity.IsAuthenticated)`

`{`

`return "loggedIn";`

`}`

`else`

`{`

`return "loggedOut";`

`}`

`}`

当用户注销时，在`hostname` `+ /public/api/logout`有一个端点可用于`Post`请求。这个端点告诉 OWIN cookie 安全性注销当前请求，这将通过注销用户来清除 cookie。一旦完成，就会返回一条消息`"Success"`(见清单 10-48)。

清单 10-48。注销方法

`[Route("public/api/logout")]`

`[HttpPost]`

`public string Logout()`

`{`

`OwinHttpRequestMessageExtensions.GetOwinContext(this.Request).Authentication.SignOut(CookieAuthenticationDefaults.AuthenticationType);`

`return "Success";`

`}`

将所有组件放在一起，你会看到清单 10-49 中完整的`LoginController`类的输出。为了更详细地了解注册和登录控制器中发生了什么，我们使用了`UserService`类。

清单 10-49。完整的 LoginController 类

`public class LoginController : ApiController`

`{`

`IUserService _userService;`

`public LoginController(IUserService userService)`

`{`

`_userService = userService;`

`}`

`[Route("public/api/loginStatus")]`

`[HttpGet]`

`public string GetLoginStatus()`

`{`

`if (User != null && User.Identity.IsAuthenticated)`

`{`

`return "loggedIn";`

`}`

`else`

`{`

`return "loggedOut";`

`}`

`}`

`[Route("public/api/login")]`

`[HttpPost]`

`public HttpResponseMessage Login(UserLogin login)`

`{`

`HttpResponseMessage response = new HttpResponseMessage();`

`response.StatusCode = System.Net.HttpStatusCode.Unauthorized;`

`if (login != null)`

`{`

`int? userId;`

`if (_userService.ValidateUserLogin(login.UserName, login.Password, out userId))`

`{`

`var identity = new ClaimsIdentity(CookieAuthenticationDefaults.AuthenticationType);`

`identity.AddClaim(new Claim(ClaimTypes.Name, userId.ToString()));`

`OwinHttpRequestMessageExtensions.GetOwinContext(this.Request).Authentication.SignIn(identity);`

`response.StatusCode = System.Net.HttpStatusCode.OK;`

`response.Content = new StringContent("Success");`

`}`

`}`

`return response;`

`}`

`[Route("public/api/logout")]`

`[HttpPost]`

`public string Logout()`

`{`

`OwinHttpRequestMessageExtensions.GetOwinContext(this.Request).Authentication.SignOut(CookieAuthenticationDefaults.AuthenticationType);`

`return "Success";`

`}`

`}`

canvas、registration 和 login 类的一个关键服务是`UserService`类，它允许为用户创建、验证和查找名称。所有这些操作都依赖于数据库来持久存储这些信息。

这个类有三个数据层项目接口和注入到构造函数中的`IMemStorage`接口来提供这些数据。清单 10-50、10-51 和 10-52 列出了数据层接口，它们分别提供了`CreateUser`、`ValidateUser`和`GetUserName`方法。

清单 10-50。ICreateUserData 接口

`public interface ICreateUserData`

`{`

`int? CreateUser(string userName, string password);`

`}`

清单 10-51。IValidateUserData 接口

`public interface IValidateUserData`

`{`

`bool ValidateUser(string userName, string password, out int? userId);`

`}`

清单 10-52。IGetUserNameFromIdData 接口

`public interface IGetUserNameFromIdData`

`{`

`string GetUserName(int id);`

`}`

清单 10-53 所示的类逻辑相对简单:`CreateAccount`和`ValidateUserLogin`返回传递给数据层接口的数据。`GetUserName`的方法并不复杂多少；它检查用户名的`IMemStorage`实现。如果它不存在或者是空字符串，它将向数据层查询此信息。如果用户名在数据层中找到，它被存储在`IMemStorage`实现中，然后从方法中返回。

清单 10-53。用户服务类

`public class UserService : IUserService`

`{`

`ICreateUserData _createUserData;`

`IValidateUserData _validateUserData;`

`IGetUserNameFromIdData _getUserNameFromIdData;`

`IMemStorage _memStorage;`

`public UserService(ICreateUserData createUserData, IValidateUserData validateUserData, IGetUserNameFromIdData getUserNameFromIdData, IMemStorage memStorage)`

`{`

`_createUserData = createUserData;`

`_validateUserData = validateUserData;`

`_getUserNameFromIdData = getUserNameFromIdData;`

`_memStorage = memStorage;`

`}`

`public int? CreateAccount(string userName, string password)`

`{`

`return _createUserData.CreateUser(userName, password);`

`}`

`public bool ValidateUserLogin(string userName, string password, out int? userId)`

`{`

`return _validateUserData.ValidateUser(userName, password, out userId);`

`}`

`public string GetUserNameFromId(int id)`

`{`

`string userName = _memStorage.GetUserName(id);`

`if (string.IsNullOrWhiteSpace(userName))`

`{`

`userName = _getUserNameFromIdData.GetUserName(id);`

`if (!string.IsNullOrWhiteSpace(userName))`

`{`

`_memStorage.StoreUserName(id, userName);`

`}`

`}`

`return userName;`

`}`

`}`

现在我们讨论创建数据层接口的具体类实现。第一个实现是清单 10-54 所示的`CreateUserData`类，它实现了`ICreateUserData`接口。

该类将在构造函数中注入连接字符串，并通过`CreateUser`存储过程将`userName`和密码参数传递给数据库。存储过程返回两个输出参数，`ReturnValue`和`UserId`，用于确定用户是否创建成功。如果`ReturnValue`参数等于`0`，且`UserId`参数为正整数，则返回`UserId`参数的值。如果`ReturnValue`参数等于`0`，并且`UserId`参数未被填充，它将返回一个值`-1`来指示一个错误。如果`ReturnValue`无效，该方法将返回`null`。

清单 10-54。CreateUserData 类

`public class CreateUserData : ICreateUserData`

`{`

`private string _connectionString;`

`public CreateUserData(string connectionString)`

`{`

`_connectionString = connectionString;`

`}`

`public int? CreateUser(string userName, string password)`

`{`

`int? returnValue = null;`

`using(SqlConnection connection = new SqlConnection(_connectionString))`

`using (SqlCommand command = new SqlCommand())`

`{`

`command.Connection = connection;`

`command.CommandText = "dbo.CreateUser";`

`command.CommandType = System.Data.CommandType.StoredProcedure;`

`SqlParameter prmReturnValue = new SqlParameter("@ReturnValue", SqlDbType.Int) { Direction = ParameterDirection.ReturnValue };`

`SqlParameter prmName = new SqlParameter("@Name", SqlDbType.NVarChar, 100) { Direction = ParameterDirection.Input, Value = userName };`

`SqlParameter prmPassword = new SqlParameter("@Password", SqlDbType.NVarChar, 255) { Direction = ParameterDirection.Input, Value = password };`

`SqlParameter prmUserId = new SqlParameter("@UserId", SqlDbType.Int) { Direction = ParameterDirection.Output };`

`command.Parameters.Add(prmReturnValue);`

`command.Parameters.Add(prmName);`

`command.Parameters.Add(prmPassword);`

`command.Parameters.Add(prmUserId);`

`connection.Open();`

`command.ExecuteNonQuery();`

`if(prmReturnValue != null && prmReturnValue.Value != DBNull.Value && prmReturnValue.Value is int && (int)prmReturnValue.Value == 0)`

`{`

`if(prmUserId != null && prmUserId.Value != DBNull.Value && prmUserId.Value is int)`

`{`

`returnValue = (int)prmUserId.Value;`

`}`

`else`

`{`

`returnValue = -1;`

`}`

`}`

`}`

`return returnValue;`

`}`

`}`

清单 10-55 所示的`ValidateUserData`类在构造函数中注入了连接字符串。该类将通过`ValidateUser`存储过程将`userName`和`password`参数传递给数据库，同时期望三个输出参数:`ReturnValue`、`ValidUser`和`UserId`。如果`ValidUser`参数等于`1`，并且`UserId`参数填充了有效值，则`out userId`参数被设置为来自`UserId`参数的值，并且该方法返回`true`。否则，`out userId`参数为`null`，方法返回`false`。

清单 10-55。ValidateUserData 类

`public class ValidateUserData : IValidateUserData`

`{`

`private string _connectionString;`

`public ValidateUserData(string connectionString)`

`{`

`_connectionString = connectionString;`

`}`

`public bool ValidateUser(string userName, string password, out int? userId)`

`{`

`bool returnValue = false;`

`userId = null;`

`using(SqlConnection connection = new SqlConnection(_connectionString))`

`using (SqlCommand command = new SqlCommand())`

`{`

`command.Connection = connection;`

`command.CommandText = "dbo.ValidateUser";`

`command.CommandType = System.Data.CommandType.StoredProcedure;`

`SqlParameter prmName = new SqlParameter("@Name", SqlDbType.NVarChar, 100) { Direction = ParameterDirection.Input, Value = userName };`

`SqlParameter prmPassword = new SqlParameter("@Password", SqlDbType.NVarChar, 255) { Direction = ParameterDirection.Input, Value = password };`

`SqlParameter prmValidUser = new SqlParameter("@ValidUser", SqlDbType.Int) { Direction = ParameterDirection.Output };`

`SqlParameter prmUserId = new SqlParameter("@UserId", SqlDbType.Int) { Direction = ParameterDirection.Output };`

`command.Parameters.Add(prmName);`

`command.Parameters.Add(prmPassword);`

`command.Parameters.Add(prmValidUser);`

`command.Parameters.Add(prmUserId);`

`connection.Open();`

`command.ExecuteNonQuery();`

`if (prmValidUser != null && prmValidUser.Value != DBNull.Value && prmValidUser.Value is int && (int)prmValidUser.Value == 1)`

`{`

`if (prmUserId != null && prmUserId.Value != DBNull.Value && prmUserId.Value is int)`

`{`

`userId = (int)prmUserId.Value;`

`returnValue = true;`

`}`

`}`

`}`

`return returnValue;`

`}`

`}`

清单 10-56 所示的`GetUserNameFromIdData`类在构造函数中注入了连接字符串。该类将通过`GetUserName`存储过程将`id`参数传递给数据库。该过程需要一个输出参数`UserName`。如果`UserName`参数是字符串值，则为方法返回；否则，返回`null`。

清单 10-56。GetUserNameFromIdData 类

`public class GetUserNameFromIdData : IGetUserNameFromIdData`

`{`

`private string _connectionString;`

`public GetUserNameFromIdData(string connectionString)`

`{`

`_connectionString = connectionString;`

`}`

`public string GetUserName(int id)`

`{`

`string returnValue = null;`

`using (SqlConnection connection = new SqlConnection(_connectionString))`

`using (SqlCommand command = new SqlCommand())`

`{`

`command.Connection = connection;`

`command.CommandText = "dbo.GetUserName";`

`command.CommandType = System.Data.CommandType.StoredProcedure;`

`SqlParameter prmUserId = new SqlParameter("@UserId", SqlDbType.Int) { Direction = ParameterDirection.Input, Value = id };`

`SqlParameter prmUserName = new SqlParameter("@UserName", SqlDbType.NVarChar, 100) { Direction = ParameterDirection.Output };`

`command.Parameters.Add(prmUserName);`

`command.Parameters.Add(prmUserId);`

`connection.Open();`

`command.ExecuteNonQuery();`

`if (prmUserName != null && prmUserName.Value != DBNull.Value && prmUserName.Value is string)`

`{`

`returnValue = (string)prmUserName.Value;`

`}`

`}`

`return returnValue;`

`}`

`}`

现在我们已经介绍了保护服务器的所有逻辑，让我们通过以下步骤将它添加到我们的项目中:

Add the `RegisterController` class with the contents in Listing 10-42 to the `GroupBrush.Web` project in the `Controllers` folder nested under the `Public` folder.   Add the `User` class with the contents in Listing 10-43 to the `GroupBrush.Entity` project.   Add the `UserLogin` class with the contents in Listing 10-46 to the `GroupBrush.Entity` project.   Add the `LoginController` class with the contents in Listing 10-49 to the `GroupBrush.Web` project in the `Controllers` folder nested under the `Public` folder.   Add the `ICreateUserData` interface with the contents in Listing 10-50 to the `GroupBrush.DL` project in the `Users` folder.   Add the `IValidateUserData` interface with the contents in Listing 10-51 to the `GroupBrush.DL` project in the `Users` folder.   Add the `IGetUserNameFromIdData` interface with the contents in Listing 10-52 to the `GroupBrush.DL` project in the `Users` folder.   Add the `UserService` class with the contents in Listing 10-53 to the `GroupBrush.BL` project in the `Users` folder.   Add the `CreateUserData` class with the contents in Listing 10-54 to the `GroupBrush.DL` project in the `Users` folder.   Add the `ValidateUserData` class with the contents in Listing 10-55 to the `GroupBrush.DL` project in the `Users` folder.   Add the `GetUserNameFromIdData` class with the contents in Listing 10-56 to the `GroupBrush.DL` project in the `Users` folder.  

现在我们已经拥有了所有的组件，我们将向您展示如何设置依赖解析器，这将允许构造函数依赖注入拥有我们想要的实现类。

### 设置相关性解析器

对于这个项目，我们将使用 Unity 容器。我们通过以下步骤将其添加到我们的项目中:

Add a solution folder named `Unity` to the `GroupBrush.Web` project.   Run the following command from the Package Manager Console for the `Default` package of `GroupBrush.Web` and `GroupBrush.Worker`:  

`Install-Package` `Unity`

为了让 Unity 在我们的项目中工作，我们必须创建一个适配器来处理 SignalR 和 Web API 依赖解析器接口，以及一个助手类来配置我们的容器注册。这两个类都将被添加到`GroupBrush.Web`项目中。

查看清单 10-57 中显示的`UnityDependencyResolver`类定义，您可以看到我们从 SignalR `DefaultDependencyResolver`派生并实现了 Web API `IDependencyResolver`接口，这使我们能够共享功能。这在大多数情况下工作良好，但是它缺少 Web API 通常从`DefaultDependencyResolver` Web API 获得的默认注册。

列出 10-57。UnityDependencyResolver 类定义

`public class UnityDependencyResolver : DefaultDependencyResolver, System.Web.Http.Dependencies.` `IDependencyResolver`

解析器的下一部分是构造函数和私有变量。清单 10-58 显示了两个构造函数。第一个构造函数是一个使用内部 Unity 容器的空构造函数。第二个构造函数接受一个容器，它将用于该类，这是为 Web API `BeginScope`方法提供功能所必需的(见清单 10-61)。

清单 10-58。UnityDependencyResolver 构造函数和私有变量

`IUnityContainer _container = new UnityContainer();`

`public UnityDependencyResolver()`

`{ }`

`public UnityDependencyResolver(IUnityContainer container)`

`{`

`_container = container;`

`}`

接下来是信号`DefaultDependencyResolver`的覆盖。我们使用这些方法来尝试使用 Unity 容器进行解析或注册。

在 10-59 清单中的 resolve 方法`GetService`和`GetServices`中，没有一种友好的方式来查看 Unity 是否可以解析一个类型，因此必须使用一个`try-catch`语句，如果解析失败，就退回到基类。

列出 10-59。UnityDependencyResolver 信号程序默认值 DependencyResolver 覆盖

`public override object GetService(Type serviceType)`

`{`

`try`

`{`

`return _container.Resolve(serviceType);`

`}`

`catch`

`{`

`return base.GetService(serviceType);`

`}`

`}`

`public override IEnumerable<object> GetServices(Type serviceType)`

`{`

`try`

`{`

`List<object> services = _container.ResolveAll(serviceType).ToList();`

`object defaultService = GetService(serviceType);`

`if (defaultService != null) services.Add(defaultService);`

`return services;`

`}`

`catch`

`{`

`return base.GetServices(serviceType);`

`}`

`}`

`public override void Register(Type serviceType, IEnumerable<Func<object>> activators)`

`{`

`_container.RegisterType(serviceType, new InjectionFactory((c) =>`

`{`

`object returnObject = null;`

`foreach (Func<Object> activator in activators)`

`{`

`object tempObject = activator.Invoke();`

`if (tempObject != null)`

`{`

`returnObject = tempObject;`

`break;`

`}`

`}`

`return returnObject;`

`}));`

`base.Register(serviceType, activators);`

`}`

注册函数采用`DefaultDependencyResolver Register`方法在 Unity 容器中注册服务，然后在基类中注册服务。这很有用，因为如果一个对象可以从 Unity 容器中解析出来，就避免了从基类中解析它的异常惩罚。

每个依赖注入容器都有自己的语法来提供注册、解析和容器生存期管理。所以为了使用 Unity 的一些特性，我们创建了一些方法来公开清单 10-60 中所示的 Unity 方法。第一种方法允许我们向实现注册一个接口。第二种方法与第一种方法相同，但也允许我们控制注册的`LifeTimeManager`。第三种方法允许我们将类型注册到我们定义的激活函数中。

清单 10-60。有用的 Unity 注册方法

`public void RegisterType<TFrom,TTo>(params InjectionMember [] injectionMembers) where TTo : TFrom`

`{`

`_container.RegisterType<TFrom, TTo>(injectionMembers);`

`}`

`public void RegisterType<TFrom, TTo>(LifetimeManager lifetimeManager, params InjectionMember[] injectionMembers) where TTo : TFrom`

`{`

`_container.RegisterType<TFrom, TTo>(lifetimeManager, injectionMembers);`

`}`

`public override void Register(Type serviceType, Func<object> activator)`

`{`

`_container.RegisterType(serviceType, new InjectionFactory((c) => activator.Invoke()));`

`base.Register(serviceType, activator);`

`}`

`public void RegisterInstance<TInterface>(TInterface instance)`

`{`

`_container.RegisterInstance<TInterface>(instance);`

`}`

`DependencyResolver`的最后一部分是清单 10-61 所示的`BeginScope`方法，它是为了 Web API 兼容性而添加的。它允许为每个进来的请求创建一个子容器。这允许对每个请求进行唯一的注册和解析。如果子容器中的解析不成功，它将冒泡到父容器中寻找解析。

清单 10-61。Web API IDependencyResolver 方法

`public IDependencyScope BeginScope()`

`{`

`return new UnityDependencyResolver(_container.CreateChildContainer());`

`}`

现在所有的方法都在一起了，你可以看到一个完整的`DependencyResolver`类，如清单 10-62 所示。为了使用新的解析器，我们将在一个静态类中配置注册(接下来讨论)。

清单 10-62。完全 UnityDependencyResolver 类

`public class UnityDependencyResolver : DefaultDependencyResolver, System.Web.Http.Dependencies.IDependencyResolver`

`{`

`IUnityContainer _container = new UnityContainer();`

`public UnityDependencyResolver()`

`{ }`

`public UnityDependencyResolver(IUnityContainer container)`

`{`

`_container = container;`

`}`

`public override object GetService(Type serviceType)`

`{`

`try`

`{`

`return _container.Resolve(serviceType);`

`}`

`catch`

`{`

`return base.GetService(serviceType);`

`}`

`}`

`public override IEnumerable<object> GetServices(Type serviceType)`

`{`

`try`

`{`

`List<object> services = _container.ResolveAll(serviceType).ToList();`

`object defaultService = GetService(serviceType);`

`if (defaultService != null) services.Add(defaultService);`

`return services;`

`}`

`catch`

`{`

`return base.GetServices(serviceType);`

`}`

`}`

`public override void Register(Type serviceType, IEnumerable<Func<object>> activators)`

`{`

`_container.RegisterType(serviceType, new InjectionFactory((c) =>`

`{`

`object returnObject = null;`

`foreach (Func<Object> activator in activators)`

`{`

`object tempObject = activator.Invoke();`

`if (tempObject != null)`

`{`

`returnObject = tempObject;`

`break;`

`}`

`}`

`return returnObject;`

`}));`

`base.Register(serviceType, activators);`

`}`

`public void RegisterType<TFrom,TTo>(params InjectionMember [] injectionMembers) where TTo : TFrom`

`{`

`_container.RegisterType<TFrom, TTo>(injectionMembers);`

`}`

`public void RegisterType<TFrom, TTo>(LifetimeManager lifetimeManager, params InjectionMember[] injectionMembers) where TTo : TFrom`

`{`

`_container.RegisterType<TFrom, TTo>(lifetimeManager, injectionMembers);`

`}`

`public override void Register(Type serviceType, Func<object> activator)`

`{`

`_container.RegisterType(serviceType, new InjectionFactory((c) => activator.Invoke()));`

`base.Register(serviceType, activator);`

`}`

`public void RegisterInstance<TInterface>(TInterface instance)`

`{`

`_container.RegisterInstance<TInterface>(instance);`

`}`

`public IDependencyScope BeginScope()`

`{`

`return new UnityDependencyResolver(_container.CreateChildContainer());`

`}`

`}`

对于大多数类型来说，清单 10-63 中的`UnityWireupConfiguration`类是一个非常简单的注册。但是有几个注册是不同的。

清单 10-63。UnityWireupConfiguration 类

`public class UnityWireupConfiguration`

`{`

`public static void WireUp(UnityDependencyResolver dependencyResolver)`

`{`

`string groupBrushSQLConnectionString = CloudConfigurationManager.GetSetting("GroupBrushDB");`

`dependencyResolver.RegisterType<IUserService, UserService>(new ContainerControlledLifetimeManager());`

`dependencyResolver.RegisterType<ICanvasService,CanvasService>();`

`dependencyResolver.RegisterType<ICanvasRoomService, CanvasRoomService>();`

`dependencyResolver.RegisterType<IMemStorage, MemoryStorage>(new ContainerControlledLifetimeManager());`

`dependencyResolver.Register(typeof(IGetUserNameFromIdData), () => new GetUserNameFromIdData(groupBrushSQLConnectionString));`

`dependencyResolver.Register(typeof(IGetCanvasDescriptionData), () => new GetCanvasDescriptionData(groupBrushSQLConnectionString));`

`dependencyResolver.Register(typeof(ICreateUserData), () => new CreateUserData(groupBrushSQLConnectionString));`

`dependencyResolver.Register(typeof(IValidateUserData), () => new ValidateUserData(groupBrushSQLConnectionString));`

`dependencyResolver.Register(typeof(ICreateCanvasData), () => new CreateCanvasData(groupBrushSQLConnectionString));`

`dependencyResolver.Register(typeof(ILookUpCanvasData), () => new LookUpCanvasData(groupBrushSQLConnectionString));`

`}`

`}`

`WireUp`方法的第一行从提供与`App.Config`和云配置兼容的`CloudConfigurationManager`中检索配置设置。然后，这些配置值可以像 SQL 连接字符串一样传递给注册。

第二行为该注册提供了一个`ContainerControlledLifeTimeManager`。这意味着对象将存在于容器的整个生命周期中，而其他注册类型会在每次请求时重新创建。

最后，类型注册的顺序很重要；应首先注册依赖于其他注册的注册。

再一次，是时候通过以下步骤将 Unity 容器类添加到我们的项目中了:

Add the `UnityDependencyResolver` class with the contents in Listing 10-62 to the `GroupBrush.Web` project in the `Unity` folder.   Add the `UnityWireupConfiguration` class with the contents in Listing 10-63 to the `GroupBrush.Web` project in the `Unity` folder.   Add a reference from the `GroupBrush.Web` project to the `GroupBrush.DL` project.   Add a reference to the `Microsoft.WindowsAzure.Configuration` assembly in the `GroupBrush.Web` project.  

接下来，我们必须设置 OWIN 管道，以便应用程序能够以正确的顺序和逻辑处理请求。

### 建立 OWIN 管道

`StartUp`类建立了 OWIN 管道，它将处理每一个进来的请求。`StartUp`类有一个特殊的 assembly 属性，表示 OWIN 管道应该使用这个类进行配置。(你可以在清单 10-64 中看到这个属性的例子。)我们项目的配置有四个设置区域:依赖解析器、认证、Web API 和 SignalR。类似于 Unity 设置，事物注册到`IAppBuilder`的顺序很重要。

清单 10-64。OwinStart 属性

`[assembly: OwinStartup(typeof(GroupBrush.Web.Startup))]`

在`StartUp`配置中首先要设置的是依赖解析器，它是通过使用清单 10-65 中的三行和清单 10-67 中的一行来完成的(稍后显示)。第一行创建了我们将用于 SignalR 和 Web API 的依赖解析器。我们可以使用静态的`WireUp`方法来配置它，这是在第二行完成的。第三行将 SignalR 配置为使用我们在第一行中创建的依赖关系解析器。(Web API 需要第四行配置，这将在 Web API 一节中讨论)。

清单 10-65。相关性解析程序设置

`var dependencyResolver = new UnityDependencyResolver();`

`UnityWireupConfiguration.WireUp(dependencyResolver);`

`GlobalHost.DependencyResolver = dependencyResolver;`

接下来要添加到`StartUp`类中的是清单 10-66 所示的认证。对于身份验证，为 cookie 身份验证创建一个配置类。在这个配置中，我们希望默认的 cookie 身份验证类型和任何登录/注销重定向返回到根路径。使用我们的 cookie 配置，我们用`UseCookieAuthentication`方法设置了 OWIN 管道中的第一个条目。我们添加到 OWIN 管道的下一个条目允许对`root`或`public`文件夹的请求继续到管道中的下一个中间件。如果请求没有继续到下一个中间件，并且用户是`null`或未认证的，那么请求会以`401`响应停止。最后，如果请求已经进行到这一步，它将继续到管道中的下一个中间件。

清单 10-66。认证设置

`var options = new CookieAuthenticationOptions()`

`{`

`AuthenticationType = CookieAuthenticationDefaults.AuthenticationType,`

`LoginPath = new PathString("/"),`

`LogoutPath = new PathString("/")`

`};`

`app.UseCookieAuthentication(options);`

`app.Use(async (context, next) =>`

`{`

`if (context.Request.Path.Value.Equals("/") || context.Request.Path.Value.StartsWith("/public", StringComparison.CurrentCultureIgnoreCase))`

`{`

`await next();`

`}`

`else if (context.Request.User == null || !context.Request.User.Identity.IsAuthenticated)`

`{`

`context.Response.StatusCode = 401;`

`}`

`else`

`{`

`await next();`

`}`

`});`

设置好身份验证之后，Web API 是我们想要运行的下一个中间件。我们使用清单 10-67 中的设置为 Web API 中间件创建一个配置。在那个配置中，我们添加了我们在清单 10-65 中创建的依赖解析器，这样 Web API 将使用那个依赖解析器。接下来，我们将配置告诉`MapHttpAttributeRoutes`，这将使我们能够使用 Web API 属性路由特性。我们使用`UseWebApi`扩展方法将 Web API 添加到 OWIN 管道中。

清单 10-67。Web API 设置

`HttpConfiguration webApiConfiguration = new HttpConfiguration();`

`webApiConfiguration.DependencyResolver = dependencyResolver;`

`webApiConfiguration.MapHttpAttributeRoutes();`

`app.UseWebApi(webApiConfiguration);`

最后，我们用一行代码添加了 SignalR 中间件，如清单 10-68 所示。

清单 10-68。信号设置

`app.MapSignalR();`

如果你把这四个部分按正确的顺序排列，你将得到一个完整的`StartUp`类，如清单 10-69 所示。但是不要忘记清单 10-64 中的`OwinStartUp`属性，它对于应用程序知道使用哪个配置是至关重要的。

清单 10-69。完成启动类

`public class Startup`

`{`

`public void Configuration(IAppBuilder app)`

`{`

`var dependencyResolver = new UnityDependencyResolver();`

`UnityWireupConfiguration.WireUp(dependencyResolver);`

`GlobalHost.DependencyResolver = dependencyResolver;`

`var options = new CookieAuthenticationOptions()`

`{`

`AuthenticationType = CookieAuthenticationDefaults.AuthenticationType,`

`LoginPath = new PathString("/"),`

`LogoutPath = new PathString("/")`

`};`

`app.UseCookieAuthentication(options);`

`app.Use(async (context, next) =>`

`{`

`if (context.Request.Path.Value.Equals("/") || context.Request.Path.Value.StartsWith("/public", StringComparison.CurrentCultureIgnoreCase))`

`{`

`await next();`

`}`

`else if (context.Request.User == null || !context.Request.User.Identity.IsAuthenticated)`

`{`

`context.Response.StatusCode = 401;`

`}`

`else`

`{`

`await next();`

`}`

`});`

`HttpConfiguration webApiConfiguration = new HttpConfiguration();`

`webApiConfiguration.DependencyResolver = dependencyResolver;`

`webApiConfiguration.MapHttpAttributeRoutes();`

`app.UseWebApi(webApiConfiguration);`

`app.MapSignalR();`

`}`

`}`

要添加`StartUp`配置，我们遵循以下步骤:

Add an OWIN `StartUp` class to the root of the `GroupBrush.Web` project with the contents of Listing 10-69.   Ensure that the `OwinStartUp` attribute is included in the `StartUp.cs` file created in step 1 and is similar to Listing 10-64.  

我们现在已经创建了运行服务器所需的所有代码，但是需要一个应用程序来托管它。对于这个应用程序，我们将以 Azure 云服务工作者的角色托管(接下来讨论)。

## 在 Azure 中托管服务器

对于这个项目，Microsoft Azure cloud 是一个很好的候选，可以支持我们需要的所有平台，以获得一个可伸缩、可靠且易于维护的应用程序。我们将使用云服务平台以工作者角色托管我们的应用程序。

我们将涵盖对项目至关重要的以下五个工人角色领域:

*   实现`RoleEntryPoint`类
*   创建云服务
*   配置工作人员角色
*   在本地测试我们的部署
*   将我们的应用程序部署到云中

在涵盖了这五个方面之后，我们将拥有一个以工作者角色运行的完全部署的应用程序。

### 实现 RoleEntryPoint 类

首先，我们想实现`RoleEntryPoint`类。Azure 使用这个类作为入口点来启动、停止和运行 worker 角色中的代码。当我们创建`GroupBrush.Worker`项目时，它创建了一个从`RoleEntryPoint`类派生的`WorkerRole`类。我们将使用这个类来托管我们的应用程序。当它在云中运行时，我们可以分别使用`OnStart`和`OnStop`方法启动和停止我们的应用程序。

因为已经创建了`WorkerRole`类，我们将使用它并添加一些更改。第一个变化是添加一个负责处理`WebApp`的变量。下一个变化是通过使用我们的 OWIN `StartUp`类和配置调用 WebApp 通用静态启动方法来启动`WebApp`。所提供的配置是应该托管`WebApp`的端点。我们通过在为实例配置的端点中寻找`SignalREndpoint`来确定端点。

最后，我们希望有一种方法来停止应用程序；我们通过在从`start`方法返回的`IDisposable`对象上调用`dispose`方法来实现。一旦所有这些都完成了，代码将类似于清单 10-70。

清单 10-70。工人阶级

`public class WorkerRole : RoleEntryPoint`

`{`

`IDisposable _webApp = null;`

`public override void Run()`

`{`

`while (true)`

`{`

`Thread.Sleep(10000);`

`Trace.TraceInformation("Working");`

`}`

`}`

`public override bool OnStart()`

`{`

`ServicePointManager.DefaultConnectionLimit = 12;`

`RoleInstanceEndpoint signalREndpoint = null;`

`if (RoleEnvironment.CurrentRoleInstance.InstanceEndpoints.TryGetValue("SignalREndpoint", out signalREndpoint))`

`{`

`_webApp = WebApp.Start<Startup>(string.Format("{0}://{1}", signalREndpoint.Protocol, signalREndpoint.IPEndpoint));`

`}`

`else`

`{`

`throw new KeyNotFoundException("Could not find SignalREndpoint");`

`}`

`return base.OnStart();`

`}`

`public override void OnStop()`

`{`

`if (_webApp != null)`

`{`

`_webApp.Dispose();`

`}`

`base.OnStop();`

`}`

`}`

让我们通过以下步骤将这些更改添加到我们的项目中:

Update the `WorkerRole` class in the `GroupBrush.Worker` project with the contents of Listing 10-70.   Add a reference from the `GroupBrush.Worker` project to the `GroupBrush.Web` project.   Run the following command from the Package Manager Console for the `Default` package of `GroupBrush.Worker`:  

`Install-Package Microsoft.Owin.Hosting`

`Install-Package Microsoft.Owin.Host.HttpListener`

这就是在云中启动和停止我们的应用程序所需的全部代码。现在我们有了代码，我们必须在云中创建一个主机来运行它。

### 创建云服务

因为我们已经有了工作者角色的代码，所以我们需要在 Azure 上创建一个云服务来托管它。创建云服务的方法有很多，但我们将使用 Visual Studio 中的服务器资源管理器来完成。

通过使用以下步骤，一个项目只能创建一次云服务:

![A978-1-4302-6320-3_10_Fig3_HTML.jpg](A978-1-4302-6320-3_10_Fig3_HTML.jpg)

图 10-3。

Create Cloud Service dialog box Complete the following on the Create Cloud Service dialog box, as shown in Figure [10-3](#Fig3): Choose the subscription that you want this cloud service to be associated with.   Enter a name for the cloud service.   Choose where you want this cloud service deployed.     Finally, click Create after all the correct information is entered.  

![A978-1-4302-6320-3_10_Fig2_HTML.jpg](A978-1-4302-6320-3_10_Fig2_HTML.jpg)

图 10-2。

Cloud Services context menu Right-click on Cloud Services to display the context menu and then click Create Cloud Service, as shown in Figure [10-2](#Fig2).  

![A978-1-4302-6320-3_10_Fig1_HTML.jpg](A978-1-4302-6320-3_10_Fig1_HTML.jpg)

图 10-1。

Azure components in Server Explorer Sign in to Visual Studio with the account that is associated to the Azure account.   Open the Server Explorer and navigate to Cloud Services, as shown in Figure [10-1](#Fig1).  

现在应该有一个云服务可以在 Azure 中使用了。现在我们需要创建一个数据库，将我们的数据保存在云中。

### 创建 Azure SQL 数据库

在我们的应用程序中，我们需要持久化用户和画布等数据，因此我们将使用 Azure SQL 数据库。创建数据库非常简单；我们遵循以下步骤:

In the Server tab, click Create a New Server.   In the New Server tab, do the following: Enter server name.   Enter server admin name.   Enter admin password.   Enter admin password again to confirm.   Click OK.   Click Create.    

![A978-1-4302-6320-3_10_Fig5_HTML.jpg](A978-1-4302-6320-3_10_Fig5_HTML.jpg)

图 10-5。

Creating a new SQL database configuration In the SQL database tab, do the following, as shown in Figure [10-5](#Fig5): Enter the database name.   Click the server button to configure the server.    

![A978-1-4302-6320-3_10_Fig4_HTML.jpg](A978-1-4302-6320-3_10_Fig4_HTML.jpg)

图 10-4。

Creating a new SQL Database Log in to [`http://portal.azure.com`](http://portal.azure.com/) .   Click the New(+) button in the bottom left.   Click SQL Database (see Figure [10-4](#Fig4)).  

我们为应用程序存储了两组记录:用户和画布。因此，我们需要在数据库中创建两个表:一个用于用户，另一个用于画布。

`Users`表由每条记录的三个值组成，如清单 10-71 所示:用户 ID、用户名和密码。

清单 10-71。用户表创建脚本

`USE [GroupBrush]`

`GO`

`CREATE TABLE [dbo].[Users](`

`[UserId] [int] IDENTITY(1,1) NOT NULL PRIMARY KEY,`

`[Name] [nvarchar](100) NOT NULL,`

`[Password] [nvarchar](255) NOT NULL`

`) ON [PRIMARY]`

`GO`

清单 10-72 所示的`Canvases`表也非常简单。它包含画布表 ID、画布 ID、画布名称和画布描述。

清单 10-72。画布表格创建脚本

`USE [GroupBrush]`

`GO`

`CREATE TABLE [dbo].[Canvases](`

`[CanvasTableId] [bigint] IDENTITY(1,1) NOT NULL PRIMARY KEY,`

`[CanvasId] [uniqueidentifier] NOT NULL,`

`[CanvasName] [nvarchar](100) NOT NULL,`

`[CanvasDescription] [nvarchar](100) NOT NULL`

`) ON [PRIMARY]`

`GO`

要将这些表添加到我们的数据库中，请遵循以下步骤:

Connect to the database using SQL Server Management Studio.   Run the complete script in Listing 10-71 to add the `Users` table.   Run the complete script in Listing 10-72 to add the `Canvases` table.   Note

在 Azure 中使用 MS SQL 时，一个表必须有一个主键才能使用。

现在已经创建了表，我们可以创建存储过程来支持数据层功能。因为存储过程是简化的，所以我们不会深入每个过程的细节，而只给出一个简短的描述:

*   如清单 10-73 所示，创建一个新用户，返回用户 ID。
*   清单 10-74 中显示的`ValidateUser`，验证用户登录。
*   如清单 10-75 所示，从用户 ID 中获取用户名。
*   清单 10-76 中显示的`CreateCanvas`，创建一个新的画布，返回画布 ID。
*   清单 10-77 所示的`LookUpCanvas`，从名称中获取画布的 ID。
*   如清单 10-78 所示，从画布 ID 中获取画布名称和描述。

清单 10-73。创建用户存储过程

`USE [GroupBrush]`

`GO`

`CREATE Procedure [dbo].[CreateUser](`

`@Name nchar(100),`

`@Password nchar(255),`

`@UserId int output`

`)`

`As`

`Begin`

`Declare @ReturnValue int = -1`

`If Exists(Select 1 From dbo.Users Where Name = @Name)`

`Begin`

`Set @ReturnValue = 1`

`End`

`Else`

`Begin`

`Declare @UserIds Table (userId int)`

`INSERT INTO [dbo].[Users]`

`([Name]`

`,[Password])`

`Output Inserted.UserId Into @UserIds(userId)`

`VALUES`

`(@Name`

`,@Password)`

`Select @ReturnValue = 0, @UserId = userId From @UserIds`

`End`

`Return @` `ReturnValue`

`End`

`GO`

清单 10-74。ValidateUser 存储过程

`USE [GroupBrush]`

`GO`

`CREATE Procedure [dbo].[ValidateUser](`

`@Name nchar(100),`

`@Password nchar(255),`

`@UserId int  = NULL output,`

`@ValidUser bit output`

`)`

`As`

`Begin`

`Select @UserId = UserId From dbo.Users Where Name = @Name and Password = @Password`

`If (@UserId Is Not Null)`

`Begin`

`Set @ValidUser = 1`

`End`

`Else`

`Begin`

`Set @ValidUser = 0`

`End`

`End`

`GO`

清单 10-75。GetUserName 存储过程

`USE [GroupBrush]`

`GO`

`Create Procedure [dbo].[GetUserName](`

`@UserId Int,`

`@UserName NVarChar(100) Output`

`)`

`As`

`Begin`

`Select @UserName = Name From dbo.Users where UserId = @UserId`

`End`

`GO`

列出 10-76。CreateCanvas 存储过程

`USE [GroupBrush]`

`GO`

`CREATE Procedure [dbo].[CreateCanvas](`

`@CanvasName nchar(100),`

`@CanvasDescription nchar(255),`

`@CanvasId UniqueIdentifier output`

`)`

`As`

`Begin`

`Declare @ReturnValue int = -1`

`If Exists(Select 1 From dbo.Canvases Where CanvasName = @CanvasName)`

`Begin`

`Set @ReturnValue = 1`

`End`

`Else`

`Begin`

`Declare @CanvasIds Table (CanvasId UniqueIdentifier)`

`INSERT INTO [dbo].[Canvases]`

`([CanvasId]`

`,[CanvasName]`

`,[CanvasDescription])`

`Output Inserted.CanvasId Into @CanvasIds(CanvasId)`

`VALUES`

`(NewID()`

`,@` `CanvasName`

`,@CanvasDescription)`

`Select  @ReturnValue = 0,`

`@CanvasId = CanvasId`

`From @CanvasIds`

`End`

`Return @ReturnValue`

`End`

`GO`

清单 10-77。LookUpCanvas 存储过程

`USE [GroupBrush]`

`GO`

`CREATE Procedure [dbo].[LookUpCanvas](`

`@CanvasName nvarchar(100),`

`@CanvasId UniqueIdentifier = NULL output`

`)`

`As`

`Begin`

`Declare @ReturnValue int = -1`

`Select @CanvasId = CanvasId From dbo.Canvases Where CanvasName = @CanvasName`

`If @CanvasId Is Not Null`

`Begin`

`Set @ReturnValue = 0`

`End`

`Return @ReturnValue`

`End`

`GO`

清单 10-78。GetCanvasDescription 存储过程

`USE [GroupBrush]`

`GO`

`Create Procedure [dbo].[GetCanvasDescription](`

`@CanvasId UniqueIdentifier,`

`@CanvasName NVarChar(100) Output,`

`@CanvasDescription NVarChar(100) Output`

`)`

`As`

`Begin`

`Select @CanvasName = CanvasName, @CanvasDescription = CanvasDescription`

`From dbo.Canvases`

`Where CanvasId = @CanvasId`

`End`

`GO`

现在我们知道需要哪些存储过程，所以让我们通过以下步骤将它们添加到我们的数据库中:

Connect to the database using SQL Server Management Studio.   Run the complete script in Listing 10-73 to add the `CreateUser` stored procedure.   Run the complete script in Listing 10-74 to add the `ValidateUser` stored procedure.   Run the complete script in Listing 10-75 to add the `GetUserName` stored procedure.   Run the complete script in Listing 10-76 to add the `CreateCanvas` stored procedure.   Run the complete script in Listing 10-77 to add the `LookUpCanvas` stored procedure.   Run the complete script in Listing 10-78 to add the GetCanvasDescription stored procedure.  

现在数据库工作已经完成，让我们继续配置 worker 角色。

### 配置工作人员角色

为了让 worker 角色正常工作，我们必须在运行时添加一些设置。根据我们运行的环境，这些设置也可以改变。本节简要介绍以下配置选项卡:设置、端点和配置。工人角色的配置可在该工人角色的属性下找到(见图 [10-6](#Fig6) )。

![A978-1-4302-6320-3_10_Fig6_HTML.jpg](A978-1-4302-6320-3_10_Fig6_HTML.jpg)

图 10-6。

Worker role context menu

对于应用程序配置，根据代码运行的位置，有不同的设置是很常见的。为了适应这种情况，我们可以为所有配置(云、本地)配置配置，或者添加我们自己的服务配置。所有配置将该配置应用于所有配置，而不管它在哪里运行，但是可以在特定配置中覆盖它。

当工作者角色在 Azure 上运行时，使用云配置。当应用程序在本地运行进行测试时，将使用本地配置。每个配置选项卡都允许对该选项卡允许您配置的所有配置值进行服务配置设置。

第一个选项卡是设置选项卡(见图 [10-7](#Fig7) )，可以在其中添加字符串和连接字符串。这是一个非常简单的配置:对于每个条目，我们给它一个名称、条目类型和值。该选项卡存储简单设置或数据库连接字符串，可以通过名称检索。

![A978-1-4302-6320-3_10_Fig7_HTML.jpg](A978-1-4302-6320-3_10_Fig7_HTML.jpg)

图 10-7。

Azure worker role Settings tab

在此配置选项卡中，我们通过以下步骤为数据库设置连接字符串:

Go to the Settings tab in the worker role configuration.   Click Add Setting.   On the newly added setting, change the name to GroupBrushDB.   Change the type to String.   Change the value to be the value of the connection string of the database created in the previous section.  

下一个选项卡是端点选项卡，如图 [10-8](#Fig8) 所示。这些设置用于确定工作者角色所允许的端点。端点具有名称、类型(方向)、公共端口、专用端口和 SSL 证书名称。我们需要添加一个端点，这样工人就有一个暴露于互联网的端口来接收请求。

![A978-1-4302-6320-3_10_Fig8_HTML.jpg](A978-1-4302-6320-3_10_Fig8_HTML.jpg)

图 10-8。

Azure worker role Endpoints tab

要添加端点，请按照下列步骤操作:

Go to the Endpoints tab in the worker role configuration.   Click Add Endpoint.   On the newly added Endpoint entry, change the name to SignalREndpoint.   Change the type to Input.   Change the protocol to http.   Make the public and private ports 80.   Leave the SSL certificate name blank.   Press Ctrl+S to save your settings.  

添加端点后，还有最后一个选项卡:配置选项卡(见图 [10-9](#Fig9) )。这是用于选择默认情况下我们希望运行的 worker 角色的大小和实例数量的选项卡。

![A978-1-4302-6320-3_10_Fig9_HTML.jpg](A978-1-4302-6320-3_10_Fig9_HTML.jpg)

图 10-9。

Azure worker role Configuration tab

虽然我们没有涵盖 worker 角色可用的所有可能的配置选项卡，但是我们讨论了最常见的选项卡。现在我们必须在本地测试我们的部署。

### 本地测试部署

因为应用程序是基于云的，所以您可能认为我们需要部署到云上来测试它。有了 Azure 云服务，情况就不一样了——我们可以使用微软提供的 Azure 计算模拟器。

要进行本地测试，请将`GroupBrush.Cloud`项目设置为`StartUp`项目。设置完成后，我们可以通过按 F5 使用模拟器运行/调试项目。当应用程序运行时，我们看到类似图 [10-10](#Fig10) 的输出，方法是在任务通知区域右键单击 Azure 模拟器，然后单击显示计算模拟器 UI。

![A978-1-4302-6320-3_10_Fig10_HTML.jpg](A978-1-4302-6320-3_10_Fig10_HTML.jpg)

图 10-10。

Azure Compute Emulator

随着我们的应用程序在本地运行，我们现在必须将它部署到云中。

### 将应用程序部署到云

我们终于准备好将我们的应用程序部署到云中了。我们已经实现了运行服务器的代码，创建了托管服务器的云服务，创建了为服务器保存数据的 SQL 数据库，配置了服务器环境，并在本地测试了服务器。部署非常简单明了。部署通常需要几分钟才能完成，所以需要部署时请耐心等待。

可以先将您的服务部署到一个临时环境中，然后在您确认它可以在临时环境中工作后，将它转移到一个“生产”环境中。我们将展示如何直接部署到“生产”，这与登台是一样的(只需要在发布步骤中选择不同的环境)。要部署到“生产”，请遵循以下步骤:

Click Publish.  

![A978-1-4302-6320-3_10_Fig13_HTML.jpg](A978-1-4302-6320-3_10_Fig13_HTML.jpg)

图 10-13。

Publish summary dialog box Validate settings in the Publish Summary dialog box similar to Figure [10-13](#Fig13).  

![A978-1-4302-6320-3_10_Fig12_HTML.jpg](A978-1-4302-6320-3_10_Fig12_HTML.jpg)

图 10-12。

Publish Settings dialog box Sign in to the Azure account and click Next.   In the Publish Settings section shown in Figure [10-12](#Fig12), do the following: Choose the cloud service that was set up earlier.   Change the environment to Production.   Click Next.    

![A978-1-4302-6320-3_10_Fig11_HTML.jpg](A978-1-4302-6320-3_10_Fig11_HTML.jpg)

图 10-11。

Cloud Service context menu Right-click the `GroupBrush.Cloud` project and click Publish, as shown in Figure [10-11](#Fig11).  

既然我们已经成功发布了，我们的应用程序应该在云中运行。但是如果它很受欢迎，需要规模化呢？接下来将讨论如何扩展应用程序。

## 扩展服务器

为了将我们的应用程序扩展到一个实例之外，我们需要能够处理以下方面:

*   实例间的通信
*   内存存储
*   机器之间的不同认证

一旦我们解决了这些问题，应用程序应该能够很好地扩展。

要解决的第一个问题是实例之间的通信，这对于确保来自一个实例上的用户的消息在所有其他实例上都可用是至关重要的。为了解决这个问题，我们可以使用 SignalR 支持的众多横向扩展解决方案之一。

对于这个有大量消息并且延迟非常明显的应用程序，Redis 横向扩展解决方案是最合适的。该解决方案需要一个专用的服务器，但是它比我们应用程序的 SQL 或 MessageBus 解决方案好得多。

Azure 最近添加了 Redis 缓存作为 PaaS，效果很好，非常容易设置。为了支持我们的应用程序的可伸缩性，通过以下步骤将 Redis 缓存添加到 Azure:

Log in to [`http://portal.azure.com`](http://portal.azure.com/) .   Click the New(+) button in the bottom left.   Click on Redis Cache.   Enter a name for the cache.   Choose the resource group of the existing application objects.   Choose the same location as the existing application.   Click Create.  

我们现在有一个 Redis 缓存，可以随时使用。

转移到内存存储，这在只有一个实例时工作得很好，但现在不行了，因为数据将位于不同实例的内存中。因为我们使用 Redis 作为我们的横向扩展解决方案，所以我们也可以将它用作实例之间的共享内存。

为此，我们需要创建一个为 Redis 实现`IMemStorage`的类。所以我们创建了从`IMemStorage`派生的`RedisStorage`类，如清单 10-79 所示。

清单 10-79。重定向类定义

`public class RedisStorage : IMemStorage`

清单 10-80 中的 RedisStorage 构造函数有一个被注入的依赖项。注入的项是 RedisConfiguration，如清单 10-81 中所定义，它提供了 Redis 的配置。

清单 10-80。再存储构造函数

`public RedisStorage(RedisConfiguration redisConfiguration)`

`{`

`_redisConfiguration = redisConfiguration;`

`_userNames = new Dictionary<int, string>();`

`}`

清单 10-81。重分布实体类

`public class RedisConfiguration`

`{`

`public string HostName { get; set; }`

`public string Password { get; set; }`

`public int Port { get; set; }`

`public bool UseRedis { get; set; }`

`public string EventKey { get; set; }`

`public RedisConfiguration(string hostName, string password, bool useRedis)`

`{`

`HostName = hostName;`

`Password = password;`

`UseRedis = useRedis;`

`Port = 6379;`

`EventKey = "GroupBrush";`

`}`

`}`

清单 10-82 显示了`RedisStorage`的私有变量。有四个前缀用于保持对象类型之间的键的唯一性。还有一个内存字典来存储用户名，以防止在 Redis 服务器上多次查找用户名。

清单 10-82。再存储私有变量

`private const string TRANSACTION_PREFIX = "CanvasTransaction:";`

`private const string ACTION_PREFIX = "CanvasBrushAction:";`

`private const string USERS_PREFIX = "CanvasUsers:";`

`private const string USERNAMES_PREFIX = "CanvasUsernames:";`

`private readonly RedisConfiguration _redisConfiguration;`

`Dictionary<int, string> _userNames;`

第一个方法是`AddBrushAction`方法，它连接到 Redis 服务器以获取画布的下一个事务编号，并将其用作传入的`CanvasBrushAction`的序列。接下来，它获取`CanvasBrushAction`，将其序列化为 JSON，并将其添加到 Redis 服务器上的画布列表中。最后，它返回`CanvasBrushAction`对象。

清单 10-83。AddBrushAction 方法

`public CanvasBrushAction AddBrushAction(string canvasId, CanvasBrushAction brushData)`

`{`

`int transactionNumber = 0;`

`using (var conn = new RedisConnection(_redisConfiguration.HostName,_redisConfiguration.Port,password: _redisConfiguration.Password))`

`{`

`conn.Open();`

`var incrTask = conn.Hashes.Increment(0, TRANSACTION_PREFIX + canvasId, "transaction");`

`transactionNumber = (int)incrTask.Result;`

`}`

`brushData.Sequence = transactionNumber;`

`string serializedData = JsonConvert.SerializeObject(brushData);`

`using (var conn = new RedisConnection(_redisConfiguration.HostName,_redisConfiguration.Port,password: _redisConfiguration.Password))`

`{`

`conn.Open();`

`conn.Lists.AddLast(0, ACTION_PREFIX + canvasId, serializedData);`

`}`

`return brushData;`

`}`

清单 10-84 中显示的`GetBrushActions`方法联系 Redis 服务器，并请求从当前位置到最新条目的所有已存储的`CanvasBrushAction`。如果 Redis 返回了结果，它会反序列化每个 JSON 对象，并将其添加到要返回的操作列表中。然后，这些操作按序号排序。最后返回这些动作。

清单 10-84。GetBrushActions 方法

`public List<CanvasBrushAction> GetBrushActions(string canvasId, int currentPosition)`

`{`

`List<CanvasBrushAction> actions = new List<CanvasBrushAction>();`

`string[] storedActions = null;`

`using (var conn = new RedisConnection(_redisConfiguration.HostName,_redisConfiguration.Port,password: _redisConfiguration.Password))`

`{`

`conn.Open();`

`var rangeTask = conn.Lists.RangeString(0, ACTION_PREFIX + canvasId, currentPosition, Int32.MaxValue);`

`storedActions = rangeTask.Result;`

`}`

`if (storedActions != null)`

`{`

`foreach (string storedAction in storedActions)`

`{`

`actions.Add(JsonConvert.DeserializeObject<CanvasBrushAction>(storedAction));`

`}`

`actions.Sort(new Comparison<CanvasBrushAction>((a, b) => { return a.Sequence.CompareTo(b.Sequence); }));`

`}`

`return actions;`

`}`

清单 10-85 中的`GetCanvasUser`方法非常简单:它连接到 Redis 服务器以获取连接到该画布的用户列表。然后，该方法将所有用户通过一个`HashSet`来获取唯一用户，并返回唯一用户。

清单 10-85。GetCanvasUsers 方法

`public List<string> GetCanvasUsers(string canvasId)`

`{`

`List<string> returnValue = new List<string>();`

`HashSet<string> uniqueList = new HashSet<string>();`

`using (var conn = new RedisConnection(_redisConfiguration.HostName,_redisConfiguration.Port,password: _redisConfiguration.Password))`

`{`

`conn.Open();`

`var getAllTask = conn.Sets.GetAllString(0, USERS_PREFIX + canvasId);`

`uniqueList = new HashSet<string>(getAllTask.Result.ToList());`

`}`

`returnValue = uniqueList.ToList<string>();`

`return returnValue;`

`}`

清单 10-86 中的`AddUserToCanvas`方法是另一个简单的方法，它将传入的 ID 添加到 Redis 服务器上指定画布 ID 的用户列表中。

清单 10-86。AddUserToCanvas 方法

`public void AddUserToCanvas(string canvasId, string id)`

`{`

`using (var conn = new RedisConnection(_redisConfiguration.HostName,_redisConfiguration.Port,password: _redisConfiguration.Password))`

`{`

`conn.Open();`

`conn.Sets.Add(0, USERS_PREFIX + canvasId, id);`

`}`

`}`

清单 10-87 中的`RemoveUserFromCanvas`方法类似于前面的方法，但是它删除用户而不是添加用户。

清单 10-87。RemoveUserFromCanvas 方法

`public void RemoveUserFromCanvas(string canvasId, string id)`

`{`

`using (var conn = new RedisConnection(_redisConfiguration.HostName,_redisConfiguration.Port,password: _redisConfiguration.Password))`

`{`

`conn.Open();`

`conn.Sets.Remove(0, USERS_PREFIX + canvasId, id);`

`}`

`}`

清单 10-88 所示的`GetUserName`和`StoreUserName`方法结合使用内存和`RedisStorage`来存储数据。为了防止在`GetUserName`方法中对 username 进行大量的进程外查找，该方法首先查看其内部 username 结构，看它是否存在。如果没有，它将连接到 Redis 服务器来检索它。`StoreUserName`方法首先将数据存储在 Redis 服务器上，然后存储在内存中。

清单 10-88。get 用户名和 StoreUserName 方法

`public string GetUserName(int id)`

`{`

`string userName = null;`

`if (_userNames.ContainsKey(id))`

`{`

`userName = _userNames[id];`

`}`

`else`

`{`

`using (var conn = new RedisConnection(_redisConfiguration.HostName,_redisConfiguration.Port,password: _redisConfiguration.Password))`

`{`

`conn.Open();`

`var getTask = conn.Strings.GetString(0, USERNAMES_PREFIX + id.ToString());`

`userName = getTask.Result;`

`_userNames[id] = userName;`

`}`

`}`

`return userName;`

`}`

`public void StoreUserName(int id, string userName)`

`{`

`using (var conn = new RedisConnection(_redisConfiguration.HostName,_redisConfiguration.Port,password: _redisConfiguration.Password))`

`{`

`conn.Open();`

`conn.Strings.Set(0, USERNAMES_PREFIX + id.ToString(), userName).Wait();`

`}`

`_userNames[id] = userName;`

`}`

一旦把`RedisStorage`类的所有部分放在一起，我们就看到了完整的类(见清单 10-89)。

清单 10-89。完全再存储类

`public class RedisStorage : IMemStorage`

`{`

`private const string TRANSACTION_PREFIX = "CanvasTransaction:";`

`private const string ACTION_PREFIX = "CanvasBrushAction:";`

`private const string USERS_PREFIX = "CanvasUsers:";`

`private const string USERNAMES_PREFIX = "CanvasUsernames:";`

`private readonly RedisConfiguration _redisConfiguration;`

`Dictionary<int, string> _userNames;`

`public RedisStorage(RedisConfiguration redisConfiguration)`

`{`

`_redisConfiguration = redisConfiguration;`

`_userNames = new Dictionary<int, string>();`

`}`

`public CanvasBrushAction AddBrushAction(string canvasId, CanvasBrushAction brushData)`

`{`

`int transactionNumber = 0;`

`using (var conn = new RedisConnection(_redisConfiguration.HostName,_redisConfiguration.Port,password: _redisConfiguration.Password))`

`{`

`conn.Open();`

`var incrTask = conn.Hashes.Increment(0, TRANSACTION_PREFIX + canvasId, "transaction");`

`transactionNumber = (int)incrTask.Result;`

`}`

`brushData.Sequence = transactionNumber;`

`string serializedData = JsonConvert.SerializeObject(brushData);`

`using (var conn = new RedisConnection(_redisConfiguration.HostName,_redisConfiguration.Port,password: _redisConfiguration.Password))`

`{`

`conn.Open();`

`conn.Lists.AddLast(0, ACTION_PREFIX + canvasId, serializedData);`

`}`

`return brushData;`

`}`

`public List<CanvasBrushAction> GetBrushActions(string canvasId, int currentPosition)`

`{`

`List<CanvasBrushAction> actions = new List<CanvasBrushAction>();`

`string[] storedActions = null;`

`using (var conn = new RedisConnection(_redisConfiguration.HostName,_redisConfiguration.Port,password: _redisConfiguration.Password))`

`{`

`conn.Open();`

`var rangeTask = conn.Lists.RangeString(0, ACTION_PREFIX + canvasId, currentPosition, Int32.MaxValue);`

`storedActions = rangeTask.Result;`

`}`

`if (storedActions != null)`

`{`

`foreach (string storedAction in storedActions)`

`{`

`actions.Add(JsonConvert.DeserializeObject<CanvasBrushAction>(storedAction));`

`}`

`actions.Sort(new Comparison<CanvasBrushAction>((a, b) => { return a.Sequence.CompareTo(b.Sequence); }));`

`}`

`return actions;`

`}`

`public List<string> GetCanvasUsers(string canvasId)`

`{`

`List<string> returnValue = new List<string>();`

`HashSet<string> uniqueList = new HashSet<string>();`

`using (var conn = new RedisConnection(_redisConfiguration.HostName,_redisConfiguration.Port,password: _redisConfiguration.Password))`

`{`

`conn.Open();`

`var getAllTask = conn.Sets.GetAllString(0, USERS_PREFIX + canvasId);`

`uniqueList = new HashSet<string>(getAllTask.Result.ToList());`

`}`

`returnValue = uniqueList.ToList<string>();`

`return returnValue;`

`}`

`public void AddUserToCanvas(string canvasId, string id)`

`{`

`using (var conn = new RedisConnection(_redisConfiguration.HostName,_redisConfiguration.Port,password: _redisConfiguration.Password))`

`{`

`conn.Open();`

`conn.Sets.Add(0, USERS_PREFIX + canvasId, id);`

`}`

`}`

`public void RemoveUserFromCanvas(string canvasId, string id)`

`{`

`using (var conn = new RedisConnection(_redisConfiguration.HostName,_redisConfiguration.Port,password: _redisConfiguration.Password))`

`{`

`conn.Open();`

`conn.Sets.Remove(0, USERS_PREFIX + canvasId, id);`

`}`

`}`

`public string GetUserName(int id)`

`{`

`string userName = null;`

`if (_userNames.ContainsKey(id))`

`{`

`userName = _userNames[id];`

`}`

`else`

`{`

`using (var conn = new RedisConnection(_redisConfiguration.HostName,_redisConfiguration.Port,password: _redisConfiguration.Password))`

`{`

`conn.Open();`

`var getTask = conn.Strings.GetString(0, USERNAMES_PREFIX + id.ToString());`

`userName = getTask.Result;`

`_userNames[id] = userName;`

`}`

`}`

`return userName;`

`}`

`public void StoreUserName(int id, string userName)`

`{`

`using (var conn = new RedisConnection(_redisConfiguration.HostName,_redisConfiguration.Port,password: _redisConfiguration.Password))`

`{`

`conn.Open();`

`conn.Strings.Set(0, USERNAMES_PREFIX + id.ToString(), userName).Wait();`

`}`

`_userNames[id] = userName;`

`}`

`}`

完成之后，我们已经解决了关于内存的第二个问题。所以要解决的最后一个问题是机器之间的不同认证。

无论何时部署应用程序实例，它都是用唯一的键创建的。因此，如果您部署多个实例，每个实例都有自己唯一的键。每次在服务器上加密 cookie 时，都会使用其他实例无法解密的密钥对其进行加密。

为了纠正这一点，我们可以创建一个类，在每个实例上以相同的方式加密和解密密钥。`AesDataProtector`类实现了`IDataProtector`(参见清单 10-90)。对于这个类，我们在构造函数中注入我们希望它使用的密码和 salt。然后，构造函数使用一个内置函数返回我们可以用作键和初始向量(IV)的字节。

清单 10-90。AesDataProtector 类

`public class AesDataProtector : IDataProtector`

`{`

`private byte [] _IV;`

`private byte [] _key;`

`public AesDataProtector(string password, string salt)`

`{`

`Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(password, Encoding.ASCII.GetBytes(salt));`

`_key = key.GetBytes(256 / 8);`

`_IV = key.GetBytes(128 / 8);`

`}`

`public byte[] Protect(byte[] userData)`

`{`

`byte[] encrypted;`

`using (AesCryptoServiceProvider aesAlg = new AesCryptoServiceProvider() )`

`{`

`aesAlg.Key = _key;`

`aesAlg.IV = _IV;`

`ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);`

`using (MemoryStream msEncrypt = new MemoryStream())`

`{`

`using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))`

`{`

`csEncrypt.Write(userData, 0, userData.Length);`

`csEncrypt.FlushFinalBlock();`

`encrypted = msEncrypt.ToArray();`

`}`

`}`

`}`

`return encrypted;`

`}`

`public byte[] Unprotect(byte[] protectedData)`

`{`

`byte[] output = null;`

`using (AesCryptoServiceProvider aesAlg = new AesCryptoServiceProvider())`

`{`

`aesAlg.Key = _key;`

`aesAlg.IV = _IV;`

`ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);`

`using (MemoryStream msDecrypt = new MemoryStream(protectedData))`

`{`

`using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))`

`{`

`byte[] buffer = new byte[8];`

`using (MemoryStream msOutput = new MemoryStream())`

`{`

`int read;`

`while ((read = csDecrypt.Read(buffer, 0, buffer.Length)) > 0)`

`{`

`msOutput.Write(buffer, 0, read);`

`}`

`output = msOutput.ToArray();`

`}`

`}`

`}`

`}`

`return output;`

`}`

`}`

有两个函数，`Protect`和`Unprotect`，它们非常简单，在`Protect`函数中对数据进行加密，在`Unprotect`函数中对数据进行解密。

要使用新的 AesDataProtector 类，我们必须提供一个实现`IDataProtectionProvider`接口的 provider 类(见清单 10-91)。这个类被构造成当调用`Create`方法返回这个`AesDataProtector`时，在构造函数中注入一个`AesDataProtector`。

清单 10-91。AesDataProtectionProvider 类

`public class AesDataProtectionProvider : IDataProtectionProvider`

`{`

`AesDataProtector _dataProtector;`

`public AesDataProtectionProvider(AesDataProtector dataProtector)`

`{`

`_dataProtector = dataProtector;`

`}`

`public IDataProtector Create(params string[] purposes)`

`{`

`return _dataProtector;`

`}`

`}`

解决了缩放限制后，让我们通过以下步骤将缩放添加到我们的项目中:

Run the following command from the Package Manager Console for the `Default` package of `GroupBrush.Worker` and `GroupBrush.Web`:  

`Install-Package` `Microsoft.AspNet.SignalR.Redis`

Run the following command from the Package Manager Console for the `Default` package of `GroupBrush.BL`:  

`Install-Package` `BookSleeve -version x.y.z`

Make sure the installed version is the same as the other projects.  

`Install-Package` `Newtonsoft.Json  -version x.y.z`

Add a setting named `GroupBrushRedisHostname` with the value of the host name of the Redis server (the host name under the properties menu for Azure Redis Cache).   Add a setting named `GroupBrushRedisPassword` with the value of the password of the Redis server (the primary under the keys menu for Azure Redis Cache).   Add a setting named `UseRedis` with the value of `true` for cloud configuration and `false` for local configuration.   Add the contents of Listing 10-92 to the top of the `WireUp` method in the `UnityWireupConfiguration` class.   Add the `RedisConfiguration` class with the contents of Listing 10-81 in the `GroupBrush.Entity` project.   Add the `RedisStorage` class with the contents of Listing 10-89 under the `Storage` folder in the `GroupBrush.BL` project.   Add a `DataProtectors` solution folder to the `GroupBrush.BL` project.   Add the `AesDataProtector` class with the contents of Listing 10-90 under the `DataProtectors` folder in the `GroupBrush.BL` project.   Add the `AesDataProtectionProvider` class with the contents of Listing 10-91 under the `DataProtectors` folder in the `GroupBrush.BL` project.   Add configuration settings to the `GroupBrush.Worker` role:   Make sure the installed version is the same as the other projects.  

清单 10-92。重定向配置设置

`string groupBrushRedisHostname = CloudConfigurationManager.GetSetting("GroupBrushRedisHostname");`

`string groupBrushRedisPassword = CloudConfigurationManager.GetSetting("GroupBrushRedisPassword");`

`string strUseRedis = CloudConfigurationManager.GetSetting("UseRedis") ?? "false";`

`bool useRedis = bool.Parse(strUseRedis);`

`RedisConfiguration redisConfiguration = new RedisConfiguration(groupBrushRedisHostname,groupBrushRedisPassword,useRedis);`

`dependencyResolver.RegisterInstance<RedisConfiguration>(redisConfiguration);`

Replace the line from Listing 10-93 with Listing 10-94 in the `UnityWireupConfiguration` class.  

清单 10-93。要替换的 IMemStorage 设置

`dependencyResolver.RegisterType<IMemStorage, MemoryStorage>(new ContainerControlledLifetimeManager());`

清单 10-94。IMemStorage 替换设置

`if (useRedis)`

`{`

`dependencyResolver.RegisterType<IMemStorage, RedisStorage>(new ContainerControlledLifetimeManager(), new InjectionConstructor(redisConfiguration));`

`}`

`else`

`{`

`dependencyResolver.RegisterType<IMemStorage, MemoryStorage>(new ContainerControlledLifetimeManager());`

`}`

Add the logic in Listing 10-95 at the top of the `Configuration` method in `StartUp.cs`.  

清单 10-95。resis`Configuration Logic`用于 StartUp.cs

`string strUseRedis = CloudConfigurationManager.GetSetting("UseRedis") ?? "false";`

`bool useRedis = bool.Parse(strUseRedis);`

Add the logic in Listing 10-96 between the `UseWebApi` and `MapSignalR` functions of the `Configuration` method in StartUp.cs.  

清单 10-96。Redis 配置用于 StartUp.cs 中的信号

`RedisConfiguration redisConfiguration = dependencyResolver.Resolve<RedisConfiguration>();`

`if (redisConfiguration.UseRedis)`

`{`

`GlobalHost.DependencyResolver.UseRedis(redisConfiguration.HostName, redisConfiguration.Port, redisConfiguration.Password, redisConfiguration.EventKey);`

`}`

Update the instance count in the `GroupBrush.Worker Configuration` tab to increase the number of instances.  

现在有了一个全功能的服务器，所以下一步是创建可以连接到它的客户机。

## 开发客户

为了连接到服务器，我们将创建一个 JavaScript 客户机。即使客户端将在它们自己的机器上运行，我们也必须在服务器上为它们托管内容。为了做到这一点，我们将使用 OWIN 静态文件中间件，以普通网站会有的 URL 形式提供内容。内容存储在特定的结构中，并且需要添加 OWIN 中间件，因此我们在继续之前完成以下步骤:

Run the following command from the Package Manager Console for the `Default` package of `GroupBrush.Web` and `GroupBrush.Worker`.  

`Install-Package Microsoft.AspNet.SignalR.JS`

`Install-Package Microsoft.Owin.StaticFiles`

Add a solution folder named `Content` to the `GroupBrush.Web` project.   Add a solution folder named `Content` to the `Public` folder in the `GroupBrush.Web` project.   Add a solution folder named `Scripts` to the `Public` folder in the `GroupBrush.Web` project.   Add a solution folder named `Styles` to the `Public` folder in the `GroupBrush.Web` project.   Add a solution folder named `Styles` to the `GroupBrush.Web` project.   Add the content in Listing 10-97 to the end of the `Configuration` method in the `StartUp.cs` file.  

清单 10-97。设置 OWIN 静态文件中间件的选项

`var sharedOptions = new SharedOptions() { RequestPath = new PathString(string.Empty), FileSystem = new PhysicalFileSystem(".//public//content") };`

`app.UseDefaultFiles(new Microsoft.Owin.StaticFiles.DefaultFilesOptions(sharedOptions) { DefaultFileNames = new List<string>() { "index.html" } });`

`app.UseStaticFiles("/public");`

`app.UseStaticFiles("/content");`

`app.UseStaticFiles("/scripts");`

`app.UseStaticFiles("/styles");`

`app.UseStaticFiles(new StaticFileOptions(sharedOptions));`

在清单 10-97 中，第一行设置了将任何对根文档的请求重定向到`Public`内容文件夹的选项。如果请求的路径不包含文件，下一行设置默认文档`index.html`。其余线路建立它们各自的路径，以响应对这些路径的请求。

### 开发客户主页

对于我们的客户端，用户将看到三个视图:主页注销、主页登录和画布空间页面。

用户看到的第一个页面是登出的主页，如图 [10-14](#Fig14) 所示，该页面为访问者提供了一个创建帐户或登录的页面。一旦用户登录，他们会看到一个类似于图 [10-15](#Fig15) 的屏幕，这让他们能够退出，创建画布，或加入画布。这两个视图都是清单 10-98 中的同一个`index.html`页面，但是应用了不同的`.css`类。最后一个视图是画布页，可以在图 [10-16](#Fig16) 的章节中看到。在这个视图中，用户可以进行实时绘图和聊天。

![A978-1-4302-6320-3_10_Fig15_HTML.jpg](A978-1-4302-6320-3_10_Fig15_HTML.jpg)

图 10-15。

Signed-in index page

![A978-1-4302-6320-3_10_Fig14_HTML.jpg](A978-1-4302-6320-3_10_Fig14_HTML.jpg)

图 10-14。

Signed-out index page

清单 10-98。Index.html

`<!DOCTYPE html>`

`<html xmlns="`[`http://www.w3.org/1999/xhtml`](http://www.w3.org/1999/xhtml)T2】

`<head>`

`<title>Group Brush</title>`

`<link rel="stylesheet" type="text/css" href="/public/styles/Index.css" />`

`<script src="/public/scripts/jquery-1.6.4.min.js"></script>`

`<script src="/public/scripts/Index.js"></script>`

`</head>`

`<body>`

`<div id="mainContent">`

`<div id="mainMessage">`

`<h1>Group Brush</h1>`

`<div id="loadingMessage">Loading...</div>`

`</div>`

`<div id="actionContent">`

`<div class="loggedOut" id="createAccountContent">`

`<div>`

`<span>Welcome to Group Brush</span><br />`

`<span>This site is for friends to draw together. Please Sign-In or Create an account.</span>`

`</div>`

`<div id="createAccount">`

`<span class="sectionTitle">Create account</span><br />`

`<span>User name:</span><input name="username" id="username" type="text" /><br />`

`<span>Password:</span><input name="password" id="password" type="password" /><br />`

`<span>Verify Password:</span><span id="passwordNotEqual" class="error">Passwords do not match</span><input name="verifyPassword" id="verifyPassword" type="password" />`

`<span id="createAccountError" class="error">Could not create account</span>`

`<button id="btnCreateAccount">Create Account</button>`

`</div>`

`</div>`

`<div class="loggedIn" id="canvasActionContent">`

`<div id="createCanvasContainer">`

`<span class="sectionTitle">Create shared canvas</span>`

`<span>Canvas name:</span><input name="canvasname" id="canvasname" type="text" /><br />`

`<span>Canvas Description:</span><input name="canvasdescription" id="canvasdescription" type="text" /><br />`

`<span id="createCanvasError" class="error">Could not create canvas</span>`

`<button id="btnCreateCanvas">Create Canvas</button>`

`</div>`

`<div id="joinCanvasContainer">`

`<span class="sectionTitle">Join shared canvas</span>`

`<span>Canvas name:</span><input name="canvasname" id="canvasname" type="text" /><br />`

`<span id="joinCanvasError" class="error">Could not join canvas</span>`

`<button id="btnJoinCanvas">Join Canvas</button>`

`</div>`

`</div>`

`</div>`

`</div>`

`<div id="userContent">`

`<div class="loggedOut">`

`<div id="loginWidget">`

`<div id="LogIn">`

`<form id="loginForm">`

`<span id="signIn">Sign In</span><br />`

`<span>User name:</span><input name="username" id="username" type="text" />`

`<span>Password:</span><input name="password" id="password" type="password" />`

`</form>`

`<span id="loginError" class="error">Could not login</span>`

`<button id="btnLogin">Login</button>`

`</div>`

`</div>`

`</div>`

`<div class="loggedIn">`

`<div id="LogOut">`

`<button id="btnLogout">Logout</button>`

`</div>`

`</div>`

`</div>`

`</body>`

`</html>`

清单 10-98 中的 HTML 显示了代表`loggedIn`和`loggedOut`州的`div`。本章中演示的 HTML 和样式是简化的，不是最佳实践，所以我们不详细介绍。

继续看清单 10-99 中的`.css`类，大部分样式是为各种页面函数设置`div`容器。`loggedOut`和`loggedIn .css`都设置为`display: none`；这样做是因为 JavaScript 中的服务器端`loggedIn`检查将在页面加载时设置正确的状态。

清单 10-99。Index.css

`div.loggedOut{`

`display: none;`

`}`

`div.loggedIn{`

`display: none;`

`}`

`div#mainContent{`

`float: left;`

`}`

`div#userContent{`

`float: left;`

`}`

`div#mainMessage h1{`

`font-size: 72px;`

`}`

`span.error{`

`color:red;`

`display:none;`

`}`

`div#actionContent>div{`

`border: 1px solid black;`

`float:left;`

`}`

`div#actionContent div.loggedIn div{`

`height: 220px;`

`}`

`div#actionContent div.loggedOut div{`

`height: 300px;`

`}`

`div#actionContent div div{`

`width: 200px;`

`float: left;`

`border-left: 1px solid black;`

`border-right: 1px solid black;`

`}`

`div#actionContent div div span{`

`padding: 4px;`

`}`

`div#actionContent div div input{`

`display: block;`

`margin-left: 4px;`

`margin-top: 4px;`

`}`

`div#actionContent div div button{`

`display: block;`

`margin-left: 4px;`

`margin-top: 4px;`

`}`

`span.sectionTitle{`

`font-size:larger;`

`}`

为了让我们的客户端正常工作，需要准备大量的 JavaScript 代码。即使是像主页这样简单的页面，也会有很多帮助函数、JavaScript 事件和 Ajax 调用。

主页 JavaScript 在列出 10-100 时有三个助手函数:`showAsLoggedIn`、`showAsLoggedOut`和`openCanvas`。前两种方法改变`.css`以显示`loggedIn`或`loggedOut`视图。一旦从服务器返回了画布 ID，就调用第三个方法，以便可以加载画布页面。为了支持不允许弹出窗口的移动设备，我们将检查窗口的宽度和高度。如果两个度量都低于阈值，脚本将重定向页面；否则，它将为新画布打开一个新窗口。

列出 10-100。索引。JS 助手函数

`function showAsLoggedIn() {`

`$('div.loggedIn').show();`

`$('div.loggedOut').hide();`

`}`

`function showAsLoggedOut() {`

`$('div.loggedOut').show();`

`$('div.loggedIn').hide();`

`}`

`function openCanvas(id) {`

`var canvasURL = "/Content/Canvas.html?canvasId=" + id;`

`if (window.innerWidth <= 800 && window.innerHeight <= 600) {`

`window.location.href = canvasURL;`

`}`

`else {`

`window.open(canvasURL, "_blank");`

`}`

`}`

一旦我们确定页面被调用的`$(document).ready`处理程序完全加载，主页的其余 JavaScript 逻辑就发生了，这让我们知道绑定到事件是安全的。我们唯一感兴趣的事件是`click`事件，我们将为页面上的所有按钮添加一个处理程序。

页面上的按钮用于登录、创建帐户、创建画布和加入画布。每个按钮都增加了一个额外的`click`处理程序，用于在显示错误文本`.css`时重置它。除了在`ready`方法中绑定事件，我们还做了一个 Ajax 调用来确定用户是否登录，这发生在`ready`函数的末尾，可以在清单 10-106 的末尾看到。

我们要看的第一个绑定是清单 10-101 中的登录按钮。每当单击 login 按钮时，用户名和密码输入字段的值就会分别作为`UserName`和`Password`添加到 JSON 对象中。接下来，对服务器进行 Ajax 调用，尝试使用 JSON 对象的值登录。如果 Ajax 调用成功并返回“`success`”，则显示登录状态。如果呼叫成功且没有“`success`”或呼叫失败，将显示注销页面。

清单 10-101。登录按钮逻辑

`$('#btnLogin').click(function () {`

`var dataObject = { "UserName": $('form#loginForm input#username').val(), "Password": $('form#loginForm input#password').val() };`

`$.ajax({`

`url: '/public/api/login',`

`type: 'post',`

`contentType: "application/json",`

`data: JSON.stringify(dataObject),`

`success: function (data, status) {`

`if (status == "success" && data == "Success") {`

`showAsLoggedIn();`

`}`

`else {`

`$('span#loginError').show();`

`}`

`},`

`error: function (data) {`

`$('span#loginError').show();`

`showAsLoggedOut();`

`}`

`});`

`});`

下一个绑定是清单 10-102 中的创建帐户按钮。每当单击该按钮时，都会比较密码和密码验证输入字段的值。如果它们不相等，并且显示一条错误消息，则事件结束。如果它们相等，用户名和密码输入字段将分别作为`UserName`和`Password`添加到 JSON 对象中。接下来，向服务器发出一个 Ajax 调用，用 JSON 对象的值创建一个帐户。如果 Ajax 调用成功并返回“`success`”，则帐户创建成功并显示登录状态。如果呼叫成功且没有“`success`”或呼叫失败，将显示带有错误消息的注销页面。

清单 10-102。创建帐户按钮逻辑

`$('#btnCreateAccount').click(function () {`

`$('span#passwordNotEqual').hide();`

`if ($('div#createAccount input#password').val() != $('div#createAccount input#verifyPassword').val())`

`{`

`$('span#passwordNotEqual').show();`

`return;`

`}`

`var dataObject = {`

`"UserName": $('div#createAccount input#username').val(),`

`"Password": $('div#createAccount input#password').val()`

`};`

`$.ajax({`

`url: '/public/api/user',`

`type: 'post',`

`contentType: "application/json",`

`data: JSON.stringify(dataObject),`

`success: function (data, status) {`

`if (status == "success" && data == "Success") {`

`showAsLoggedIn();`

`}`

`else`

`{`

`$('span#createAccountError').show();`

`}`

`},`

`error: function (data) {`

`showAsLoggedOut();`

`$('span#createAccountError').show();`

`}`

`});`

`});`

现在来看看清单 10-103 中的创建画布按钮绑定。每当单击按钮时，canvas name 和 canvas description 输入字段分别作为`Name`和`Description`添加到 JSON 对象中。接下来，向服务器发出一个 Ajax 调用，用 JSON 对象的值创建一个画布。如果 Ajax 调用成功并返回“`success`”，画布创建成功，调用`openCanvas`函数打开画布房间页面。如果呼叫成功且没有“`success`”或呼叫失败，则显示错误消息。

清单 10-103。创建画布按钮逻辑

`$('#btnCreateCanvas').click(function () {`

`var dataObject = {`

`"Name": $('div#createCanvasContainer input#canvasname').val(),`

`"Description": $('div#createCanvasContainer input#canvasdescription').val()`

`};`

`$.ajax({`

`url: '/api/canvas',`

`type: 'post',`

`contentType: "application/json",`

`data: JSON.stringify(dataObject),`

`dataType: "Json",`

`success: function (data, status) {`

`if (status == "success" && data != undefined) {`

`openCanvas(data)`

`}`

`else {`

`$('span#createCanvasError').show();`

`}`

`},`

`error: function (data) {`

`$('span#createCanvasError').show();`

`}`

`});`

`});`

接下来是清单 10-104 中的连接画布按钮绑定。每当单击按钮时，画布名称输入字段就会作为`Name`添加到 JSON 对象中。然后向服务器发出一个 Ajax 调用，用 JSON 对象的值连接画布。如果 Ajax 调用成功并返回`"success"`，则加入画布成功，并调用`openCanvas`函数打开画布房间页面。如果呼叫成功且没有`"success"`或呼叫失败，则显示错误消息。

清单 10-104。连接画布按钮逻辑

`$('#btnJoinCanvas').click(function () {`

`var dataObject = {`

`"Name": $('div#joinCanvasContainer input#canvasname').val()`

`};`

`$.ajax({`

`url: '/api/canvas',`

`type: 'put',`

`contentType: "application/json",`

`data: JSON.stringify(dataObject),`

`dataType: "Json",`

`success: function (data, status) {`

`if (status == "success" && data != undefined) {`

`openCanvas(data)`

`}`

`else {`

`$('span#joinCanvasError').show();`

`}`

`},`

`error: function (data) {`

`$('span#joinCanvasError').show();`

`}`

`});`

`});`

主页上的最后一个按钮绑定是清单 10-105 中的注销按钮。每当单击该按钮时，就会向服务器发出一个 Ajax 调用来注销。如果 Ajax 调用成功，就会显示注销页面。否则，如果呼叫不成功，则没有反馈。

清单 10-105。注销按钮逻辑

`$('#btnLogout').click(function () {`

`$.ajax({`

`url: '/public/api/logout',`

`type: 'post',`

`success: function (data) {`

`showAsLoggedOut();`

`}`

`});`

`});`

清单 10-106。完整索引。JS 文件

`function showAsLoggedIn() {`

`$('div.loggedIn').show();`

`$('div.loggedOut').hide();`

`}`

`function showAsLoggedOut() {`

`$('div.loggedOut').show();`

`$('div.loggedIn').hide();`

`}`

`function openCanvas(id) {`

`var canvasURL = "/Content/Canvas.html?canvasId=" + id;`

`if (window.innerWidth <= 800 && window.innerHeight <= 600) {`

`window.location.href = canvasURL;`

`}`

`else {`

`window.open(canvasURL, "_blank");`

`}`

`}`

`$(document).ready(function () {`

`$('div#mainContent button').bind('click', function () { $('span.error').hide();})`

`$('#btnLogin').click(function () {`

`var dataObject = { "UserName": $('form#loginForm input#username').val(), "Password": $('form#loginForm input#password').val() };`

`$.ajax({`

`url: '/public/api/login',`

`type: 'post',`

`contentType: "application/json",`

`data: JSON.stringify(dataObject),`

`success: function (data, status) {`

`if (status == "success" && data == "Success") {`

`showAsLoggedIn();`

`}`

`else {`

`$('span#loginError').show();`

`}`

`},`

`error: function (data) {`

`$('span#loginError').show();`

`showAsLoggedOut();`

`}`

`});`

`});`

`$('#btnCreateAccount').click(function () {`

`$('span#passwordNotEqual').hide();`

`if ($('div#createAccount input#password').val() != $('div#createAccount input#verifyPassword').val())`

`{`

`$('span#passwordNotEqual').show();`

`return;`

`}`

`var dataObject = {`

`"UserName": $('div#createAccount input#username').val(),`

`"Password": $('div#createAccount input#password').val()`

`};`

`$.ajax({`

`url: '/public/api/user',`

`type: 'post',`

`contentType: "application/json",`

`data: JSON.stringify(dataObject),`

`success: function (data, status) {`

`if (status == "success" && data == "Success") {`

`showAsLoggedIn();`

`}`

`else`

`{`

`$('span#createAccountError').show();`

`}`

`},`

`error: function (data) {`

`showAsLoggedOut();`

`$('span#createAccountError').show();`

`}`

`});`

`});`

`$('#btnCreateCanvas').click(function () {`

`var dataObject = {`

`"Name": $('div#createCanvasContainer input#canvasname').val(),`

`"Description": $('div#createCanvasContainer input#canvasdescription').val()`

`};`

`$.ajax({`

`url: '/api/canvas',`

`type: 'post',`

`contentType: "application/json",`

`data: JSON.stringify(dataObject),`

`dataType: "Json",`

`success: function (data, status) {`

`if (status == "success" && data != undefined) {`

`openCanvas(data)`

`}`

`else {`

`$('span#createCanvasError').show();`

`}`

`},`

`error: function (data) {`

`$('span#createCanvasError').show();`

`}`

`});`

`});`

`$('#btnJoinCanvas').click(function () {`

`var dataObject = {`

`"Name": $('div#joinCanvasContainer input#canvasname').val()`

`};`

`$.ajax({`

`url: '/api/canvas',`

`type: 'put',`

`contentType: "application/json",`

`data: JSON.stringify(dataObject),`

`dataType: "Json",`

`success: function (data, status) {`

`if (status == "success" && data != undefined) {`

`openCanvas(data)`

`}`

`else {`

`$('span#joinCanvasError').show();`

`}`

`},`

`error: function (data) {`

`$('span#joinCanvasError').show();`

`}`

`});`

`});`

`$('#btnLogout').click(function () {`

`$.ajax({`

`url: '/public/api/logout',`

`type: 'post',`

`success: function (data) {`

`showAsLoggedOut();`

`}`

`});`

`});`

`$.ajax({`

`url: '/public/api/loginStatus',`

`type: 'get',`

`success: function (data,status,x) {`

`if (status == "success" && data == "loggedIn") {`

`showAsLoggedIn();`

`}`

`else {`

`showAsLoggedOut();`

`}`

`},`

`error: function (data) {`

`$('div.loggedOut').show();`

`},`

`complete: function () {`

`$('#loadingMessage').hide();`

`}`

`});`

`});`

现在我们已经了解了主页部分，让我们按照以下步骤将文件添加到我们的项目中:

Create an HTML page named `index.html` with the content of Listing 10-98 in the `Content` folder under the `Public` folder.   Update the version numbers for the scripts to be the same as the version in the Scripts folder.   Update the `Copy To Output Directory` property to `Copy Always`.   Create a `.css` page named `index.css` with the content of Listing 10-99 in the `Styles` folder under the `Public` folder.   Update the `Copy To Output Directory` property to `Copy Always`.   Create a JavaScript page named `index.js` with the content of Listing 10-106 in the `Scripts` folder under the `Public` folder.   Update the `Copy To Output Directory` property to `Copy Always`.  

接下来，我们将创建画布室，在其中进行实时绘图和聊天。

### 开发客户画布室

画布房间的 HTML 基本上只是用于演示目的的结构。图 [10-16](#Fig16) 显示房间里 HTML 不多。

![A978-1-4302-6320-3_10_Fig16_HTML.jpg](A978-1-4302-6320-3_10_Fig16_HTML.jpg)

图 10-16。

Canvas page

然而，在 HTML 中有一些东西需要指出:堆叠的画布、状态消息以及画笔和颜色的数据属性。清单 10-107 显示了三个相同大小和位置的画布，它们有不同的`z-index` es。我们以这种方式堆叠画布，以便我们可以临时绘制这些画布并擦除那里的内容，而不必担心重新绘制之前画布上的内容。在清单 10-107 的 HTML 底部要看的另一件事是我们根据连接状态显示的状态消息。JavaScript 使用画笔和颜色的数据属性来确定使用什么画笔以及画笔应该是什么颜色。

清单 10-107。Canvas.html

`<!DOCTYPE html>`

`<html xmlns="`[`http://www.w3.org/1999/xhtml`](http://www.w3.org/1999/xhtml)T2】

`<head>`

`<title>GroupBrush</title>`

`<link rel="stylesheet" type="text/css" href="/styles/Canvas.css" />`

`<script src="/public/scripts/jquery-1.6.4.min.js"></script>`

`<script src="/public/scripts/jquery.signalr-2.0.3.min.js"></script>`

`<script src="/signalr/hubs"></script>`

`<script src="/scripts/canvas.js"></script>`

`</head>`

`<body>`

`<div id="canvasContent" class="connectionContent">`

`<div id="mainContent">`

`<div id="canvasContainer">`

`<div style="position:relative; width: 600px;height: 400px;">`

`<canvas width="600" height="400" id="scratchCanvas" style="position:absolute; z-index: 3;"></canvas>`

`<canvas width="600" height="400" id="drawingCanvas" style="position:absolute; z-index: 2;"></canvas>`

`<canvas width="600" height="400" id="cursorCanvas" style="position: absolute; z-index: 1;"></canvas>`

`</div>`

`</div>`

`<div id="toolboxContainer">`

`<div class="brushes">`

`<div class="brush tool selected" data-brushtype="1">Brush</div>`

`<div class="brush tool" data-brushtype="2">Eraser</div>`

`<div class="brush tool" data-brushtype="3">Fill</div>`

`<div class="brush tool" data-brushtype="4">Clear All</div>`

`</div>`

`<div class="colors">`

`<div class="color tool selected" data-colorvalue="#FF0000" id="Red">&nbsp;</div>`

`<div class="color tool" data-colorvalue="#FFA500" id="Orange">&nbsp;</div>`

`<div class="color tool" data-colorvalue="#FFFF00" id="Yellow">&nbsp;</div>`

`<div class="color tool" data-colorvalue="#00FF00" id="Green">&nbsp;</div>`

`<div class="color tool" data-colorvalue="#0000FF" id="Blue">&nbsp;</div>`

`<div class="color tool" data-colorvalue="#800080" id="Purple">&nbsp;</div>`

`<div class="color tool" data-colorvalue="#A52A2A" id="Brown">&nbsp;</div>`

`<div class="color tool" data-colorvalue="#000000" id="Black">&nbsp;</div>`

`</div>`

`<div class="sizeContainer">`

`<span>Size:</span>`

`<select id="sizes">`

`<option value="1">1</option>`

`<option value="2">2</option>`

`<option value="4">4</option>`

`<option value="8">8</option>`

`<option value="16">16</option>`

`<option value="32">32</option>`

`<option value="64">64</option>`

`<option value="128">128</option>`

`</select>`

`</div>`

`</div>`

`</div>`

`<div id="sideContent">`

`<h1 id="CanvasName"></h1>`

`<span id="CanvasDescription"></span>`

`<div id="onlineUsersContainer">`

`<span>Users Online:</span>`

`<ul id="userList"></ul>`

`</div>`

`<div id="chatContainer">`

`<span>Chat Messages:</span>`

`<div id="chatMessagesContainer">`

`<ul id="chatMessages"></ul>`

`</div>`

`<div id="chatInputContainer">`

`<input type="text" id="chatInput" />`

`<button id="btnSendMessage">Send</button>`

`</div>`

`</div>`

`</div>`

`</div>`

`<div id="loadingCanvasContent" class="connectionContent">`

`<span>Connecting...</span>`

`</div>`

`<div id="syncingCanvasContent" class="connectionContent">`

`<span>Syncing...</span>`

`</div>`

`<div id="reloadCanvasContent" class="connectionContent">`

`<span>Connection problems </span>`

`<button id="btnReload">Reload</button>`

`</div>`

`</body>`

`</html>`

再次强调，这个项目的`.css`非常基础，除了设置页面的流程和容器、画笔颜色和状态消息显示，清单 10-108 中没有太多内容。

清单 10-108。Canvas.css

`div#mainContent{`

`float: left;`

`width: 600px;`

`height: 600px;`

`border: solid 2px black;`

`}`

`div#sideContent{`

`float: left;`

`width: 300px;`

`height: 600px;`

`}`

`div#canvasContainer{`

`border-bottom: 1px solid black;`

`}`

`div#toolboxContainer{`

`width: 600px;`

`height: 100px;`

`margin-top: 20px;`

`}`

`div#toolboxContainer{`

`width: 600px;`

`height: 100px;`

`}`

`div#toolboxContainer div.brushes {`

`width: 110px;`

`float: left;`

`}`

`div#toolboxContainer div.colors {`

`width: 430px;`

`float: left;`

`}`

`div#toolboxContainer div.colors div#Red {`

`background-color: #FF0000;`

`}`

`div#toolboxContainer div.colors div#Orange {`

`background-color: #FFA500;`

`}`

`div#toolboxContainer div.colors div#Yellow {`

`background-color: #FFFF00;`

`}`

`div#toolboxContainer div.colors div#Green {`

`background-color: #00FF00;`

`}`

`div#toolboxContainer div.colors div#Blue {`

`background-color: #0000FF;`

`}`

`div#toolboxContainer div.colors div#Purple {`

`background-color: #800080;`

`}`

`div#toolboxContainer div.colors div#Brown {`

`background-color: #A52A2A;`

`}`

`div#toolboxContainer div.colors div#Black {`

`background-color: #000000;`

`}`

`div#toolboxContainer div.actions {`

`width: 50px;`

`float: left;`

`}`

`div#toolboxContainer div.tool {`

`width: 50px;`

`height: 50px;`

`float: left;`

`border: 1px solid black;`

`text-align: center;`

`}`

`div#toolboxContainer div.selected {`

`border: 5px solid #AAAAAA;`

`width: 42px;`

`height: 42px;`

`}`

`div#onlineUsersContainer{`

`border: 1px solid black;`

`margin: 0px 10px 10px 10px;`

`height: 200px;`

`}`

`div#chatContainer{`

`border: 1px solid black;`

`margin: 10px;`

`height: 290px;`

`position: relative;`

`}`

`div#chatInputContainer{`

`position:absolute;`

`bottom: 0px;`

`}`

`div#sideContent ul li {`

`list-style: none;`

`}`

`div#sideContent span{`

`margin-left: 4px;`

`}`

`div#sideContent input{`

`margin-left: 4px;`

`width: 210px;`

`}`

`div#canvasContent{`

`display:none;`

`}`

`div#syncingCanvasContent{`

`display:none;`

`}`

`div#reloadCanvasContent{`

`display:none;`

`}`

`body{`

`touch-action:none;`

`}`

`canvas#scratchCanvas{`

`-ms-user-select:none;`

`}`

客户端的代码非常复杂，所以我们将把它分解成更小的相关函数。与 HTML 一样，JavaScript 仅用于示例目的，可能没有使用最佳实践。

清单 10-109 显示了画布房间的变量。第一个变量`hubProxy`用于将代理存储到 SignalR hub。下一个变量`userList`是一个数组，用于存储用户列表中显示的用户。`lastCursorPositionTime`变量标记当前用户的光标最后一次被发送到服务器的时间。`lastDrawTime`变量是最后一次将抽签位置发送到服务器。`lastSequence`变量存储最新收到的绘制序列。`isBrushown`和`firstTouch`变量跟踪拖动事件是否正在发生。`brushPositions`数组存储需要发送给服务器的位置。`otherBrushCursors`数组存储其他 canvas room 用户光标的用户名、位置和上次更新时间。`isDrawingContinued`变量用于让`Canvas`对象知道它是否需要在绘制之前移动位置上下文。最后，`cleanUpCursorCanvasTimer`变量存储了`setTimeout`句柄，这样它就可以被取消。

清单 10-109。Canvas.js 变量

`var hubProxy = null;`

`var userList = [];`

`var lastCursorPositionTime = 0;`

`var lastDrawTime = 0;`

`var lastSequence = 0;`

`var isBrushDown = false;`

`var firstTouch = null;`

`var brushPositions = [];`

`var otherBrushCursors = [];`

`var isDrawingContinued = false;`

`var cleanUpCursorCanvasTimer = null;`

除了画布空间的变量，还有可以在脚本中传递的“对象”。清单 10-110 中显示的第一个对象是`Position`对象，它存储一个位置的`x`和`y`坐标。下一个对象`OtherBrush`，存储画笔(光标)名称、位置和上次更新时间。最后一个对象`CurrentBrushData`，从 HTML DOM 中检索当前选择的颜色、大小和类型，并作为“对象”返回，可以发送给服务器。

清单 10-110。Canvas.js 对象

`function Position(x, y) {`

`this.x = x;`

`this.y = y;`

`}`

`function OtherBrush(userName, x, y) {`

`this.UserName = userName;`

`this.x = x;`

`this.y = y;`

`this.updateTime = Date.now();`

`}`

`function CurrentBrushData() {`

`this.Color = $('div.color.tool.selected').data('colorvalue') || 1;`

`this.Size = $('select#sizes').val() || 1;`

`this.Type = $('div.brush.tool.selected').data('brushtype') || 1;`

`}`

下一组类似的逻辑是清单 10-111 所示的助手方法。`getCanvasId`方法通过查找查询字符串关键字`'canvasId'`来查看查询字符串以找到画布 ID。如果在查询字符串中找不到画布 ID，该函数会将页面重定向回站点根目录。

清单 10-111。Canvas.js 助手方法

`function getCanvasId() {`

`var canvasId = null;`

`var queryString = window.location.search.substring(1);`

`var queryStringArray = queryString.split('&');`

`for (var x = 0; x < queryStringArray.length; x++) {`

`var keyValue = queryStringArray[x].split('=');`

`if (keyValue.length > 1) {`

`var queryKey = keyValue[0];`

`var queryValue = keyValue[1];`

`if (queryKey == 'canvasId') {`

`canvasId = queryStringArray[x];`

`}`

`}`

`}`

`if (canvasId == undefined || canvasId.length != 45) {`

`window.location('/');`

`}`

`return canvasId;`

`}`

`function connectionChange(contentToShow) {`

`$('div.connectionContent').hide();`

`if (contentToShow != undefined)`

`$(contentToShow).show();`

`}`

`$(document).ready(function () {`

`$('div.color.tool').click(function () {`

`$('div.color.tool').removeClass('selected');`

`$(this).addClass('selected');`

`});`

`$('div.brush.tool').click(function () {`

`$('div.brush.tool').removeClass('selected');`

`$(this).addClass('selected');`

`});`

`$('div#reloadCanvasContent button#btnReload').click(function () {`

`connect();`

`});`

`connect();`

`});`

每当画布房间的查看状态需要改变时，就会使用`connectionChange`辅助方法。它隐藏了类名为`'connectionContent'`的所有主要内容`div`部分。如果可以找到传入的`.css`选择器的内容，就显示该内容。

最后一个 helper 方法是 JQuery 在文档满载时提供的`ready`函数。我们使用这个辅助函数为颜色和画笔`div`容器添加一个点击绑定，它将改变所选的颜色或画笔。helper 还为 reload 按钮添加了一个 click 绑定，该按钮在连接无法连接时显示。最后，这个函数调用连接 SignalR hub 的`connect`方法(接下来讨论)。

`connect`方法是画布房间脚本中最重要的方法之一(见清单 10-112)。该方法负责连接到 SignalR hub 并绑定其所有事件。如果 hub 连接成功，这个方法为画布绑定`mouse`和`touch`事件，并将画布同步到服务器上的最新版本。

清单 10-112。连接方法

`function connect() {`

`connectionChange('div#loadingCanvasContent');`

`var canvasId = getCanvasId();`

`var connection = $.hubConnection('/signalr', { qs: canvasId });`

`hubProxy = connection.createHubProxy('CanvasHub');`

`hubProxy.on('MoveOtherCursor', function (userName, x, y) {`

`drawOtherBrush(userName, x, y)`

`});`

`hubProxy.on('UserChatMessage', function (message) {`

`$('#chatMessages').append('<li>' + message + '</li>')`

`});`

`hubProxy.on('UserConnected', function (userName) {`

`userConnected(userName);`

`});`

`hubProxy.on('UserDisconnected', function (userName) {`

`userDisconnected(userName);`

`});`

`hubProxy.on('DrawCanvasBrushAction', function (canvasBrushAction) {`

`drawCanvasBrushAction(canvasBrushAction);`

`});`

`connection.reconnecting(function () {`

`connectionChange('div#loadingCanvasContent');`

`});`

`connection.reconnected(function () {`

`syncRoom();`

`});`

`connection.disconnected(function () {`

`connectionChange('div#reloadCanvasContent');`

`});`

`connection.start().done(function () {`

`$('#btnSendMessage').click(function () {`

`hubProxy.invoke('SendChatMessage', $('#chatInput').val()).done(function(){$('#chatInput').val('');});`

`});`

`var canvasTouch = document.getElementById('scratchCanvas');`

`canvasTouch.addEventListener('touchstart', touchStart, false);`

`canvasTouch.addEventListener('touchmove', touchMove, false);`

`canvasTouch.addEventListener('touchend', touchEnd, false);`

`canvasTouch.addEventListener('touchleave', touchEnd, false);`

`canvasTouch.addEventListener('touchcancel', touchEnd, false);`

`if (window.navigator.msPointerEnabled) {`

`canvasTouch.addEventListener('MSPointerDown', msTouchStart, false);`

`canvasTouch.addEventListener('MSPointerMove', msTouchMove, false);`

`canvasTouch.addEventListener('MSPointerUp', msTouchEnd, false);`

`}`

`else`

`{`

`var canvas = $('#scratchCanvas');`

`canvas.bind('mousemove', mouseMove);`

`canvas.bind('mousedown', mouseDown);`

`canvas.bind('mouseup', mouseUp);`

`}`

`syncRoom();`

`});`

`}`

对于我们的应用程序，有两种基于其他用户事件的绘制:绘制其他用户的光标和绘制他们的画笔动作。

当服务器调用`drawOtherBrush`方法时，绘制其他用户的光标。该方法基于用户名将画笔(光标)位置存储在一个数组中。该事件然后调用`drawAllBrushes`方法，该方法取消任何挂起的清理计时器。

该方法清除在其上绘制光标的画布，然后遍历用户光标的数组，绘制上一秒钟内更新的任何内容。如果绘制了任何光标，该方法将创建一个计时器，该计时器将在半秒钟内触发以调用`drawAllBrushes`方法来重复该过程。

第二个事件是绘制其他用户的画笔动作(见清单 10-133)。这个事件也是由服务器在调用`drawCanvasBrushAction`方法时触发的，该方法存储最新的绘制顺序并绘制传入的`canvasBrushAction`。如果`canvasBrushAction`类型是`1`或`2`，它分别在定义的位置绘图或擦除。如果`canvasBrushAction`类型为`3`或`4`，则分别填充或清除整个画布。

清单 10-113。绘制其他画笔方法

`function drawOtherBrush(userName, x, y) {`

`otherBrushCursors[userName] = new OtherBrush(userName, x, y);`

`drawAllBrushes();`

`}`

`function drawAllBrushes()`

`{`

`if (cleanUpCursorCanvasTimer != null) clearTimeout(cleanUpCursorCanvasTimer);`

`var dirtyCanvas = false;`

`var c = document.getElementById("cursorCanvas");`

`var ctx = c.getContext("2d");`

`ctx.fillStyle = "#000000";`

`ctx.clearRect(0, 0, 600, 400);`

`for (var key in otherBrushCursors) {`

`var currentBrush = otherBrushCursors[key];`

`if (Date.now() - currentBrush.updateTime < 1000) {`

`dirtyCanvas = true;`

`ctx.fillRect(currentBrush.x - 5, currentBrush.y - 5, 10, 10);`

`ctx.fillText(currentBrush.UserName, currentBrush.x + 10, currentBrush.y);`

`}`

`}`

`if(dirtyCanvas) cleanUpCursorCanvasTimer = setTimeout(function () { drawAllBrushes(); }, 500);`

`}`

`function drawCanvasBrushAction(canvasBrushAction) {`

`var c = document.getElementById('drawingCanvas');`

`var ctx = c.getContext("2d");`

`ctx.beginPath();`

`lastSequence = canvasBrushAction.Sequence;`

`if (canvasBrushAction.Type == 1 || canvasBrushAction.Type == 2) {`

`var brushActionSize = canvasBrushAction.Size;`

`ctx.strokeStyle = canvasBrushAction.Color;`

`ctx.lineWidth = brushActionSize;`

`if (canvasBrushAction.BrushPositions.length > 0) {`

`ctx.moveTo(canvasBrushAction.BrushPositions[0].X, canvasBrushAction.BrushPositions[0].Y);`

`}`

`for (var x = 0; x < canvasBrushAction.BrushPositions.length; x++) {`

`var position = canvasBrushAction.BrushPositions[x];`

`ctx.lineTo(position.X, position.Y);`

`if (canvasBrushAction.Type == 1)`

`ctx.stroke();`

`else if(canvasBrushAction.Type == 2)`

`ctx.clearRect(position.X, position.Y, brushActionSize, brushActionSize)`

`}`

`}`

`else if (canvasBrushAction.Type == 3) {`

`ctx.fillStyle = canvasBrushAction.Color;`

`ctx.fillRect(0, 0, 600, 400);`

`}`

`else if (canvasBrushAction.Type == 4) {`

`ctx.clearRect(0, 0, 600, 400);`

`}`

`ctx.closePath();`

`}`

清单 10-114 中的`userConnected`和`userDisconnected`方法在用户连接或断开时从 SignalR hub 调用。出现这种情况时，用户将被添加到内存中的用户列表中，或者从该列表中删除。然后用`drawUserList`方法重新绘制这个用户列表。

清单 10-114。用户连接方法

`function userConnected(userName) {`

`var alreadyExists = false;`

`for (var x = 0; x < userList.length; x++) {`

`if (userList[x] == userName) {`

`alreadyExists = true;`

`break;`

`}`

`}`

`if(!alreadyExists)   userList.push(userName);`

`drawUserList();`

`}`

`function userDisconnected(userName) {`

`for (var x = userList.length - 1; x > -1; x--) {`

`if (userList[x] == userName) {`

`userList.splice(x, 1);`

`}`

`}`

`drawUserList();`

`}`

`function drawUserList() {`

`var userListHTML = [];`

`for (var x = 0; x < userList.length; x++) {`

`userListHTML.push('<li>');`

`userListHTML.push(userList[x]);`

`userListHTML.push('</li>');`

`}`

`$('#userList').html(userListHTML.join(''));`

`}`

对于画布室来说，一个至关重要的功能就是能够绘画。清单 10-115 中显示的绘图方法处理通用输入、绘图日志和画布对象的实际绘图。

清单 10-115。绘图方法

`function canvasBrushMove(position) {`

`if (isBrushDown) {`

`storeDrawCoordinates(position);`

`}`

`if (Date.now() - lastCursorPositionTime > 100) {`

`lastCursorPositionTime = Date.now()`

`hubProxy.invoke('MoveCursor', position.x, position.y);`

`}`

`}`

`function canvasBrushDown(position) {`

`isBrushDown = true;`

`storeDrawCoordinates(position);`

`return true;`

`}`

`function canvasBrushUp(position) {`

`isBrushDown = false;`

`storeDrawCoordinates(position);`

`sendBrushData(brushPositions);`

`brushPositions = [];`

`isDrawingContinued = false;`

`var c = document.getElementById("scratchCanvas");`

`var ctx = c.getContext("2d");`

`ctx.closePath();`

`ctx.clearRect(0, 0, 600, 400);`

`}`

`function sendBrushData(brushPositionsData)`

`{`

`var currentBrushData = new CurrentBrushData();`

`var brushData = {`

`BrushPositions: brushPositionsData,`

`ClientSequenceId: Date.now(),`

`Color: currentBrushData.Color,`

`Size: currentBrushData.Size,`

`Type: currentBrushData.Type`

`}`

`hubProxy.invoke('SendDrawCommand', brushData).fail(function (error) {`

`});`

`}`

`function storeDrawCoordinates(position) {`

`var c = document.getElementById("scratchCanvas");`

`var ctx = c.getContext("2d");`

`var allowChange = false;`

`if (brushPositions.length > 0)`

`{`

`var lastPosition = brushPositions[brushPositions.length - 1];`

`if (Math.abs(lastPosition.x - position.x) >= 1 || Math.abs(lastPosition.y - position.y) >= 1) allowChange = true;`

`}`

`else {`

`allowChange = true;`

`}`

`if (!isDrawingContinued) {`

`ctx.beginPath();`

`isDrawingContinued = true;`

`ctx.moveTo(position.x, position.y);`

`}`

`var currentBrushData = new CurrentBrushData();`

`ctx.strokeStyle = currentBrushData.Color;`

`ctx.lineWidth = currentBrushData.Size;`

`ctx.lineTo(position.x, position.y);`

`ctx.stroke();`

`brushPositions.push(position);`

`if (Date.now() - lastDrawTime > 50) {`

`lastDrawTime = Date.now();`

`var tempPositions = brushPositions.splice(0);`

`brushPositions.push(position);`

`sendBrushData(tempPositions);`

`}`

为了进行绘制，我们需要在画笔被放下、移动或提起时处理输入。当画笔被放下时，它会触发`canvasBrushDown`方法。我们设置了一个发生拖动的变量，并存储画笔的位置。

移动画笔时触发下一个输入，调用`canvasBrushMove`方法。如果画笔是拖动的一部分，坐标将被存储。如果自上次发送到服务器的刷子位置以来的时间超过 50 毫秒，则未发送的刷子位置被发送到服务器。

最后一个输入是当画笔被提起时，它触发了`canvasBrushUp`方法。此方法停止拖动，存储画笔的位置，将画笔数据发送到服务器，清除画笔位置数组，并清除记录画笔位置的画布表面。

在各种输入方法中，画笔位置由`storeDrawCoordinates`方法存储。在这个方法中，画笔的位置被绘制到画布上。然后画笔位置存储在一个数组中。有时，这些位置会从数组中清除，并使用`sendBrushData`方法发送到服务器。

`sendBrushData`方法是获取当前画笔大小、颜色和类型的方法。它将它们与传入的画笔位置和数字格式的当前时间结合起来。然后，它获取这些数据，并通过调用`SendDrawCommand`服务器端方法将其发送到 hub。

因为应用程序的运行非常依赖于输入方法，所以我们同时支持鼠标和触摸运动。如前所示，有向下、移动和向上画笔的通用方法。清单 10-116 显示了鼠标的三种方法，微软浏览器的触摸方法，非微软浏览器的触摸方法。

清单 10-116。用户输入捕获方法

`function getDrawPosition(e) {`

`var canvasRect = document.getElementById('scratchCanvas').getBoundingClientRect();`

`var xPos = e.clientX - canvasRect.left;`

`var yPos = e.clientY - canvasRect.top;`

`return new Position(xPos, yPos);`

`}`

`function mouseMove(e) {`

`canvasBrushMove(getDrawPosition(e));`

`}`

`function mouseDown(e) {`

`canvasBrushDown(getDrawPosition(e));`

`}`

`function mouseUp(e) {`

`canvasBrushUp(getDrawPosition(e));`

`}`

`function msTouchStart(e) {`

`e.preventDefault();`

`if (firstTouch == null && e.buttons == 1) {`

`firstTouch = e.pointerId;`

`canvasBrushDown(new Position(e.clientX, e.clientY));`

`}`

`}`

`function msTouchMove(e) {`

`e.preventDefault();`

`if (firstTouch == e.pointerId) {`

`canvasBrushMove(new Position(e.clientX, e.clientY));`

`}`

`}`

`function msTouchEnd(e) {`

`e.preventDefault();`

`if(e.buttons == 0 && firstTouch == e.pointerId){`

`canvasBrushUp(new Position(e.clientX, e.clientY));`

`firstTouch = null;`

`}`

`}`

`function touchStart(e) {`

`e.preventDefault();`

`if (firstTouch == null && e.changedTouches.length > 0) {`

`var touchData = e.changedTouches[0];`

`firstTouch = touchData.identifier;`

`canvasBrushDown(new Position(touchData.pageX, touchData.pageY));`

`}`

`}`

`function touchMove(e) {`

`e.preventDefault();`

`for (var t = 0; t < e.changedTouches.length; t++) {`

`if (e.changedTouches[t].identifier == firstTouch) {`

`var touchData = e.changedTouches[t];`

`canvasBrushMove(new Position(touchData.pageX, touchData.pageY));`

`}`

`}`

`}`

`function touchEnd(e) {`

`e.preventDefault();`

`for (var t = 0; t < e.changedTouches.length; t++) {`

`if (e.changedTouches[t].identifier == firstTouch) {`

`firstTouch = null;`

`var touchData = e.changedTouches[t];`

`canvasBrushUp(new Position(touchData.pageX, touchData.pageY));`

`}`

`}`

`}`

这些方法非常简单明了，但是请注意，鼠标方法确定相对于画布的位置，而触摸方法设置为一次处理一个触摸指针。

每当画布第一次连接或重新连接时，代码调用`syncRoom`函数将画布同步到服务器上的最新内容。它可以通过调用`SyncToRoom`服务器端 hub 方法与最近已知的 canvas 序列同步(见清单 10-117)。如果该方法成功返回，它将更新用户列表并完成所有画笔操作。如果该方法失败，它会将页面状态更改为重新加载内容。

清单 10-117。画布同步方法

`function syncRoom() {`

`connectionChange('div#syncingCanvasContent');`

`hubProxy.invoke('SyncToRoom', lastSequence).done(function (canvasSnapShot) {`

`userList = [];`

`$.each(canvasSnapShot.Users, function () {`

`userConnected(this);`

`});`

`$.each(canvasSnapShot.Actions, function () {`

`drawCanvasBrushAction(this);`

`});`

`$('h1#CanvasName').html(canvasSnapShot.CanvasName);`

`$('span#CanvasDescription').html(canvasSnapShot.CanvasDescription);`

`connectionChange('div#canvasContent');`

`}).fail(function () {`

`connectionChange('div#reloadCanvasContent');`

`});`

`}`

清单 10-118 给出了 Canvas.js 的完整代码

清单 10-118。完成 Canvas.js

`var hubProxy = null;`

`var userList = [];`

`var lastCursorPositionTime = 0;`

`var lastDrawTime = 0;`

`var lastSequence = 0;`

`var isBrushDown = false;`

`var firstTouch = null;`

`var brushPositions = [];`

`var otherBrushCursors = [];`

`var isDrawingContinued = false;`

`var cleanUpCursorCanvasTimer = null;`

`function Position(x, y) {`

`this.x = x;`

`this.y = y;`

`}`

`function OtherBrush(userName, x, y) {`

`this.UserName = userName;`

`this.x = x;`

`this.y = y;`

`this.updateTime = Date.now();`

`}`

`function CurrentBrushData() {`

`this.Color = $('div.color.tool.selected').data('colorvalue') || 1;`

`this.Size = $('select#sizes').val() || 1;`

`this.Type = $('div.brush.tool.selected').data('brushtype') || 1;`

`}`

`function getCanvasId() {`

`var canvasId = null;`

`var queryString = window.location.search.substring(1);`

`var queryStringArray = queryString.split('&');`

`for (var x = 0; x < queryStringArray.length; x++) {`

`var keyValue = queryStringArray[x].split('=');`

`if (keyValue.length > 1) {`

`var queryKey = keyValue[0];`

`var queryValue = keyValue[1];`

`if (queryKey == 'canvasId') {`

`canvasId = queryStringArray[x];`

`}`

`}`

`}`

`if (canvasId == undefined || canvasId.length != 45) {`

`window.location('/');`

`}`

`return canvasId;`

`}`

`function connectionChange(contentToShow) {`

`$('div.connectionContent').hide();`

`if (contentToShow != undefined)`

`$(contentToShow).show();`

`}`

`$(document).ready(function () {`

`$('div.color.tool').click(function () {`

`$('div.color.tool').removeClass('selected');`

`$(this).addClass('selected');`

`});`

`$('div.brush.tool').click(function () {`

`$('div.brush.tool').removeClass('selected');`

`$(this).addClass('selected');`

`});`

`$('div#reloadCanvasContent button#btnReload').click(function () {`

`connect();`

`});`

`connect();`

`});`

`function connect() {`

`connectionChange('div#loadingCanvasContent');`

`var canvasId = getCanvasId();`

`var connection = $.hubConnection('/signalr', { qs: canvasId });`

`hubProxy = connection.createHubProxy('CanvasHub');`

`hubProxy.on('MoveOtherCursor', function (userName, x, y) {`

`drawOtherBrush(userName, x, y)`

`});`

`hubProxy.on('UserChatMessage', function (message) {`

`$('#chatMessages').append('<li>' + message + '</li>')`

`});`

`hubProxy.on('UserConnected', function (userName) {`

`userConnected(userName);`

`});`

`hubProxy.on('UserDisconnected', function (userName) {`

`userDisconnected(userName);`

`});`

`hubProxy.on('DrawCanvasBrushAction', function (canvasBrushAction) {`

`drawCanvasBrushAction(canvasBrushAction);`

`});`

`connection.reconnecting(function () {`

`connectionChange('div#loadingCanvasContent');`

`});`

`connection.reconnected(function () {`

`syncRoom();`

`});`

`connection.disconnected(function () {`

`connectionChange('div#reloadCanvasContent');`

`});`

`connection.start().done(function () {`

`$('#btnSendMessage').click(function () {`

`hubProxy.invoke('SendChatMessage', $('#chatInput').val()).done(function(){$('#chatInput').val('');});`

`});`

`var canvasTouch = document.getElementById('scratchCanvas');`

`canvasTouch.addEventListener('touchstart', touchStart, false);`

`canvasTouch.addEventListener('touchmove', touchMove, false);`

`canvasTouch.addEventListener('touchend', touchEnd, false);`

`canvasTouch.addEventListener('touchleave', touchEnd, false);`

`canvasTouch.addEventListener('touchcancel', touchEnd, false);`

`if (window.navigator.msPointerEnabled) {`

`canvasTouch.addEventListener('MSPointerDown', msTouchStart, false);`

`canvasTouch.addEventListener('MSPointerMove', msTouchMove, false);`

`canvasTouch.addEventListener('MSPointerUp', msTouchEnd, false);`

`}`

`else`

`{`

`var canvas = $('#scratchCanvas');`

`canvas.bind('mousemove', mouseMove);`

`canvas.bind('mousedown', mouseDown);`

`canvas.bind('mouseup', mouseUp);`

`}`

`syncRoom();`

`});`

`}`

`function syncRoom() {`

`connectionChange('div#syncingCanvasContent');`

`hubProxy.invoke('SyncToRoom', lastSequence).done(function (canvasSnapShot) {`

`userList = [];`

`$.each(canvasSnapShot.Users, function () {`

`userConnected(this);`

`});`

`$.each(canvasSnapShot.Actions, function () {`

`drawCanvasBrushAction(this);`

`});`

`$('h1#CanvasName').html(canvasSnapShot.CanvasName);`

`$('span#CanvasDescription').html(canvasSnapShot.CanvasDescription);`

`connectionChange('div#canvasContent');`

`}).fail(function () {`

`connectionChange('div#reloadCanvasContent');`

`});`

`}`

`function drawOtherBrush(userName, x, y) {`

`otherBrushCursors[userName] = new OtherBrush(userName, x, y);`

`drawAllBrushes();`

`}`

`function drawAllBrushes()`

`{`

`if (cleanUpCursorCanvasTimer != null) clearTimeout(cleanUpCursorCanvasTimer);`

`var dirtyCanvas = false;`

`var c = document.getElementById("cursorCanvas");`

`var ctx = c.getContext("2d");`

`ctx.fillStyle = "#000000";`

`ctx.clearRect(0, 0, 600, 400);`

`for (var key in otherBrushCursors) {`

`var currentBrush = otherBrushCursors[key];`

`if (Date.now() - currentBrush.updateTime < 1000) {`

`dirtyCanvas = true;`

`ctx.fillRect(currentBrush.x - 5, currentBrush.y - 5, 10, 10);`

`ctx.fillText(currentBrush.UserName, currentBrush.x + 10, currentBrush.y);`

`}`

`}`

`if(dirtyCanvas) cleanUpCursorCanvasTimer = setTimeout(function () { drawAllBrushes(); }, 500);`

`}`

`function drawCanvasBrushAction(canvasBrushAction) {`

`var c = document.getElementById('drawingCanvas');`

`var ctx = c.getContext("2d");`

`ctx.beginPath();`

`lastSequence = canvasBrushAction.Sequence;`

`if (canvasBrushAction.Type == 1 || canvasBrushAction.Type == 2) {`

`var brushActionSize = canvasBrushAction.Size;`

`ctx.strokeStyle = canvasBrushAction.Color;`

`ctx.lineWidth = brushActionSize;`

`if (canvasBrushAction.BrushPositions.length > 0) {`

`ctx.moveTo(canvasBrushAction.BrushPositions[0].X, canvasBrushAction.BrushPositions[0].Y);`

`}`

`for (var x = 0; x < canvasBrushAction.BrushPositions.length; x++) {`

`var position = canvasBrushAction.BrushPositions[x];`

`ctx.lineTo(position.X, position.Y);`

`if (canvasBrushAction.Type == 1)`

`ctx.stroke();`

`else if(canvasBrushAction.Type == 2)`

`ctx.clearRect(position.X, position.Y, brushActionSize, brushActionSize)`

`}`

`}`

`else if (canvasBrushAction.Type == 3) {`

`ctx.fillStyle = canvasBrushAction.Color;`

`ctx.fillRect(0, 0, 600, 400);`

`}`

`else if (canvasBrushAction.Type == 4) {`

`ctx.clearRect(0, 0, 600, 400);`

`}`

`ctx.closePath();`

`}`

`function getDrawPosition(e) {`

`var canvasRect = document.getElementById('scratchCanvas').getBoundingClientRect();`

`var xPos = e.clientX - canvasRect.left;`

`var yPos = e.clientY - canvasRect.top;`

`return new Position(xPos, yPos);`

`}`

`function mouseMove(e) {`

`canvasBrushMove(getDrawPosition(e));`

`}`

`function mouseDown(e) {`

`canvasBrushDown(getDrawPosition(e));`

`}`

`function mouseUp(e) {`

`canvasBrushUp(getDrawPosition(e));`

`}`

`function msTouchStart(e) {`

`e.preventDefault();`

`if (firstTouch == null && e.buttons == 1) {`

`firstTouch = e.pointerId;`

`canvasBrushDown(new Position(e.clientX, e.clientY));`

`}`

`}`

`function msTouchMove(e) {`

`e.preventDefault();`

`if (firstTouch == e.pointerId) {`

`canvasBrushMove(new Position(e.clientX, e.clientY));`

`}`

`}`

`function msTouchEnd(e) {`

`e.preventDefault();`

`if(e.buttons == 0 && firstTouch == e.pointerId){`

`canvasBrushUp(new Position(e.clientX, e.clientY));`

`firstTouch = null;`

`}`

`}`

`function touchStart(e) {`

`e.preventDefault();`

`if (firstTouch == null && e.changedTouches.length > 0) {`

`var touchData = e.changedTouches[0];`

`firstTouch = touchData.identifier;`

`canvasBrushDown(new Position(touchData.pageX, touchData.pageY));`

`}`

`}`

`function touchMove(e) {`

`e.preventDefault();`

`for (var t = 0; t < e.changedTouches.length; t++) {`

`if (e.changedTouches[t].identifier == firstTouch) {`

`var touchData = e.changedTouches[t];`

`canvasBrushMove(new Position(touchData.pageX, touchData.pageY));`

`}`

`}`

`}`

`function touchEnd(e) {`

`e.preventDefault();`

`for (var t = 0; t < e.changedTouches.length; t++) {`

`if (e.changedTouches[t].identifier == firstTouch) {`

`firstTouch = null;`

`var touchData = e.changedTouches[t];`

`canvasBrushUp(new Position(touchData.pageX, touchData.pageY));`

`}`

`}`

`}`

`function canvasBrushMove(position) {`

`if (isBrushDown) {`

`storeDrawCoordinates(position);`

`}`

`if (Date.now() - lastCursorPositionTime > 100) {`

`lastCursorPositionTime = Date.now()`

`hubProxy.invoke('MoveCursor', position.x, position.y);`

`}`

`}`

`function canvasBrushDown(position) {`

`isBrushDown = true;`

`storeDrawCoordinates(position);`

`return true;`

`}`

`function canvasBrushUp(position) {`

`isBrushDown = false;`

`storeDrawCoordinates(position);`

`sendBrushData(brushPositions);`

`brushPositions = [];`

`isDrawingContinued = false;`

`var c = document.getElementById("scratchCanvas");`

`var ctx = c.getContext("2d");`

`ctx.closePath();`

`ctx.clearRect(0, 0, 600, 400);`

`}`

`function sendBrushData(brushPositionsData)`

`{`

`var currentBrushData = new CurrentBrushData();`

`var brushData = {`

`BrushPositions: brushPositionsData,`

`ClientSequenceId: Date.now(),`

`Color: currentBrushData.Color,`

`Size: currentBrushData.Size,`

`Type: currentBrushData.Type`

`}`

`hubProxy.invoke('SendDrawCommand', brushData).fail(function (error) {`

`});`

`}`

`function storeDrawCoordinates(position) {`

`var c = document.getElementById("scratchCanvas");`

`var ctx = c.getContext("2d");`

`var allowChange = false;`

`if (brushPositions.length > 0)`

`{`

`var lastPosition = brushPositions[brushPositions.length - 1];`

`if (Math.abs(lastPosition.x - position.x) >= 1 || Math.abs(lastPosition.y - position.y) >= 1) allowChange = true;`

`}`

`else {`

`allowChange = true;`

`}`

`if (!isDrawingContinued) {`

`ctx.beginPath();`

`isDrawingContinued = true;`

`ctx.moveTo(position.x, position.y);`

`}`

`var currentBrushData = new CurrentBrushData();`

`ctx.strokeStyle = currentBrushData.Color;`

`ctx.lineWidth = currentBrushData.Size;`

`ctx.lineTo(position.x, position.y);`

`ctx.stroke();`

`brushPositions.push(position);`

`if (Date.now() - lastDrawTime > 50) {`

`lastDrawTime = Date.now();`

`var tempPositions = brushPositions.splice(0);`

`brushPositions.push(position);`

`sendBrushData(tempPositions);`

`}`

`}`

`function userConnected(userName) {`

`var alreadyExists = false;`

`for (var x = 0; x < userList.length; x++) {`

`if (userList[x] == userName) {`

`alreadyExists = true;`

`break;`

`}`

`}`

`if(!alreadyExists)   userList.push(userName);`

`drawUserList();`

`}`

`function userDisconnected(userName) {`

`for (var x = userList.length - 1; x > -1; x--) {`

`if (userList[x] == userName) {`

`userList.splice(x, 1);`

`}`

`}`

`drawUserList();`

`}`

`function drawUserList() {`

`var userListHTML = [];`

`for (var x = 0; x < userList.length; x++) {`

`userListHTML.push('<li>');`

`userListHTML.push(userList[x]);`

`userListHTML.push('</li>');`

`}`

`$('#userList').html(userListHTML.join(''));`

`}`

现在我们已经了解了所有的画布空间逻辑，让我们通过以下步骤将其添加到项目中:

Click Publish.  

![A978-1-4302-6320-3_10_Fig18_HTML.jpg](A978-1-4302-6320-3_10_Fig18_HTML.jpg)

图 10-18。

Publish summary dialog box Validate the settings in the Publish summary dialog box (similar to Figure [10-18](#Fig18)).  

![A978-1-4302-6320-3_10_Fig17_HTML.jpg](A978-1-4302-6320-3_10_Fig17_HTML.jpg)

图 10-17。

Cloud Service context menu Add an HTML file called `Canvas.html` with the contents of Listing 10-107 in the `Content` folder of the `GroupBrush.Web` project.   Update the version numbers for the scripts to be the same as the version in the `Scripts` folder.   Update the `Copy To Output Directory` property to `Copy Always`.   Add a `.css` file called `Canvas.css` with the contents of Listing 10-108 in the `Styles` folder of the `GroupBrush.Web` project.   Update the `Copy To Output Directory` property to `Copy Always`.   Add a JavaScript file called `Canvas.js` with the contents of Listing 10-118 in the `Scripts` folder of the `GroupBrush.Web` project.   Update the `Copy To Output Directory` property to `Copy Always`.   Move all jQuery files in the `Scripts` directory to the `Scripts` directory in the `Public` directory.   Update the `Copy To Output Directory` property to `Copy Always`.   Right-click the `GroupBrush.Cloud` project and click Publish (see Figure [10-17](#Fig17)).  

我们现在已经成功地部署了完成的项目。试试看！图 [10-19](#Fig19) 显示了一个实际应用的例子。

![A978-1-4302-6320-3_10_Fig19_HTML.jpg](A978-1-4302-6320-3_10_Fig19_HTML.jpg)

图 10-19。

Canvas page

这个例子只显示了一个客户端，JavaScript 客户端。使用我们已经创建的现有服务器结构，可以添加更多的客户端。

## 摘要

我们已经创建了一个应用程序，允许我们实时地协作绘图和发送消息。该应用程序也通过身份验证得到保护。在我们添加了需要扩展的代码后，应用程序无需太多工作就能够按需扩展。最后，我们可以用我们创建的服务器支持各种客户机。

我们希望你喜欢阅读这本书，现在有一个坚实的了解信号。我们祝你在未来的信号工程中好运。