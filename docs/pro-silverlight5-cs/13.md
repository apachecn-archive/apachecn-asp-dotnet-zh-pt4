## 13

## Silverlight 3D

正如您已经知道的，Silverlight 最初是作为 WPF 库中的特性、类和功能的子集出现的。早在 Silverlight 发布之前，这项技术首先被称为 WPF/E(每个人的 WPF 的简写)。

但是在 Silverlight 1.0 之后的这些年里，Silverlight 已经走上了自己的路。正如所料，它继承了 WPF 的一些特性，包括 WPF 的许多控件、命令、数据绑定和样式特性，以及。NET 文件访问模型。但它也在 WPF 之前获得了一些新功能(如动画放松和视觉状态)，并添加了一些没有直接 WPF 对等物的功能(如网络摄像头支持，DeepZoom 和 PivotViewer)。但是 Silverlight 与 WPF 世界最大的不同是它的 3D 绘图模型。

WPF 有自己的 3D 渲染功能，这些功能基于 Viewport3D 控件。使用它们，您可以在 XAML 创建 3D 绘图(通常使用 3D 插图程序)或用代码生成 3D 模型。Silverlight 避开了 Viewport3D 控件，转而支持完全不同的 DrawingSurface 控件，该控件基于 Microsoft XNA framework，也是用于在 Xbox 上创建游戏的工具包。

在 WPF 使用 Viewport3D 控件创建 3D 应用程序非常困难。使用 DrawingSurface 控件在 Silverlight 中创建 3D 应用程序要稍微困难一些。为了渲染甚至简单的 3D 场景，您需要考虑像像素着色器这样的底层管道。然而，如果你花时间学习必要的概念，你将能够创建一个全新的应用程序类别——并且由于 Silverlight 的硬件加速，你将获得快速、敏捷的视觉效果。如果你已经有了开发 Xbox 或 Windows Phone 的微软 XNA 经验，你会发现你的许多技能可以移植到 Silverlight 支持的 web 应用程序世界。

![images](images/square.jpg) **新功能** Silverlight 的 3D 支持在 Silverlight 5 中是全新的。

### 了解 Silverlight 中的 3D

你已经知道 Silverlight 的 3D 模型不是基于 WPF 的 3D 模型。在继续之前，您应该了解关于 Silverlight 提供的 3D 支持的一些关键事实:

> *是硬件加速的*:其实它*肯定*是，因为没有软件渲染回退。如果您不打开硬件加速或它不可用(例如，在非常旧的视频硬件或坏的视频驱动程序的情况下)，您将无法显示任何内容。
> 
> *它是以代码为中心的*:与 WPF 的 3D 框架不同，你不能单独通过 XAML 标记在 Silverlight 中创建任何 3D 内容。相反，由您的代码来创建许多对象并管理一个相当详细的绘制过程。(或者使用构建在 3D 系统上并提供标记支持的第三方工具。)
> 
> 它发生在 XNA 之后，而不是 Silverlight 的其余部分:在某些情况下，这会导致令人困惑的重复。例如，Silverlight 已经有了自己的矩形和颜色类，但是 Silverlight 的 3D 程序集为 3D 渲染引入了新的矩形和颜色类。类似地，Silverlight 3D 使用非托管像素着色器，而不是您在《T2》第 9 章中了解到的 ShaderEffect 类，并且它不支持 Silverlight 功能，如动画、变换和数据绑定。
> 
> 它不支持所有的 XNA :在完整的微软 XNA 平台上有很多渲染功能，但是在 Silverlight 中不支持。例如，Silverlight 只支持像素着色器的相对过时的着色器模型 2.0 标准(发布于 2002 年)，但它不支持更常见的着色器模型 3.0。
> 
> 它需要一台 Windows 电脑:不幸的是，因为 3D 功能是建立在 XNA 管道上的，所以它们不能在 Mac 电脑上工作。

记住这些细节，您就可以开始创建您的第一个 3D 场景了。

#### 添加程序集引用

Silverlight 的 3D 支持被分散在少数几个程序集之间，但最终您需要添加对所有程序集的引用。它们包括以下内容:

> System.Windows.Xna.dll:这个程序集定义了核心类型，比如 DrawingSurface 控件和管理它的 GraphicsDeviceManager。
> 
> Microsoft.Xna.Framework.dll:这个组件包括 XNA 版本的颜色和矩形结构。它还包括你在[第 12 章](12.html#ch12)中考虑的微软 XNA 驱动的音频支持。
> 
> *Microsoft.Xna.Framework.Graphics.dll*:这个组件包括许多核心绘图类型，包括 GraphicsDevice，通过它你可以在绘图表面上执行所有的 3D 绘图。
> 
> Microsoft.Xna.Framework.Graphics.Extensions.dll:这个组合包括了更多重要的绘画材料。这包括 BasicEffect 类，它包装了许多绘图细节，并提供了一个简单的硬编码像素着色器，因此您不需要自己编写它。
> 
> Microsoft.Xna.Framework.Graphics.Shaders.dll:这个组件包括 PixelShader 和 VertexShader 类，如果你有编译好的 HLSL(高级着色器语言)代码，它们可以让你加载你自己的着色器。
> 
> *Microsoft.Xna.Framework.Math.dll*:这个类包括用点和矩阵进行 3D 计算的基本成分，比如 Vector3 和 Matrix。

在继续之前，您应该添加对所有这些程序集的引用。

#### 在 Silverlight 项目中启用 3D

Silverlight 的 3D 支持需要硬件加速。没有它，任何 3D 绘图都是不可能的。更糟糕的是，如果你不启用硬件加速，你将不会得到警告 DrawingSurface 控件将只是顽固地保持空白。

幸运的是，启用硬件加速很容易。正如您在[第 10 章](10.html#ch10)中了解到的，您需要做的就是将 enableGPUAcceleration 参数添加到测试页面的 Silverlight 插件部分，就像这样:

`<div id="silverlightControlHost">
  <object data="data:application/x-silverlight-2,"
   type="application/x-silverlight-2" width="100%" height="100%">
   **<param name="enableGPUAcceleration" value="true" />**
    ...
  </object>
  <iframe style="visibility:hidden;height:0;width:0;border:0px"></iframe>
</div>`

然而，这里有一个重要的陷阱。默认情况下，Silverlight 被阻止使用硬件加速。这是为了防止某些类型的拒绝服务攻击(基本上，坏软件试图用荒谬复杂的着色器和几何图形捆绑你的显卡)。尽管其他 3D 技术(如 WebGL)也面临同样的问题，尽管这种攻击从未出现过，但微软还是采取了这种保护措施来降低风险。

那么 Silverlight 应用程序如何获得使用硬件加速和 3D 绘图的许可呢？有两种选择:

> 用提升的信任安装应用程序:这授予应用程序广泛的权限，包括硬件加速，如[第 18 章](18.html#ch18)所述。然而，它需要一个安装步骤或证书配置，并不适合每种类型的应用程序。
> 
> *更改 Silverlight 属性*:用户可以使用 Silverlight 配置窗口显式解锁视频驱动，但是有点笨拙。为此，用户需要右键单击 Silverlight 内容区域，在菜单中单击 Silverlight，然后选择 Permissions 选项卡。在这里，用户必须找到对应于当前应用程序的域(例如 YourSite.com)，选择该域，然后单击 Allow 按钮以启用 3D 支持。

如果您正在测试您的应用程序，或者将它安装在公司网络中，第一个选项效果最好。但是在公共应用程序中，第二个选项可能是唯一可行的选择。然而，重要的是要理解 Silverlight 不会告诉用户需要进行配置更改。相反，如果硬件加速被阻止，您创建的任何 3D 场景都不会渲染，也不会生成任何通知消息或异常。要检测此问题，可以在应用程序加载时检查 GraphicsDeviceManager 的 RenderMode 和 RenderModeReason 属性。下面的示例首先检查这个问题，然后查找其他几个不太常见的问题:

`private void Application_Startup(object sender, StartupEventArgs e)
{
    GraphicsDeviceManager gdm = GraphicsDeviceManager.Current;            
   **if (gdm.RenderMode == RenderMode.Unavailable)**
    {`
`        switch (gdm.RenderModeReason)
        {
           **case RenderModeReason.SecurityBlocked:**
                MessageBox.Show("3D support is currently disabled to enforce " +
                  " security. You can enable it by following these steps ...");
                break;
            case RenderModeReason.GPUAccelerationDisabled:
                MessageBox.Show("Developer error! Use the enableGPUAcceleration " +
                  "parameter in the test page to enable 3D rendering.");
                break;
            case RenderModeReason.Not3DCapable:
                MessageBox.Show(
                  "Your computer doesn't appear to support 3D rendering.");
                break;
            case RenderModeReason.TemporarilyUnavailable:
                MessageBox.Show(
                  "There was a problem accessing the video card driver.");
                break;
        }
    }
    else
    {
        // Run the application as normal.
        this.RootVisual = new MainPage();
    }
}`

当然，有比使用消息框更好的方法来处理这个问题。例如，如果您检测到 RenderModeReason 被 SecurityBlocked，您可以将应用程序的 RootVisual 设置为一个窗口，该窗口具有详细的设置说明，并在配置更改时提示用户刷新页面。

至此，您已经知道如何创建一个简单的应用程序来验证它是否支持 3D。

### 基本三维绘图

在 Silverlight 中，所有的 3D 绘制都在一个名为 DrawingSurface 的控件中进行，这个控件可以在系统中找到。Windows.Controls 命名空间。DrawingSurface 是一个普通的 Silverlight 控件，这意味着您不需要添加任何程序集引用或导入任何命名空间来使用它。通常，您会将 DrawingSurface 放在一个具有黑色背景的容器中，以便可以在顶部绘制内容:

`<Grid x:Name="LayoutRoot" Background="Black">
  <DrawingSurface Width="400" Height="300"></DrawingSurface>
</Grid>`

当您将 DrawingSurface 控件添加到页面时，您可以给它固定的尺寸(如本示例所示)，这允许您编写最简单的绘图代码。或者，您可以让绘图表面扩展以填充其容器，并相应地修改您的绘图代码，您将在本章的稍后部分看到这一点。

要使内容真正出现在 DrawingSurface 控件中，您需要处理它的 Draw 事件:

`**<DrawingSurface Width="400" Height="300" Draw="drawingSurface_Draw">**
</DrawingSurface>`

不幸的是，编写绘图逻辑没有捷径可走。在您可以在绘图图面中呈现单个形状之前，您需要学习一些新概念。您将在接下来的几节中讨论这些内容。

#### 3D 坐标系

在定位一个三角形之前，您需要在 Silverlight 使用的坐标系中确定自己的方向。Silverlight 采用微软 XNA 的约定，并使用一个*右手*坐标系。

为了理解这意味着什么，想象 z 轴直接指向屏幕外面，朝向你。当一个点沿着 z 轴向你移动时，它的 z 坐标会增加。随着它的远离，它的 z 坐标会减小。(x 轴和 y 轴与二维图中的相同)。图 13-1 说明了。

   ![images](images/9781430234791_Fig13-01.jpg)

***图 13-1。**Silverlight 中的 3D 坐标轴*

#### 填充顶点缓冲器

现在您已经知道了 3D 空间的样子，您已经准备好创建一些 3D 内容了。这就是事情开始变得棘手的地方。

如果你以前曾经处理过 3D 绘图(或者如果你读过一些关于现代视频卡的底层技术)，你可能已经知道计算机用三角形构建 3D 场景。这是因为三角形是定义曲面最简单、最精细的方式。三角形很简单，因为每个三角形只由三个点定义(角上的三个顶点)。圆弧和曲面显然更复杂。三角形是粒状的，因为其他直边形状(正方形、矩形和更复杂的多边形)可以分解成一组三角形。无论好坏，现代图形硬件和图形编程都是建立在这个核心抽象之上的。

![images](images/square.jpg) **注**一个*顶点*是一个数据对象，表示 3D 空间中的一个单点。例如，大多数 3D 绘图系统都是通过用成千上万个小三角形构建复杂的表面和物体来工作的。每个三角形由它的三个角点定义，每个角点是一个顶点。

显然，大多数你想要的 3D 物体看起来不会像简单的平面三角形。相反，你需要组合三角形——有时只是几个，但通常是数百个或数千个以不同角度排列的三角形。例如，[图 13-2](#fig_13_2) 展示了如何用三角形构造一个球体。随着您添加更多三角形，曲面会变得更加平滑。(在最右边的图中，球体实际上是由矩形构成的，但每个矩形都是由两个三角形构成的，这里没有显示。)

![images](images/9781430234791_Fig13-02.jpg)

***图 13-2。**用三角形构建 3D 物体*

![images](images/square.jpg) **注意**不幸的是，Silverlight 没有任何更高级别的 3D 对象抽象。库中没有球体、立方体或网格，尽管第三方工具包可以(并将)基于 Silverlight 的 3D 支持来提供所有这些成分以及更多。

所以，你可以在 3D 中渲染的最简单的形状是一个三角形。要画这个三角形，需要在每个角上定义一个点，或者说*顶点*。一个*顶点缓冲区*是保存你的形状中所有三角形的顶点组合的对象。

比如，假设你要画[图 13-3](#fig_13_3) 所示的三角形。

   ![images](images/9781430234791_Fig13-03.jpg)

***图 13-3。**3D 世界空间中的一个三角形*

在编写任何代码之前，您应该导入以下命名空间:

`using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using System.Windows.Graphics;`

要绘制三角形，首先需要在 VertexBuffer 中定义三角形的三个顶点。为了优化绘图性能，顶点缓冲区、对象模型等总是在 DrawingSurface 之外定义。实际绘制它们的 Draw 事件处理程序。因此，将 VertexBuffer 定义为用户控件中的类级变量是有意义的。同时，您还需要创建一个 BasicEffect 类的实例，它将管理绘图过程的其他方面，稍后您将了解到:

`// Stores the corners of all your triangles.
private VertexBuffer vertexBuffer;

// Stores various drawing details.
private BasicEffect effect;`

现在，当页面加载后，您就可以开始工作了。最好的设计是将您的代码放在一个专用的方法中，如下面所示的 PrepareDrawing()方法:

`private void PrepareDrawing()
{
    ...
}`

然后，您可以从用户控件的构造函数中调用此方法:

`public SingleTriangleExample()`
`{
    InitializeComponent();

    PrepareDrawing();
}`

![images](images/square.jpg) **注意**不要犯在事件处理程序中为加载的事件执行初始化逻辑的错误。有时，DrawingSurface 会在加载的事件完成之前触发其第一个 Draw 事件。因为 Draw 事件在不同的线程(称为*渲染线程*)上触发，所以您的绘制代码可能会在顶点缓冲区准备好之前启动，这将导致异常。

本节的其余部分将检查您将放入 PrepareDrawing()方法中的代码。

首先，你需要为你的形状创建顶点。每个顶点由 Vector3 类的一个实例表示。下面是创建图 13-3 中三角形所需的三个顶点的代码:

`// Define the triangle's vertices.
Vector3 topCenter = new Vector3(0, 1, 0);
Vector3 bottomLeft = new Vector3(-1, 0, 0);
Vector3 bottomRight = new Vector3(1, 0, 0);`

不太明显的是，每个顶点也需要一种颜色。当像素着色器绘制三角形时，它通过插值三个周围顶点的颜色来分别为每个像素着色。如果顶点使用相同的颜色，整个三角形将被纯色填充。但是，如果顶点使用不同的颜色(如在这个例子中)，你得到一个混合，渐变效果。

要创建颜色，请使用颜色类:

`// When creating a color, you supply the red, greed, blue, and
// (optionally) alpha values.
// This is white:
Color color1 = new Color(255, 255, 255);
// and red:
Color color2 = new Color(255, 0, 0);
// and green:
Color color3 = new Color(0, 255, 0);`

为了避免命名空间冲突，请确保不要导入系统。Windows.Media 命名空间，它有自己的冲突版本的颜色结构。

现在，您已经准备好结合位置和颜色数据来创建一个 VertexPositionColor 对象数组，这是您将要构建的顶点缓冲区中的关键成分:

`// Combine the color and vertex information.
VertexPositionColor[] vertices = new VertexPositionColor[3];
vertices[0] = new VertexPositionColor(bottomLeft, color1);
vertices[1] = new VertexPositionColor(topCenter, color3);
vertices[2] = new VertexPositionColor(bottomRight, color2);`

下一步是创建 VertexBuffer 对象。为此，首先需要获得对当前 GraphicsDevice 的引用，该引用由 GraphicsDeviceManager 提供:

`GraphicsDevice device = GraphicsDeviceManager.Current.GraphicsDevice;`

然后，您可以创建并填充顶点缓冲区:

`vertexBuffer = new VertexBuffer(device, typeof(VertexPositionColor),
  vertices.Length, BufferUsage.WriteOnly);
vertexBuffer.SetData(0, vertices, 0, vertices.Length, 0);`

如果这段代码看起来不必要的复杂，那是因为顶点缓冲区的结构可以变化。在本例中，顶点缓冲区填充了 VertexPositionColor 对象(由传递给 vertex buffer 构造函数的第二个参数指定)。但是，您也可以拥有一个不包含颜色信息或使用纹理数据的顶点缓冲区。事实上，顶点缓冲区的行为几乎就像一个低级的字节数组，因此您需要使用 vertex buffer 显式地将一系列数据复制到其中。SetData()方法。

现在，您已经完成了用一个三角形信息填充顶点缓冲区所需的所有代码。但是，在编写绘制逻辑之前，您需要创建一个能看到 3D 场景的摄像机。

#### 定位摄像机

在渲染 3D 场景之前，您需要将相机放置在正确的位置，并使其朝向正确的方向。

定位摄像机非常简单，但需要您指定三个细节。第一个细节是 3D 空间中将要放置摄像机的点。第二个细节是摄像机正在观察的点。综合起来，这两个细节决定了相机离你的内容有多远(因此，场景在 DrawingSurface 控件中会出现多大)以及相机是否能看到你的内容(如果指向错误的方向，它就看不到)。图 13-4 显示了这些细节是如何协同工作的。

   ![images](images/9781430234791_Fig13-04.jpg)

***图 13-4。**定位摄像机*

然而，这些细节还不够。你还需要告诉摄像机哪个方向是“向上”，这样它就可以自己确定方向。毕竟，即使有一个给定的位置和观察方向，也没有什么可以阻止相机旋转自己来观察侧面或上下颠倒的场景。在[图 13-4](#fig_13_4) 中，上方向直接指向(0，1，0)点，几何上向上。这是一个自然的设置，但是图 13-5 中[所示的带标题的摄像机同样是可能的。](#fig_13_5)

   ![images](images/9781430234791_Fig13-05.jpg)

***图 13-5。**定位摄像机*

要定位摄像机，您必须创建一个矩阵来设置所有这三个细节。实际上，理解对 3D 场景有意义的矩阵数学是复杂的，远远超出了本章的范围。然而，Silverlight 包含了足够的功能来创建你需要的矩阵并使用它们，而不需要咀嚼复杂的矩阵数学。

例如，放置摄像机时，您可以使用 handy Matrix。CreateLookAt()方法。它获取相机位置、相机观察方向和向上方向。每种成分都由一个单独的 Vector3 对象表示。下面是如何使用 CreateLookAt()方法将相机放置在 z 轴线上，正面观察三角形:

`Matrix view = Matrix.CreateLookAt(new Vector3(0, 0, 1), Vector3.Zero, Vector3.Up);`

相比之下，下面是你如何移动相机到图 13-4 所示的点:

`Matrix view = Matrix.CreateLookAt(new Vector3(-2, 2, 3), Vector3.Zero, Vector3.Up);`

下面是如何将倾斜的摄像机放置在[图 13-5](#fig_13_5) 中:

`Matrix view = Matrix.CreateLookAt(new Vector3(-2, 2, 3), Vector3.Zero,
  new Vector3(-1, 2, 0));`

现在相机绕 z 轴倾斜。因此，您的 3D 内容看起来会向另一个方向倾斜一点。这就好像你在观察场景时把头歪向了一边。

这些相机细节被称为*视图*(或者，有时，视图空间)。该视图决定了渲染时 3D 场景的位置、大小和几何形状。然而，在 Silverlight 3D 中，还有另一个关键的相机细节需要考虑，称为*投影。*视图设置摄像机的位置，而投影设置摄像机可以看到的视图部分(因此，视频卡将绘制的部分)。这一可见部分被称为*视锥*，如图[图 13-6](#fig_13_6) 所示。

   ![images](images/9781430234791_Fig13-06.jpg)

***图 13-6。**视图投影*

视图投影会修剪掉场景中太远的部分(无论如何都可能被其他对象遮挡)和太近的部分。因为视频卡不需要渲染场景中不会显示的部分，所以这种技术可以确保最佳性能。

矩阵类再一次用一个专用的方法简化了生活。CreatePerspectiveFieldOfView()方法接受四个浮点数，并使用它们来计算投影，它以矩阵的形式返回投影。表 13-1 解释了这四个参数。

![images](images/9781430234791_tab13-01.jpg)

下面的代码为单三角形示例创建投影。它会渲染距离相机 1 到 10 个单位的所有东西。1.33 的纵横比是通过将绘图表面宽度(400)除以高度(300)来计算的。

`Matrix projection = Matrix.CreatePerspectiveFieldOfView(MathHelper.PiOver4,
  1.33f, 1, 10);`

有点令人困惑的是，CreatePerspectiveFieldOf()方法实际上返回了一个透视投影，这并不是 3D 场景所需的最终视图投影。要计算视图投影，您需要一个额外的步骤。一旦投影矩阵从矩阵中返回。CreatePerspectiveFieldOfView()方法，必须将其乘以视图矩阵，就像这样:

`Matrix viewProjection = view * projection;`

既然已经有了视图和投影矩阵，就可以创建和配置一个 BasicEffect 对象了，这是 PrepareDrawing()方法中的最后一个初始化步骤。

**透视和正交摄像机**

相机视图和投影确定如何将 3D 场景投影到 DrawingSurface 控件的 2D 图面上。

当您调用 CreatePerspectiveFieldOfView()时，您为一个*透视摄像机*创建了一个矩阵。透视相机渲染场景，使远处的物体看起来更小。这是大多数人在 3D 场景中预期的行为。

您还可以通过调用 Matrix 类的 CreateOrthographicOffCenter()或 CreateOrthographicOffCenter()方法来创建一个*正交摄像机*。正交相机会展平 3D 对象，以便保留精确的比例，无论形状位于何处。这看起来有点奇怪，但是对于某些类型的可视化工具很有用。例如，技术绘图应用程序经常依赖于这种类型的视图。最后，对于更专业的相机效果，您可以手动创建自己的投影矩阵。[图 13-7](#fig_13_7) 显示了透视相机和正交相机的区别。

![images](images/9781430234791_Fig13-07.jpg)

***图 13-7。**不同类型相机中的视角*

#### 配置基本效果

要理解 BasicEffect 对象，您需要了解更多关于 Silverlight 3D 模型的信息。从技术上讲，Silverlight 3D 使用*着色器*来完成所有渲染工作，这些着色器是直接在显卡的 GPU 上运行的微小代码。有两种类型的着色器:

> 顶点着色器:这是一段代码，它检查你的顶点缓冲区中的每个顶点，并将其位置从虚拟 3D 空间中的坐标转换为 2D 绘图表面中的物理显示位置。
> 
> 像素着色器(pixel shader):这是一段代码，它检查将要绘制的每个像素(作为线条或三角形的一部分)并分配适当的颜色。

您可以编写自己的着色器，并使用 DirectX SDK 中的 fxc.exe 实用程序进行编译(可从`[http://msdn.microsoft.com/en-us/directx/aa937781](http://msdn.microsoft.com/en-us/directx/aa937781)`获得)。着色器的语法是 HLSL(高级着色器语言)，类似于 C#。然而，用任何语言编写低级像素处理算法都是冗长而复杂的。

好在 Silverlight 继承了微软的 XNA 更高级的特效模型。这个想法是你的应用程序使用一个效果对象，它有自己内置的顶点和像素着色器。许多效果对象引入了更复杂的渲染，支持纹理、照明、材质、雾和蒙皮。

所有效果类都是从。Xna.Framework.Graphics 命名空间。Silverlight 包括一个几乎不可或缺的效果类，叫做 BasicEffect。尽管名为 BasicEffect，但它非常实用，功能惊人地全面——具有执行基本着色、纹理映射和复杂照明的内置能力。在这一章中，您将花大量的时间使用 BasicEffect，并学习如何使用所有这些有价值的特性。

要准备当前示例中的 BasicEffect 对象，您需要使用在上一节中创建的矩阵来设置视图和投影:

`effect = new BasicEffect(device);
effect.View = view;
effect.Projection = viewProjection;`

您还需要设置世界矩阵，它允许您将对象移动到新位置:

`effect.World = Matrix.Identity;`

在场景中定位多个对象时，世界矩阵非常方便，每个对象都有不同的基本效果对象。世界矩阵允许您将每个对象从定义它的初始位置(通常，围绕(0，0，0)处的原点)移动到相对于场景其余部分的另一个位置。从概念上讲，这一步将你的内容从原始的*物体空间*移动到完整场景的*世界空间*。从技术上讲，这种移动是通过将原始位置乘以您提供的世界矩阵来执行的。

在这个例子中只有一个物体，不需要把它移动到世界空间的任何地方。所以，代码使用了*单位矩阵*。(单位矩阵是在矩阵乘法运算中使用时不会改变任何东西的矩阵。因此，对象保持在其当前位置。)在本章的后面，你将看到如何使用世界矩阵来移动和旋转一个 3D 物体。

您需要在 BasicEffect 对象中设置的最后一个属性是 VertexColorEnabled。通过将其设置为 true，您可以打开内置的像素着色器来为三角形着色:

`effect.VertexColorEnabled = true;`

如果你不采取这一步，你不提供任何其他像素着色器，基本效果不会绘制你的对象。

这就完成了 PrepareDrawing()方法中的初始化代码。现在，您已经准备好进入实际的绘制逻辑，使用您看到的所有成分来呈现您的 3D 内容。

#### 绘制场景

如前所述，DrawingSurface 控件会在代码渲染场景时触发一个 Draw 事件。首要任务是获取对当前 GraphicsDevice 对象的引用，并使用 clear()方法清除任何预先存在的内容，如下所示:

`private void drawingSurface_Draw(object sender, DrawEventArgs e)
{
    GraphicsDevice device = GraphicsDeviceManager.Current.GraphicsDevice;

    device.Clear(new Color(0, 0, 0));
    ...`

![images](images/square.jpg) **注意**每个绘图操作都应该从调用 Clear()方法开始。如果您第一次忘记清除表面，DrawingSurface 将使用深紫色背景来表示您的疏忽。

下一步是获取您之前创建的顶点缓冲区，其中包含您想要绘制的内容，并将其应用到 GraphicsDevice。这可以通过调用 SetVertexBuffer()方法来实现:

`    ...
    device.SetVertexBuffer(vertexBuffer);
    ...`

最后一步是执行实际的绘图。使用效果对象时，您可能需要多次重复绘制，这取决于它所创建的效果的种类。幸运的是，你不需要担心通过的次数。您只需要遍历效果中的所有 EffectPass 对象。CurrentTechniques.Passes 集合。对于您找到的每一个，调用 EffectPass。Apply()，然后用 GraphicsDevice 绘制内容。DrawPrimitives()方法:

`    ...
    // Perform all the passes.
    foreach (EffectPass pass in effect.CurrentTechnique.Passes)
    {
        pass.Apply();

        device.DrawPrimitives(PrimitiveType.TriangleList,
          0, vertexBuffer.VertexCount / 3);
    }
}`

图 13-8 显示了期待已久但有些平淡无奇的结果。在这里，相机正从一个适当的距离直视一个单一的。在 BasicEffect 对象的内置像素着色器的帮助下，三角形使用三种不同的颜色(每个顶点一种)来创建渐变填充。

   ![images](images/9781430234791_Fig13-08.jpg)

***图 13-8。**最简单的 3D 场景之一*

![images](images/square.jpg) **注意**当你第一次显示带有 DrawingSurface 控件的页面时，Draw 事件会立即触发。但是，它不会再次触发，除非您调用 DrawEventArgs。在绘制逻辑的末尾使用 InvalidateSurface()方法或调用 DrawingSurface。Invalidate()方法。在本章的后面，当你开始制作 3D 对象的动画时，你会学到更多关于这个技术的知识。

在这个例子中，DrawPrimitives()方法是绘图逻辑的核心。这里，DrawPrimitives()方法用于绘制一系列一个或多个三角形(一个 TriangleList)，从顶点缓冲区的开头(位置 0)开始，只查找一个三角形(vertex buffer 的结果。VertexCount / 3)。

这是相当典型的代码。通过将更多的顶点添加到顶点缓冲区的末尾(三个一组)，可以将更多的三角形添加到三角形列表中。然后，DrawPrimitives()方法将一步画出所有的三角形。

然而，值得指出的是，你还可以画一些其他种类的图元，如[表 13-2](#tab_13_2) 所列。当然，如果你绘制一个不同类型的图元，你需要相应地调整你的顶点缓冲区，使它有适当的顶点数。

![images](images/9781430234791_tab13-02.jpg)

![images](images/9781430234791_tab13-02a.jpg)

#### 背面剔除

正如您所了解的，有许多潜在的问题会阻碍您的 3D 效果。到目前为止，您已经了解了一些常见问题，所有这些问题都有相同的令人沮丧的黑屏症状:

*   无法启用 3D 加速
*   忘记在绘图表面后面放置纯黑色背景
*   将相机指向错误的方向
*   将相机放得过近或过远，因此物体会落在视锥之外
*   无法在 BasicEffect 对象中启用顶点着色

还有一个错误会让你的 3D 图形消失:如果你以逆时针方向定义你的顶点，而不是顺时针方向。这是因为 Silverlight 使用一种叫做*背面剔除*的技术来移除任何看起来像是物体背面的表面。(从技术上讲，背面剔除是为了通过不绘制对象不需要的背面来提高性能。问题是 Silverlight 使用了一个相对粗糙的测试——它假设如果一个形状是相对于相机的位置逆时针绘制的，那么这个形状就是背面。)

下面是一个有问题的代码示例，它通过交换前一个示例中的第一个和第三个顶点，按逆时针顺序绘制了一个三角形:

`VertexPositionColor[] vertices = new VertexPositionColor[3];
vertices[0] = new VertexPositionColor(bottomRight, color2);
vertices[1] = new VertexPositionColor(topCenter, color3);
vertices[2] = new VertexPositionColor(bottomLeft, color1);`

当你渲染这个顶点缓冲时，不会出现三角形。

![images](images/square.jpg) **注意**背面剔除的工作方式与三角形带略有不同。与 TriangleList 不同，TriangleStrip 在每个偶数编号的三角形上“翻转”背面剔除顺序。这意味着偶数编号的逆时针三角形会出现，而奇数编号的顺时针三角形不会出现。

如果你遇到背面剔除的问题，你可以简单的关闭它。为此，您需要替换 GraphicState。用新的光栅化状态对象。在实际调用 DrawPrimitives()之前，您可以在绘图代码中的任何位置执行此操作(当响应绘图事件时):

`device.RasterizerState = new RasterizerState()
{
    CullMode = CullMode.None
};`

栅格化状态对象也给你一些更多的属性来调整。最有用的是，您可以将渲染切换到线框模式，以便显示没有内部填充的三角形线。这使得更容易看到场景中不同对象如何重叠。

`device.RasterizerState = new RasterizerState()
{
    FillMode = FillMode.WireFrame
};`

#### 缩放您的绘图

在当前示例中，DrawingSurface 被分配了一个固定的大小(宽 400 像素，高 300 像素)。但是在许多应用程序中，您会希望给用户调整浏览器窗口大小的机会，并且您会调整 3D 绘图的大小以与之匹配。

若要实现此技术，首先需要从页面标记中的 DrawingSurface 控件中移除硬编码的宽度和高度属性。然后，您需要响应 DrawingSurface 或其容器的 SizeChanged 事件，并适当地调整投影:

`private void DrawingSurface_SizeChanged(object sender, SizeChangedEventArgs e)
{            
    // Apply new scale.
   **float aspectRatio = (float)e.NewSize.Width / (float)e.NewSize.Height;**
   Matrix view = Matrix.CreateLookAt(new Vector3(0, 0, 5), Vector3.Zero,
      Vector3.Up);
    Matrix projection = Matrix.CreatePerspectiveFieldOfView(MathHelper.PiOver4,
      **aspectRatio**, 1, 10);

    effect.Projection = view * projection;
}`

此代码确定 DrawingSurface 的当前纵横比，并使用它来计算投影应该使用的纵横比。然后将该投影应用于当前的基本效果。

您还需要触发实际的重绘操作。用对 DrawingSurface 的调用来结束 SizeChanged 事件处理程序是有意义的。Invalidate()，但实际上这会导致闪烁和偶尔的小故障，可能是因为 Windows 操作系统绘图(背景的)和 3D 渲染(表面的)之间的重叠。相反，通常在绘图例程结束时触发立即刷新，以确保绘图持续保持最新:

`private void drawingSurface_Draw(object sender, DrawEventArgs e)
{
    ...

    e.InvalidateSurface();
}`

幸运的是，这对性能的影响可以忽略不计，因为 Silverlight 的 3D 管道将工作卸载到了显卡上。如果您以后向 3D 内容添加任何动画或交互性，也需要使用这种技术。

![images](images/square.jpg) **注意**如果你的长宽比与你的绘图表面的尺寸不匹配，你的内容将向一个方向拉伸以适应。

### 复杂物体和纹理

对于一个三角形来说，要解决顶点缓冲区、效果、视图和投影的问题是一件很麻烦的事情。因为这个三角形完全是平的，它看起来不像是一个三维绘图的好例子。但是现在您已经理解了 Silverlight 3D 的基本概念，您已经准备好创建更复杂的形状了。

一旦你掌握了最低级的三角形，下一步就是通过组装一小组扁平的 2D 三角形来创建一个立体的、多面的形状。在以下示例中，您将创建一个多维数据集。

立方体由六个正方形边组成。每个正方形边需要两个三角形。然后，每个正方形边可以以一定角度连接到相邻边。图 13-9 显示了一个立方体如何分解成你可以建模的三角形。

   ![images](images/9781430234791_Fig13-09.jpg)

***图 13-9。**把立方体分成三角形*

为了减少开销并提高 3D 程序的性能，通常要避免渲染看不到的形状。例如，如果你知道你永远不会看到图 13-9 所示立方体的底面，那么就没有理由为该面定义两个三角形。但是，在本例中，您将定义每个边，以便可以自由旋转立方体或围绕立方体移动相机。

#### 绘制一个立方体

这个例子中的基本结构与第一个单三角形例子中的相同。首先，您需要存储顶点缓冲区和效果对象的两个相同的成员字段:

`private VertexBuffer vertexBuffer;
private BasicEffect effect;`

在页面出现之前填充顶点缓冲区(在构造函数中)，通常是通过调用您创建的另一个方法(如 PrepareDrawing()方法)。在此方法中，第一步是定义要使用的颜色:

`private void PrepareDrawing()
{
    Color colorRed = new Color(255, 0, 0);
    Color colorBlue = new Color(0, 255, 0);
    Color colorGreen = new Color(0, 0, 255);
    Color colorWhite = new Color(255, 255, 255);
    ...`

下一步是定义要用于三角形的点。正如图 13-9 所示，每个顶点都是立方体的一个角，所以每个顶点都被三到六个三角形共享，这取决于你在哪里划分边。为了使这堆顶点更容易管理，有必要分别定义这些点，然后重用它们来创建您需要的顶点。

很明显，每个立方体总共需要八个点，四个是组成正面的正方形，四个是组成背面的正方形:

`    ...    
    Vector3 topLeft = new Vector3(-1, 1, 0);
    Vector3 bottomLeft = new Vector3(-1, -1, 0);
    Vector3 topRight = new Vector3(1, 1, 0);
    Vector3 bottomRight = new Vector3(1, -1, 0);

    Vector3 topLeftFront = new Vector3(-1, 1, 1);
    Vector3 bottomLeftFront = new Vector3(-1, -1, 1);
    Vector3 topRightFront = new Vector3(1, 1, 1);
    Vector3 bottomRightFront = new Vector3(1, -1, 1);
    Vector3 topLeftBack = new Vector3(-1, 1, -1);
    Vector3 topRightBack = new Vector3(1, 1, -1);
    Vector3 bottomLeftBack = new Vector3(-1, -1, -1);
    Vector3 bottomRightBack = new Vector3(1, -1, -1);
    ...`

正如图 13-9 所示，每个立方体也有 12 个三角形，每个面有两个。这意味着每个三角形需要三个顶点，整个立方体总共需要 36 个三角形来绘制每条边:

`    ...    
    VertexPositionColor[] vertices = new VertexPositionColor[36];
    ...`

下面是将八个点缝合成所需的三十六个顶点的代码:

`    ...
    // The front face.`
`    vertices[0] = new VertexPositionColor(topRightFront, colorBlue);
    vertices[1] = new VertexPositionColor(bottomLeftFront, colorBlue);
    vertices[2] = new VertexPositionColor(topLeftFront, colorBlue);
    vertices[3] = new VertexPositionColor(topRightFront, colorGreen);
    vertices[4] = new VertexPositionColor(bottomRightFront, colorGreen);
    vertices[5] = new VertexPositionColor(bottomLeftFront, colorGreen);

    // The back face.
    vertices[6] = new VertexPositionColor(bottomLeftBack, colorRed);
    vertices[7] = new VertexPositionColor(topRightBack, colorRed);
    vertices[8] = new VertexPositionColor(topLeftBack, colorRed);
    vertices[9] = new VertexPositionColor(bottomRightBack, colorWhite);
    vertices[10] = new VertexPositionColor(topRightBack, colorWhite);
    vertices[11] = new VertexPositionColor(bottomLeftBack, colorWhite);

    // The top face.
    vertices[12] = new VertexPositionColor(topLeftBack, colorRed);
    vertices[13] = new VertexPositionColor(topRightBack, colorRed);
    vertices[14] = new VertexPositionColor(topLeftFront, colorRed);
    vertices[15] = new VertexPositionColor(topRightBack, colorWhite);
    vertices[16] = new VertexPositionColor(topRightFront, colorWhite);
    vertices[17] = new VertexPositionColor(topLeftFront, colorWhite);

    // The bottom face.
    vertices[18] = new VertexPositionColor(bottomRightBack, colorWhite);
    vertices[19] = new VertexPositionColor(bottomLeftBack, colorWhite);
    vertices[20] = new VertexPositionColor(bottomLeftFront, colorWhite);
    vertices[21] = new VertexPositionColor(bottomRightFront, colorGreen);
    vertices[22] = new VertexPositionColor(bottomRightBack, colorGreen);
    vertices[23] = new VertexPositionColor(bottomLeftFront, colorGreen);

    // The left face.
    vertices[24] = new VertexPositionColor(bottomLeftFront, colorGreen);
    vertices[25] = new VertexPositionColor(bottomLeftBack, colorGreen);
    vertices[26] = new VertexPositionColor(topLeftFront, colorGreen);
    vertices[27] = new VertexPositionColor(topLeftFront, colorRed);
    vertices[28] = new VertexPositionColor(bottomLeftBack, colorRed);
    vertices[29] = new VertexPositionColor(topLeftBack, colorRed);

    // The right face.
    vertices[30] = new VertexPositionColor(bottomRightBack, colorRed);
    vertices[31] = new VertexPositionColor(bottomRightFront, colorRed);
    vertices[32] = new VertexPositionColor(topRightFront, colorRed);
    vertices[33] = new VertexPositionColor(bottomRightBack, colorBlue);
    vertices[34] = new VertexPositionColor(topRightFront, colorBlue);
    vertices[35] = new VertexPositionColor(topRightBack, colorBlue);    
    ...`

**给立方体着色**

在这个例子中，每个三角形都被赋予了纯色。(比如一个是蓝色，相邻的一个是绿色，以此类推。)这样就很容易区分你画的三角形了。然而，在一个更现实的应用程序中，你可能会选择使用不同颜色的顶点，这样你的三角形就会被着色。通常，您会希望一个面上的三角形相互融合，因此您会对每个顶点使用相同的颜色，即使它在不同的三角形中:

`// The front face.
vertices[0] = new VertexPositionColor(**topRightFront**, **colorBlue**);
vertices[1] = new VertexPositionColor(bottomLeftFront, colorGreen);
vertices[2] = new VertexPositionColor(topLeftFront, colorRed);
vertices[3] = new VertexPositionColor(**topRightFront**, **colorBlue**);
vertices[4] = new VertexPositionColor(bottomRightFront, colorWhite);
vertices[5] = new VertexPositionColor(bottomLeftFront, colorGreen);`

这种方法的缺点是它会模糊立方体的边缘，因为一个彩色的面可能会混合到另一个面中。图 13-10 显示了立方体的两种绘制方式，左边是实心三角形，右边是混合三角形的一个例子。

![images](images/9781430234791_Fig13-10.jpg)

***图 13-10。**不同阴影的立方体*

一旦定义了顶点，就有了创建和初始化顶点缓冲区的熟悉任务，然后创建基本效果并用当前相机的视图和投影设置对其进行配置。下面是实现这一点的代码，它与单三角形示例中的代码基本相同:

`    ...

    // Set up the vertex buffer.
    GraphicsDevice device = GraphicsDeviceManager.Current.GraphicsDevice;
    vertexBuffer = new VertexBuffer(device, typeof(VertexPositionColor),
      vertices.Length, BufferUsage.WriteOnly);
    vertexBuffer.SetData(0, vertices, 0, vertices.Length, 0);

    // Configure the camera.
    Matrix view = Matrix.CreateLookAt(new Vector3(1, 1, 3), Vector3.Zero,
      Vector3.Up);`
`    Matrix projection = Matrix.CreatePerspectiveFieldOfView(MathHelper.PiOver4,
      1.33f, 1, 100);

    // Set up the effect.
    effect = new BasicEffect(device);
    effect.World = Matrix.Identity;
    effect.View = view;
    effect.Projection = view * projection;
    effect.VertexColorEnabled = true;
}`

最后，您可以使用与单三角形示例中相同的绘图代码。这是因为您正在执行本质上相同的任务—将顶点缓冲区复制到 GraphicsDevice 并将其呈现为三角形列表:

`private void drawingSurface_Draw(object sender, DrawEventArgs e)
{
    GraphicsDevice device = GraphicsDeviceManager.Current.GraphicsDevice;
    device.Clear(new Color(0, 0, 0));
    device.SetVertexBuffer(vertexBuffer);

    foreach (EffectPass pass in effect.CurrentTechnique.Passes)
    {
        pass.Apply();
        device.DrawPrimitives(PrimitiveType.TriangleList,
          0, vertexBuffer.VertexCount / 3);
    }
}`

这个立方体是一个真正的 3D 物体，尽管当它只是静态场景的一部分时，看起来可能仍然不那么引人注目。但是因为它是一个真实的物体，用相机从不同的有利位置观察它或者旋转它——你将在本章后面看到。

#### 添加纹理

每个像素着色器使用某种公式绘制三角形中的像素。BasicEffect 使用一个相对基本但仍然非常实用的像素着色器，它使用三个顶点为每个像素插值一种颜色。这个过程可以创建有吸引力的阴影，但它并不总是你想要的。

另一个选择是使用一个*纹理*，一个覆盖在 3D 物体上的位图。每一个纹理，因为作为一个 2D 位图-本质上，一个普通的图像文件。但是，当您将 2D 纹理映射到 3D 形状时，它会被拉伸和扭曲以适应形状的轮廓。你可以把它想象成你正在塑造你的形状并用一些塑料薄膜紧紧包裹它(这就是 2D 纹理)。

纹理的基础很简单。在下面的例子中，你将把它应用于立方体，以创建如图 13-11 所示的结果。

   ![images](images/9781430234791_Fig13-11.jpg)

***图 13-11。**一个有纹理的立方体*

第一步是改变你定义顶点的方式。当用颜色给形状加底纹时，使用 VertexPositionColor 类。将纹理应用到形状时，可以用 VertexPositionTextureClass 替换它:

`VertexPositionTexture[] vertices = new VertexPositionTexture[36];`

与 VertexPositionColor 一样，VertexPositionTextureClass 需要一个代表顶点的 Vector3 对象。但是它没有将颜色对象与其耦合，而是将颜色对象与存储在 Vector2 中的纹理坐标匹配。这里有一个例子:

`vertices[0] = new VertexPositionTexture(topRightFront, **new Vector2(1, 0)**);`

乍一看，这似乎有点奇怪。毕竟，您可能希望 VertexPositionTexture 组合一个顶点和某种纹理对象。然而，这并不会发生，因为纹理的工作方式。使用纹理，像立方体这样的单个对象通常会有一个包裹其整个表面的纹理。将顶点与纹理配对是不合适的，因为这会给每个单独的三角形*三个*纹理，这肯定不是你想要的。

那么，纹理坐标的意义是什么？纹理坐标告诉 Silverlight 从哪里开始从纹理中获取图像数据。在前面的示例中，第一个顶点与纹理图像中的点(1，0)配对。纹理坐标使用 0 到 1 的比例，所以点(1，0)实际上代表了纹理的右上角(其中 *x=1* 和 *y=0* )。因此，最终结果是位于立方体正面右上角的第一个顶点被钉在纹理的右上角([图 13-12](#fig_13_12) )。

![images](images/9781430234791_Fig13-12.jpg)

***图 13-12。**纹理坐标*

![images](images/square.jpg) **注意**从技术上来说，纹理坐标使用一种叫做(u，v)系统的东西，其中 u 代表水平，v 代表垂直。这完全对应于(x，y)点，但是名称的变化强调了单位的变化。如您所见，(u，v)点是从 0 到 1 的分数值，它们代表纹理大小的相对百分比，而不是绝对像素尺寸。

用你的顶点排列你的纹理会有点棘手。重要的是，同一个立方体面上的两个相邻三角形将纹理放置在相同的方向上，以便在该面上无缝地绘制图像。为了使这个绘制过程更容易，在开始创建 VertexPositionTexture 对象之前，最好使用 Vector2 对象定义纹理的四个角。

`Vector2 textureTopLeft = new Vector2(0, 0);
Vector2 textureTopRight = new Vector2(1, 0);
Vector2 textureBottomLeft = new Vector2(0, 1);
Vector2 textureBottomRight = new Vector2(1, 1);`

然后，您可以使用这些坐标来构建 VertexPositionTexture 对象，如下所示:

`// The front face.
vertices[0] = new VertexPositionTexture(topRightFront, textureTopRight);
vertices[1] = new VertexPositionTexture(bottomLeftFront, textureBottomLeft);
vertices[2] = new VertexPositionTexture(topLeftFront, textureTopLeft);
vertices[3] = new VertexPositionTexture(topRightFront, textureTopRight);
vertices[4] = new VertexPositionTexture(bottomRightFront, textureBottomRight);
vertices[5] = new VertexPositionTexture(bottomLeftFront, textureBottomLeft);`

这段代码将纹理放置在立方体的一个面上。需要注意的关键细节是两个三角形使用一致的纹理坐标。例如，点 topRightFront 包含在组成边的两个三角形中，两次它都与相同的纹理坐标配对。要查看为立方体的所有六个面创建 VertexPositionTexture 对象的完整代码，请下载本章的示例项目。

一旦使用 VertexPositionTexture 对象定义了所有顶点，就可以用通常的方式创建顶点缓冲区和相机:

`GraphicsDevice device = GraphicsDeviceManager.Current.GraphicsDevice;
vertexBuffer = new VertexBuffer(device, **typeof(VertexPositionTexture)**,
  vertices.Length, BufferUsage.WriteOnly);
vertexBuffer.SetData(0, vertices, 0, vertices.Length, 0);

// (Configure the camera here, using the same code as before.)`

下一步是配置 BasicEffect 对象。这是流程发生变化的地方。与以前不同，您将不再设置基本效果。VertexColorEnabled 属性。相反，您将设置基本效果。TextureEnabled 属性使用 BasicEffect 的内置纹理功能:

`effect = new BasicEffect(device);
effect.World = Matrix.Identity;
effect.View = view;
effect.Projection = view * projection;
effect.TextureEnabled = true;`

现在，您需要加载纹理图像(通常是从项目中的资源中)并使用它来创建 Texture2D 对象。这里涉及到一点杂耍，因为您需要首先将数据从流中取出并放入 BitmapImage，然后将它从 BitmapImage 移动到 Texture2D。最后，通过设置 Texture2D 对象的 Texture 属性，将该对象传递给 BasicEffect:

`// Load the texture from a resource, and place it in a BitmapImage.
string uri = "Silverlight3D;component/mayablur.jpg";
Stream s = Application.GetResourceStream(new Uri(uri, UriKind.Relative)).Stream;
BitmapImage bmp = new BitmapImage();
bmp.SetSource(s);

// Copy the BitmapImage data into a Texture2D object.
Texture2D texture;
texture = new Texture2D(device, bmp.PixelWidth, bmp.PixelHeight);
bmp.CopyTo(texture);

// Set the texture.
effect.Texture = texture;`

最后一步是通过添加以下语句来调整绘图代码:

`private void drawingSurface_Draw(object sender, DrawEventArgs e)
{
    GraphicsDevice device = GraphicsDeviceManager.Current.GraphicsDevice;
**    device.SamplerStates[0] = SamplerState.LinearClamp;**
    …`

这允许 XNA 映射任何纹理图形。不使用 SampleState。LinearClamp，你的纹理图形需要有 2 的幂的像素尺寸。(例如，有效的纹理图形将包括 2x2、4x4、8x8、32x32 等等的图像，但不包括 40x40 的图像)。使用 SampleState 时。LinearClamp，这个尴尬的限制消失了。

其余的绘图代码保持不变。它仍然使用 DrawPrimitives()方法呈现三角形列表。唯一的区别是，BasicEffect 对象现在配置为使用纹理:

`    …
    device.Clear(new Color(0, 0, 0));
    device.SetVertexBuffer(vertexBuffer);

    foreach (EffectPass pass in effect.CurrentTechnique.Passes)
    {
        pass.Apply();
        device.DrawPrimitives(PrimitiveType.TriangleList,
          0, vertexBuffer.VertexCount / 3);
    }
}`

**映射纹理的不同部分**

你不需要使用纹理的全部。例如，考虑一下，如果在纹理坐标中用 0.5 替换每次出现的 1，会有什么好处:

`Vector2 textureTopLeft = new Vector2(0, 0);
Vector2 textureTopRight = new Vector2(0.5f, 0);
Vector2 textureBottomLeft = new Vector2(0, 0.5f);
Vector2 textureBottomRight = new Vector2(0.5f, 0.5f);`

现在，你的立方体将抓取图像右上角的四分之一，并将其用于每一面，如图 13-13 所示。这是因为 *x=0.5* 代表水平 x 轴中间的一点，而 *y=0.5* 代表垂直 y 轴中间的一点。

如果您想在立方体的每一侧显示不同的图像，这种技术也提示了解决方案。在这种情况下，你只需要将所有的图片合并成一个大的纹理图形。然后，您可以使用纹理坐标来抓取图像中要用于每一面的部分。

![images](images/9781430234791_Fig13-13.jpg)

***图 13-13。**使用纹理的一部分*

#### 照亮一个物体

到目前为止，您已经看到了如何使用 BasicEffect 类给形状着色或用纹理包裹它。然而，还有另一个选择:你可以使用照明来给你的物体有吸引力的，真实的阴影。

照明背后的基本原理是你在三维场景中打开一个或多个光源。然后根据这些光源的位置和颜色照亮您的对象。

在你深入研究照明之前，重要的是你要认识到 Silverlight 照明模型的行为不像真实世界中的光。尽管照明系统是为了模拟真实世界而构建的，但计算真实的光线反射是一项处理器密集型任务。出于这个原因，Silverlight 进行了大量的简化，包括:

*   为对象*单独计算光效*。从一个物体反射的光不会被另一个物体反射。同样，一个物体不会在另一个物体上投射阴影，不管它被放在哪里。
*   在每个三角形的顶点处计算照明，然后在三角形的表面上进行插值。(换句话说，Silverlight 确定每个角的光强度，并将其混合以填充三角形。)作为这种设计的结果，具有相对较少三角形的物体可能不能被正确照明。为了获得更好的照明，你需要把你的形状分成成百上千个三角形。

Silverlight 支持两种类型的灯光。环境光是向各处辐射并且同等地照亮每个形状的光。平行光是向特定方向辐射的光，照亮面向它的表面。结合环境光和一个或多个平行光是 3D 场景制作艺术的一部分。

那么如何给场景添加灯光呢？最简单但最不引人注目的方法是简单地设置 BasicEffect 对象的 AmbientLightColor 和 LightingEnabled 属性。首先，设置 AmbientLightColor 来选择灯光的色偏。这里有一道强烈的红光:

`effect.AmbientLightColor = new Vector3(1, 0, 0);`

奇怪的是，照明颜色是使用 Vector3 类型而不是 Color 类型设置的。您仍然使用熟悉的颜色组件(红色、绿色和蓝色，按此顺序)，但是您将每个组件指定为从 0 到 1 的分数值。在前面的示例中，红色通道是 1(完全红色)，而绿色和蓝色通道是 0。这相当于 RGB 符号中的颜色 255，0，0。

第二步是将 LightingEnabled 设置为 true。这使照明系统生效:

`effect.LightingEnabled = true;`

如果你用纹理立方体的例子来尝试这个，你会发现表面有一种更淡的红色。

环境照明是最没意思的一种照明，因为它同等地照亮一切。在立方体的例子中，你可以在没有光照的情况下得到完全相同的效果，只需要用红色的纹理替换立方体。

定向照明要有趣得多。例如，考虑[图 13-14](#fig_13_14) ，它显示了由几个平行光照亮的立方体。这创造了一个丰富的细节阴影效果。

![images](images/9781430234791_Fig13-14.jpg)

***图 13-14。**带灯光的纹理立方体*

更好的是，这种类型的照明是动态的。例如，如果用户移动页面底部的滑块来旋转立方体，光线会平滑地穿过表面，照亮不同的区域并产生不同的眩光点，就像真实的光线一样。(在本章的稍后部分，您将了解如何执行此滑块使用的旋转。)

要创建这种照明效果，必须设置 BasicEffect 对象提供的几个附加照明属性。除了局限于 AmbientLightColor，还可以设置 DirectionalLight0、DirectionalLight1 和 DirectionalLight2 属性，这些属性为您提供了三种照亮场景的灯光。每个平行光都有自己的方向和两种颜色:一种*漫反射*颜色(当光线以一定角度照射到某个形状的表面时使用)，一种*镜面反射*颜色(当光线正好照射到某个表面时使用)。通常，您将使用高光颜色来创建闪亮的眩光效果。

起初，调整所有这些照明属性可能有点让人不知所措。但是再一次，BasicEffect 对象可以帮你解决这个问题。它包括一个名为 EnableDefaultLighting()的方法:

`effect.EnableDefaultLighting();`

当您调用此方法时，BasicEffect 会打开其环境光和平行光光源，定位平行光，并为所有光源赋予略微不同的漫反射和镜面反射颜色，而不需要任何额外的代码行。对于您的 3D 对象，这有点像步入一个光线充足的肖像工作室。事实上，EnableDefaultLighting()方法用于创建图 13-14 中的复杂照明。

如果你想进一步调整你的照明，知道 EnableDefaultLighting()实际上做什么是有帮助的。下面是它在幕后运行的代码:

`effect.AmbientLightColor = new Vector3(0.053f, 0.098f, 0.181f);
effect.SpecularColor = new Vector3(0, 0, 0);
effect.DiffuseColor = new Vector3(0.64f, 0.64f, 0.64f);

effect.DirectionalLight0.Enabled = true;
effect.DirectionalLight0.DiffuseColor = new Vector3(1f, 0.96f, 0.81f);
effect.DirectionalLight0.Direction = new Vector3(-0.52f, -0.57f, -0.62f);
effect.DirectionalLight0.SpecularColor = new Vector3(1f, 0.96f, 0.81f);

effect.DirectionalLight1.Enabled = true;
effect.DirectionalLight1.DiffuseColor = new Vector3(0.96f, 0.76f, 0.40f);
effect.DirectionalLight1.Direction = new Vector3(0.71f, 0.34f, 0.60f);
effect.DirectionalLight1.SpecularColor = new Vector3(0f, 0f, 0f);

effect.DirectionalLight2.Enabled = true;
effect.DirectionalLight2.DiffuseColor = new Vector3(0.32f, 0.36f, 0.39f);
effect.DirectionalLight2.Direction = new Vector3(0.45f, -0.76f, 0.45f);
effect.DirectionalLight2.SpecularColor = new Vector3(0.32f, 0.36f, 0.39f);`

不幸的是，要创建一个合适的光照场景，就像图 13-14 中的场景，你还需要配置你的形状的顶点。问题是 Silverlight 需要更多的信息来计算光照如何照亮每个顶点。

就其本身而言，顶点只是空间中的一个点。Silverlight 并不关注一个顶点与其周围其他顶点的连接方式，因为那种光照计算太复杂了。相反，Silverlight 需要你提供一个*法向量*,告诉它相应表面的方向。面对光源的表面会比部分或完全背离光源的表面捕捉到更多的光。

通常，法向量与你的表面成直角。所以在立方体的例子中，左侧的所有顶点都有指向左侧的法向量。[图 13-15](#fig_13_15) 说明了。

![images](images/9781430234791_Fig13-15.jpg)

***图 13-15。**立方体中的法向量*

为了在代码中获取这些信息，需要用 VertexPositionNormalTexture 对象替换 VertexPositionTexture 对象。不同之处在于，每个 VertexPositionNormalTexture 对象都包含一个法线向量，如下所示:

`Vector3 vector = new VertexPositionNormalTexture(
  topRightFront, **normal**, textureTopRight);`

一旦你理解了什么是法向量，重建立方体就很容易(但是很乏味)。首先，您需要定义指向适当方向的法向量，远离每一边:

`Vector3 frontNormal = new Vector3(0, 0, 1);
Vector3 backNormal = new Vector3(0, 0, -1);
Vector3 topNormal = new Vector3(0, 1, 0);
Vector3 bottomNormal = new Vector3(0, -1, 0);
Vector3 leftNormal = new Vector3(-1, 0, 0);
Vector3 rightNormal = new Vector3(1, 0, 0);`

然后，在定义立方体的边时使用这些法线。下面是重新编写的定义正面的代码:

`vertices[0] = new VertexPositionNormalTexture(
  topRightFront, frontNormal, textureTopRight);
vertices[1] = new VertexPositionNormalTexture(
  bottomLeftFront, frontNormal, textureBottomLeft);
vertices[2] = new VertexPositionNormalTexture(
  topLeftFront, frontNormal, textureTopLeft);
vertices[3] = new VertexPositionNormalTexture(
  topRightFront, frontNormal, textureTopRight);
vertices[4] = new VertexPositionNormalTexture(
  bottomRightFront, frontNormal, textureBottomRight);
vertices[5] = new VertexPositionNormalTexture(
  bottomLeftFront, frontNormal, textureBottomLeft);`

不需要其他更改。一旦你的形状有了合适的法线，你就可以通过 BasicEffect 对象应用任何你想要的光照效果。

#### 创建多个对象

当你创建一个稍微复杂的 3D 对象时，比如前面例子中的纹理立方体，你需要管理大量的细节和代码。到目前为止，您看到的示例都将该表单放在表示页面的用户控件中。然而，一个更好的位置是一个专门的类，它包装了所有的绘图逻辑，并提供了对您想要调整的属性的简单访问。这种设计不仅简化了代码，还使得在同一个 3D 场景中使用一个对象的多个副本变得容易。

例如，考虑纹理立方体的例子。您可以将它的所有绘图细节移动到一个专用的类中，如下面概述的 Cube3D 类:

`public class Cube3D
{
    // Store the vertex buffer and effect internall.
    private VertexBuffer vertexBuffer;
    private BasicEffect effect;

    // Allow the code using the Cube3D to change its world matrix`
`    // (to move or rotate the object).
    public Matrix World
    {
        get { return effect.World; }
        set { effect.World = value; }
    }

    // Allow the code using the Cube3D to change its view matrix
    // (to move or rotate the camera).
    public Matrix View
    {
        get { return effect.View; }
        set { effect.View = value; }
    }

    // Allow the code using the Cube3D to change its view projection
    // (to change the aspect ratio if the DrawingSurface size changes).
    public Matrix Projection
    {
        get { return effect.Projection; }
        set { effect.Projection = value; }
    }

    // (Constructors go here.)
    // (Drawing code goes here.)
}`

Cube3D 类公开了三个矩阵，您可能需要在代码中操作它们来添加交互性或动画。支撑顶点缓冲区和基本效果对象的其他细节被隐藏起来。

Cube3D 类包括两个构造函数。它们都接受一些关键的细节:要使用的 GraphicsDevice、放置立方体左下角的 Vector3 对象、立方体应该具有的宽度、纹理的 URI 以及 DrawingSurface 的纵横比。第二个构造函数也接受放置摄像机的视图矩阵。第一个构造函数不需要——它只是调用第二个构造函数，其中包含所有细节和一个硬编码的默认视图矩阵:

`public Cube3D(GraphicsDevice device, Vector3 bottomLeftBack, float width,
  string textureUri, float aspectRatio)
  : this(device, bottomLeftBack, width, textureUri, aspectRatio,
  Matrix.CreateLookAt(new Vector3(0, 0, 5), Vector3.Zero, Vector3.Up))
{
    // No code is required, because this constructor calls the second
    // constructor, which does all the work.
}

public Cube3D(GraphicsDevice device, Vector3 bottomLeftBack, float width,
  string textureUri, float aspectRatio, Matrix view)
{
    // (Initialization code goes here.)
}`

第二个构造函数包含先前放在 PrepareDrawing()方法中的代码。唯一的区别是代码稍微做了一些调整，以使用传入的构造函数参数。例如，所有顶点都是根据立方体的左下角和指定的宽度定义的:

`Vector3 topLeftFront = new Vector3(
  bottomLeftBack.X, bottomLeftBack.Y + width, bottomLeftBack.Z + width);
Vector3 bottomLeftFront = new Vector3(
  bottomLeftBack.X, bottomLeftBack.Y, bottomLeftBack.Z + width);
Vector3 topRightFront = new Vector3(
  bottomLeftBack.X + width, bottomLeftBack.Y + width, bottomLeftBack.Z + width);
Vector3 bottomRightFront = new Vector3(
  bottomLeftBack.X + width, bottomLeftBack.Y, bottomLeftBack.Z + width);
Vector3 topLeftBack = new Vector3(
  bottomLeftBack.X, bottomLeftBack.Y + width, bottomLeftBack.Z);
Vector3 topRightBack = new Vector3(
  bottomLeftBack.X + width, bottomLeftBack.Y + width, bottomLeftBack.Z);
Vector3 bottomRightBack = new Vector3(
  bottomLeftBack.X + width, bottomLeftBack.Y, bottomLeftBack.Z);`

接下来，创建顶点缓冲区，使用指定的纵横比和视图创建相机，并使用指定的资源 URI 加载纹理，如您之前所见。

Cube3D 类还包含一个公共 Draw()方法，应用程序可以调用该方法将立方体呈现到绘图表面。当调用 Draw()时，代码只是传入适当的 GraphicsDevice，其余的按通常的方式展开:

`public void Draw(GraphicsDevice device)
{   
    device.SetVertexBuffer(vertexBuffer);
    device.SamplerStates[0] = SamplerState.LinearClamp;

    foreach (EffectPass pass in effect.CurrentTechnique.Passes)
    {
        pass.Apply();
        device.DrawPrimitives(PrimitiveType.TriangleList,
          0, vertexBuffer.VertexCount / 3);
    }
}`

现在，您已经完成了将绘图代码移动到一个单独的类中的工作，您将在您的用户控件中获得整洁的事件处理代码。下面的示例演示了如何使用 Cube3D 类的三个实例来创建三个多维数据集，每个多维数据集位于不同的位置，具有不同的大小。代码简洁明了:

`public partial class MultipleCubes : UserControl {
    private Cube3D cube;
    private Cube3D cube2;
    private Cube3D cube3;

    public MultipleCubes()
    {
        InitializeComponent();

        GraphicsDevice device = GraphicsDeviceManager.Current.GraphicsDevice;
        string uri = "Silverlight3D;component/mayablur.jpg";`

`        // Create a view that all three cubes will share.
        Matrix view = Matrix.CreateLookAt(new Vector3(1, 1, 3), Vector3.Zero,
          Vector3.Up);

        // Create the three cubes.
        cube = new Cube3D(device, new Vector3(-1,-1,-1), 2, uri, 1.33f, view);
        cube2 = new Cube3D(device, new Vector3(-2, -2, 1), 1.5f, uri, 1.33f, view);
        cube3 = new Cube3D(device, new Vector3(-5, -2, -2.5f), 2, uri, 1.33f, view);
    }

    private void drawingSurface_Draw(object sender, DrawEventArgs e)
    {
        GraphicsDevice device = GraphicsDeviceManager.Current.GraphicsDevice;

        // Clear the DrawingSurface.
        device.Clear(new Color(0, 0, 0));

        // Ask all three cubes to draw themselves.
        cube.Draw(device);
        cube2.Draw(device);
        cube3.Draw(device);
    }
}`

[图 13-16](#fig_13_16) 显示了结果。

![images](images/9781430234791_Fig13-16.jpg)

***图 13-16。**绘制一个对象的多个副本*

#### 使用模型

到目前为止，你已经花了很多时间在非常简单的几何图形上，比如一个平面三角形和 3D 立方体。但是真实的 3D 场景通常涉及*成千上万*个三角形，这些三角形被组装成复杂的物体。有三种方法可以创建这样的对象:

*   手动:这是你目前为止采用的方法，但是对于更复杂的对象来说，它很快变得不切实际。事实上，如果你依赖一组手写的顶点，你不太可能构建比立方体更复杂的东西。但是，使用别人现成的 3D 类，你可能会获得更多的里程。这些类可以封装冗长的代码细节，如 Cube3D 示例中所示。尽管如此，还是需要有人来编写代码，而且这不是一件小事。
*   *用代码(算法上)*:用这种方法，你使用循环和计算的组合来构建一个形状。例如，您可以编写代码，用数百个三角形创建一个球体，尽管您可能需要提高数学技能才能正确完成。将动态数据映射到 3D 内容时通常使用这种方法，例如，如果您正在构建一个绘制从 web 服务检索的科学结果的 3D 图表工具。
*   *用设计工具*:用这种方法，你用 3D 建模程序准备你的 3D 物体。这里不缺乏选择，包括像 3ds Max 和 Maya 这样非常昂贵的工具，以及完全免费且功能惊人的 Blender ( `[www.blender.org](http://www.blender.org)`)。一旦完善了 3D 模型，就可以将其导出到文件中，导入到 Silverlight 应用程序中，并使用熟悉的技术(如世界矩阵、视图矩阵和投影矩阵)对其进行操作。

第三种选择——使用设计工具创建模型——显然是大多数人的最爱。然而，有一个问题。Silverlight 中的 3D 支持没有直接加载模型的能力，因为它缺少完整 XNA 平台中的内容管道。尽管许多有事业心的编码员正忙着填补空白，但解决方案还没有完全到位。两个最好的选择是建立在 Silverlight 3D 支持之上的更高级的开源框架:Babylon ( `[http://babylontoolkit.codeplex.com](http://babylontoolkit.codeplex.com)`)和巴尔德(`[http://balder.codeplex.com](http://balder.codeplex.com)`)。这两个框架都是为 Silverlight 的早期版本开发的，它们提供了软件渲染的 3D。现在，他们通过 Silverlight 的硬件加速 3D 提供了同样出色的功能。问题是，在撰写本文时，这两个工具包都没有发布。

### 运动和动画

如果您使用 DrawingSurface 控件只绘制静态场景，您将错过 Silverlight 3D 的真正优势。当你开始抓住你的物品并移动它们时，生活变得有趣多了。

将 3D 渲染与动画结合有很多原因。也许你只是想让用户把一个物体转过来，从不同的角度看它。或者，您可能计划构建一个完整的第一人称游戏，让用户在虚拟世界中漫游。无论哪种方式，您都从相同的基本构建块开始，您将在下面的部分中了解这些构建块。

#### 移动一个形状

移动或旋转任何形状的诀窍是改变世界矩阵，无论是单个三角形、相对简单的纹理立方体还是从 3D 设计工具导入的完整模型。

在你已经看到的例子中，世界矩阵(在基础效果中设置。世界属性)被设置为单位矩阵:

`effect.World = Matrix.Identity;`

这意味着世界矩阵没有做任何事情。但是考虑一下这个更有趣的代码:

`Matrix translation = Matrix.CreateTranslation(-2, 0, 0);
effect.World = effect.World * translation;`

在这里，世界矩阵被一个*平移*所改变。平移是将对象的坐标移动您指定的量的操作。在这种情况下，平移将对象向左移动两个单位(因为*x*-坐标是-2)，但不改变 y 或 z 坐标。

![images](images/square.jpg) **注意**记住，3D 场景不使用物理单位(比如像素)。当你移动一个物体-2 到一边时，你可以移动它一小段距离或一大段距离。这只取决于你把相机放得有多近，以及它的视野有多大。

翻译非常容易应用。黑客帝国。CreateTranslation()方法生成你需要的变换矩阵。然后，通过将世界视图矩阵与矩阵相乘，将其应用于对象。

你不需要担心在幕后计算坐标的矩阵数学。但是，您需要意识到这一点:

`effect.World = effect.World * translation;`

不等同于此:

`effect.World = translation * effect.World;`

矩阵乘法是不可交换的，所以执行乘法的顺序很重要。总是从世界矩阵开始，然后是翻译。为方便起见，您可以使用*=运算符快捷方式:

`effect.World *= translation;`

还有一个你不想犯的错误:

`effect.World = translation;`

这种说法实际上*取代了*世界矩阵，而不是对其进行变换。

最后，你应该意识到你在世界矩阵上执行的变换是*累积的*。这意味着你可以这样做:

`Matrix translation = Matrix.CreateTranslation(-2, 0, 0);
effect.World *= translation;
translation = Matrix.CreateTranslation(0, 5, 0);`
`effect.World *= translation;
translation = Matrix.CreateTranslation(-1, 0, 0);
effect.World *= translation;`

一个接一个地应用三种翻译。就像你会用这个简单的翻译一样:

`Matrix translation = Matrix.CreateTranslation(-3, 5, 0);
effect.World = effect.World * translation;`

您可以将世界矩阵视为迄今为止应用于对象的所有变换的快照。常见的变换包括您刚刚看到的平移操作，以及接下来要讨论的旋转。

#### 旋转形状

Matrix 类提供了一个允许移动对象的 CreateTranslation()方法，它也包含了旋转对象的方法。但是因为旋转有点复杂，有几种方法可以使用，如[表 13-3](#tab_13_3) 所列。

![images](images/9781430234791_tab13-03.jpg)

如果你对在三维空间中可视化旋转有任何困难，图 13-17 会让你明白。

![images](images/9781430234791_Fig13-17.jpg)

***图 13-17。**三维旋转一个物体*

下面是一个应用 1/8 圆周小旋转的示例:

`// There are 2*Pi radians in a circle. So this rotation is 1/8 of that:
Matrix rotation = Matrix.CreateRotationY(MathHelper.PiOver4);
effect.World *= rotation;`

与平移一样，通过乘以世界矩阵来应用旋转。

还有一个细节需要考虑:你的物体和轴之间的距离。例如，如果 y 轴正好穿过对象的中间，用 CreateRotationY()创建的旋转将使其旋转，同时保持在同一位置。但是如果你的物体偏离了 y 轴，CreateRotationY()会让它绕着 y 轴移动，就像行星绕着太阳转一样。[图 13-18](#fig_13_18) 说明了不同之处。(为了帮助形象化这个例子，请记住 z 轴指向页面之外，围绕 z 轴旋转会使图像围绕这条假想线旋转。)

![images](images/9781430234791_Fig13-18.jpg)

***图 13-18。**绕 z 轴旋转物体，两种方式*

为了确保你得到你想要的结果，你需要考虑你放置对象的位置和移动对象的时间。例如，假设您想围绕一个对象的中心点旋转该对象，然后将其移动到一个新位置。要获得您想要的结果，您必须首先将形状放在您要绕其旋转的轴上。

例如，如果您想要围绕 z 轴完美地旋转一个形状，z 轴必须穿过形状的中间。因此，将形状的中心点放在原点(0，0，0)通常是最容易的。

当您准备好应用变换时，首先应用旋转。然后，您可以应用平移将您的形状移动到适当的位置。或者你可以一步到位，就像这样:

`effect.World = effect.World * rotation * translation;`

但是请记住，这有不同的效果:

`effect.World = effect.World * translation * rotation;`

它首先用平移移动形状，然后围绕(现在距离)轴线旋转它。

![images](images/square.jpg) **注意**Matrix 类提供了另外一个转换函数，名为 CreateScale()。它允许你改变对象的比例，缩小或放大它。还可以使用 CreateScale()的不同重载沿 x、y 或 z 轴不成比例地缩放对象。例如，您可以将对象拉伸两倍宽(在 x 维度上)和三倍高(在 y 维度上)，同时保持其厚度不变(在 z 维度上)。

#### 形状动画

现在你知道了创建一个动画形状所需要的一切。第一步是通过将该语句添加到 DrawingSurface 的末尾，确保您的绘图逻辑连续运行。绘制事件处理程序:

`e.InvalidateSurface();`

现在您只需要在每次 Draw 事件触发时应用一个旋转。

还有一个考虑。您需要确定每次触发 Draw 事件时旋转形状的角度。这应该是一个较小的弧度数，通常是 MathHelper.PiOver4 的一小部分。但是，不同的视频卡会以不同的速度执行绘图代码。为了确保每个人的计算机上的旋转速度相同，您需要将旋转量与后续绘制事件之间的时间间隔联系起来。这样，每秒能够绘制更多帧的快速视频卡将在每帧中旋转形状较小的量，而较慢的视频卡将旋转形状较大的量以弥补时间延迟，并且旋转速度在每个人的计算机上都是一致的。

DrawEventArgs 对象提供了两个属性，可以帮助您在动画中使用计时信息。TotalTime 属性以 TimeSpan 对象的形式返回自应用程序启动以来经过的总时间。更有用的是，DeltaTime 属性返回自上一个 Draw 事件被触发以来所经过的时间的 TimeSpan(从技术上讲，它是本次 Draw 记录的总时间与上一个 Draw 事件开始时记录的总时间之间的差值)。下面是一个使用 DeltaTime 缓慢旋转纹理立方体的事件处理程序:

`private void drawingSurface_Draw(object sender, DrawEventArgs e)
{
    GraphicsDevice device = GraphicsDeviceManager.Current.GraphicsDevice;
    device.Clear(new Color(0, 0, 0));

    // Spin the cube.
    Matrix rotation = Matrix.CreateRotationY(
      MathHelper.PiOver4 * (float)e.DeltaTime.TotalMilliseconds / 2000f);
    cube.World = cube.World * rotation;                
    cube.Draw(device);

    // Keep the drawing surface updated.
    e.InvalidateSurface();
}`

要查看这个旋转立方体的运行情况，请参考本章的示例代码。

#### 旋转和移动摄像机

你在这一章要处理的最后一个任务是创建一个“第一人称”相机，用户可以用键盘移动和定位。这是一个比旋转场景中的对象更复杂的任务，因为相机不是一个独特的对象，它没有自己的世界矩阵。相反，它是通过视图的属性来修改的。

图 13-19 显示了完成的例子。这里，DrawingSurface 包括两种形状:熟悉的纹理形状和灰色的“地板”，它是由两个非常大的三角形构成的。使用箭头键，用户可以转动和接近立方体，走过它，转身再次看到它，等等。事实上，因为启用了背面剔除，你甚至可以让*走进*立方体，从里面查看(图 13-19，底部)。当这一切发生时，立方体继续旋转——除非用户点击按钮停止它。

![images](images/9781430234791_Fig13-19.jpg)

***图 13-19。**绕着一个立方体行走*

为了创建这个例子，首先需要添加三个跟踪摄像机信息的 Vector3 字段。你已经知道了摄像机的位置和摄像机的目标，这两个信息是你用来创建矩阵视图的。CreateLookAt()方法。此外，这段代码还添加了一个 cameraLook 向量，该向量指示摄像机正在观察的方向。

`// The position of the camera.
// Initially, it starts almost at the origin.
private Vector3 cameraPosition = new Vector3(0, 0, 0.01f);

// The direction the camera is looking.
// Initially, it looks down the z-axis line, into the front of the scene.
private Vector3 cameraLook = new Vector3(0,0,-1);

// The combination of the camera's position and its look direction.
private Vector3 cameraTarget;`

cameraLook 和 cameraTarget 之间的区别很微妙但很重要。cameraTarget 是摄像机正在观察的*点*。相机看起来是相机正在看的*方向*。这里重要的细节是，如果你把 cameraPosition 和 cameraLook 向量加在一起，你就得到 cameraTarget，如图[图 13-20](#fig_13_20) 所示。

![images](images/9781430234791_Fig13-20.jpg)

***图 13-20。**计算摄像机目标*

加载该页面时，构造函数创建视图、立方体和地板:

`Matrix view = Matrix.CreateLookAt(cameraPosition, cameraTarget, Vector3.Up);            

// The cube is positioned carefully, so that the y-axis runs through the middle,
// allowing it to spin in place.
cube = new Cube3D(device, new Vector3(-1, -1, -1), 2, uri, 1.33f, view);
floor = new Floor3D(device, 1.33f, view);

// Walk the camera back so the scene is visible.
cameraPosition -= cameraLook * 6;`

这里唯一不同寻常的细节是摄像机首先被放在原点，*然后*向后移动 6 个单位。这允许代码首先旋转摄像机(在原点)，然后将其移动到适当的位置。否则，如果您首先移动相机，它将在旋转时绕 y 轴旋转。

绘图代码负责在渲染场景之前，将 cameraPosition 和 cameraLook 组合在一起，将相机放置在正确的位置。下面是完整的 Draw 事件处理程序:

`private bool rotate = true;

private void drawingSurface_Draw(object sender, DrawEventArgs e)
{
    GraphicsDevice device = GraphicsDeviceManager.Current.GraphicsDevice;
    device.Clear(new Color(0, 0, 0));

    // This allows you to see the inside of the cube when you pass into it.
    device.RasterizerState = new RasterizerState()
    {
        CullMode = CullMode.None
    };

    // Spin the cube.
    if (rotate)
    {
        Matrix rotation = Matrix.CreateRotationY(
          MathHelper.PiOver4 * (float)e.DeltaTime.TotalMilliseconds / 2000f);
        cube.World = cube.World * rotation;                
    }

    // Create the view for the current camera position and direction.
    cameraTarget = cameraPosition + cameraLook;
    Matrix view = Matrix.CreateLookAt(cameraPosition, cameraTarget, Vector3.Up);                         
    cube.View = view;
    floor.View = view;

    // Draw the shapes.
    floor.Draw(device);
    cube.Draw(device);

    // Keep the drawing surface updated.
    e.InvalidateSurface();
}`

您会注意到，只有当 rotate 标志为 true 时，绘图代码才会旋转立方体。有一个按钮可以让用户翻转这个标志，并随时停止或开始旋转:

`private void cmdToggleRotate_Click(object sender, RoutedEventArgs e)
{
    rotate = !rotate;
}`

本例中真正的神奇之处发生在用户控件的 KeyDown 事件处理程序中。在这里，箭头键被拦截，相机相应地调整。如果按下向上或向下键，摄像机将向前或向后移动一小段 cameraLook。类似地，当按下左键或右键时，一个分数旋转被应用到 cameraLook 向量，从一边到另一边扭曲它。

`private void UserControl_KeyDown(object sender, KeyEventArgs e)
{
    Matrix rotation = Matrix.Identity;
    switch (e.Key)
    {
        case Key.Up:
            cameraPosition += cameraLook * 0.08f;
            break;
        case Key.Down:
            cameraPosition -= cameraLook * 0.08f;
            break;                
        case Key.Left:                                       
            rotation = Matrix.CreateRotationY(MathHelper.PiOver4 * 0.08f);
            cameraLook = Vector3.Transform(cameraLook, rotation);
            break;
        case Key.Right:
            rotation = Matrix.CreateRotationY(MathHelper.PiOver4 * -0.08f);
            cameraLook = Vector3.Transform(cameraLook, rotation);
            break;
    }
    // Apply the new rotation, if one was created.
    cube.View *= rotation;
}`

旋转或移动的实际量取决于您希望移动的平滑程度和速度。在这个例子中，因子 0.08 给出了一个很好的折衷，具有快速但不急动的运动。然而，这个数字是通过纯粹的反复试验决定的。

虽然这个例子相对简单，但通过在 3D 场景中添加更多的对象并让用户在整个场景中漫步，很容易对其进行扩展。

### 最后一句话

当 WPF 推出其 3D 模型时，它的适合度和光洁度令人印象深刻。有一系列有用的便利，包括点击测试支持，在 3D 对象上放置交互式 2D 控件的能力，用于操纵形状和移动相机的集成动画，甚至还有一些方便的代码，让用户用鼠标旋转 3D 对象。相比之下，Silverlight 的 3D 功能是强大功能和轻微笨拙的混合。Silverlight 的创建者没有创建一个新的、真正集成 Silverlight 的方法，而是在 Silverlight 宇宙中嵌入了一个强大的微软 XNA，粗糙的边缘显露出来。但结果是——浏览器中真正的硬件加速 3D——绝对是革命性的。

将你在本章中学到的 3D 基础知识用于构建一个实际的 3D 应用程序并不容易。要达到这个目标，你有两个选择:

> *使用工具包*:你可以使用一个基于 Silverlight 3D 支持的工具包，但是增加了一些关键特性，比如从 3D 设计工具导入模型的能力。两个最好的框架是巴尔德(`[http://balder.codeplex.com](http://balder.codeplex.com)`)和巴比伦(`[http://babylontoolkit.codeplex.com](http://babylontoolkit.codeplex.com)`)。
> 
> *自己动手*:你的另一个选择是从零开始构建你需要的东西，前提是你有足够的数学技能和痛苦阈值来实现它。你可以通过一本关于 XNA 的书来磨练你的技能，比如*学习 XNA 4.0* (亚伦·里德)。虽然不是所有的材料都适用于 Silverlight(因为 Silverlight 只支持 XNA 的一个子集)，但大部分都适用。您还将学习其他非特定技术的重要游戏编程技能，例如如何执行碰撞检测、添加人工智能以及创建基于物理的效果。