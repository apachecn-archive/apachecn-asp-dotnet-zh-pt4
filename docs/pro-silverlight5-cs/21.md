## 21

## 数据控制

到目前为止，您已经学习了如何使用数据绑定从数据对象中提取信息，对其进行格式化，并使其可供编辑。然而，尽管数据绑定是一个灵活而强大的系统，但要得到您想要的结果仍然需要做大量的工作。例如，典型的数据表单需要将许多不同的属性绑定到不同的控件，以有意义的方式排列它们，并使用适当的转换器、模板和验证逻辑。创建这些组件和其他类型的 UI 设计一样耗时。

Silverlight 提供了几个有助于减轻部分工作负担的特性:

*   *标签和描述查看器控件*:它们从数据对象中提取元数据，并自动显示在页面中。
*   *数据注释*:最初由 ASP.NET 动态数据引入，它们允许你在数据类中嵌入验证规则。将数据批注与 ValidationSummary 控件配对，以便于在页面中列出所有验证错误。
*   DataGrid 控件:它是 Silverlight 丰富数据支持的核心——一个高度可定制的行列表，支持排序、编辑、分组和(在 DataPager 的帮助下)分页。
*   TreeView 控件 : Silverlight 的层次树并不局限于数据绑定，也不支持编辑。然而，在处理分层数据时，例如包含嵌套产品列表的类别列表时，它是一个真正的节省时间的工具。
*   PivotViewer 控件 : Silverlight 最奇怪的数据控件是一个带有内置动画的奇特切片数据可视化工具。它高度专业化的本质意味着它不适合大多数应用程序，但是那些可以使用它的人将享受高级功能而无需低级编码。

在这一章中，你将学习如何扩展你在前一章学到的数据绑定基础知识。您还将了解如何跨越巨大的 web 服务鸿沟传递智能数据对象，以便相同的元数据和验证逻辑可用于服务器端 ASP.NET 代码和客户端 Silverlight 应用程序。

![images](images/square.jpg) **新增功能** Silverlight 5 在核心框架中增加了新版本的 PivotViewer 控件。以前，PivotViewer 只能通过 Silverlight 控件工具包获得，其编程模型略有不同。为了加快速度，请查看本章末尾的“数据透视查看器”一节。

### 更好的数据形式

在前一章中，您学习了如何使用数据绑定来构建基本的数据表单。这些表单(本质上是由文本框和其他绑定控件组成的普通页面)允许用户输入、编辑和查看数据。最重要的是，它们需要相对较少的代码。

但是现实并不像看起来那么完美。要构建数据表单，您需要相当多的手写 XAML 标记，其中必须包括硬编码的细节，如标题文本、提示和错误消息。管理所有这些细节可能是一件非常令人头疼的事情，尤其是在数据模型频繁变化的情况下。更改数据库，您将被迫更改您的数据类*和*您的用户界面 Visual Studio 的编译时错误检查无法捕捉无效绑定或过时的验证规则。

出于这些原因，Silverlight 的创建者正在努力构建更高级别的数据控件、助手类，甚至是整个基于服务器的数据管理框架(即将推出的 RIA 服务)。尽管这些功能仍在快速发展，但一些组件已经融入了 Silverlight 平台。在接下来的部分中，您将看到其中的三个 Label、DescriptionViewer 和 validation summary——如何使构建丰富的数据表单变得更加容易，特别是当您将它们与强大的*数据注释*功能结合使用时。

![images](images/square.jpg) **注意**要访问 Label、DescriptionViewer 和 ValidationSummary 控件，必须添加对 System.Windows.Controls.Data.Input.dll 程序集的引用。如果从工具箱中添加这些控件中的一个，Visual Studio 将添加程序集引用并映射命名空间，如下所示:`**xmlns:dataInput="clr-namespace:System.Windows.Controls;assembly=System.Windows.Controls.Data.Input"**`

#### 目标:数据类标记

虽然您可以单独使用 Label、DescriptionViewer 和 ValidationSummary，但是当您将它们与 *smart* 数据类一起使用时，它们最大的优势就会显现出来，这些数据类使用一小组属性来嵌入额外的信息。这些属性允许您将与数据相关的详细信息(如属性描述和验证规则)移动到数据类中，而不是强制您将它们包含在页面标记中。

基于属性的方法有几个好处。首先，它是一个令人印象深刻的省时工具，可以让您更快地构建数据表单。第二，也是更重要的一点，它使你的应用程序更容易维护，因为你可以保持数据细节正确地同步。例如，如果底层数据模型发生变化，您需要修改数据类，您只需调整属性。这比试图跟踪分散在多个页面中的描述性文本和验证逻辑更快、更可靠，尤其是考虑到数据类代码通常在一个单独的项目中编译(并且可能由不同的开发人员管理)。

![images](images/square.jpg) **注意**在使用 web 服务时，基于属性的方法也有一个缺点。因为所有属性都放在数据类中，所以它们将从自动生成的客户端代码中剥离出来。为了避免这个问题，您需要使用 web 服务类型共享，这允许您在服务器端 ASP.NET 代码和客户端 Silverlight 代码之间共享相同的类定义。[第 19 章](19.html#ch19)描述了如何使用这项技术，本章的可下载代码将它付诸实践。

在下面几节中，您将看到数据属性是如何工作的。使用它们，您将了解如何在数据对象中直接嵌入标题、描述和有效性规则。

#### 标签

标签取代了为数据控件添加标题的 TextBlock。例如，考虑以下标记，它显示文本“型号”，后跟包含型号的文本框:

`<TextBlock Margin="7">Model Number:</TextBlock>
<TextBox Margin="5" Grid.Column="1" x:Name="txtModelNumber"
 Text="{Binding ModelNumber, Mode=TwoWay}"></TextBox>`

您可以使用如下标签替换 TextBlock:

`<dataInput:Label Margin="7" Content="Model Number:"></dataInput:Label>
<TextBox Margin="5" Grid.Column="1" x:Name="txtModelNumber"
 Text="{Binding ModelNumber, Mode=TwoWay}"></TextBox>`

以这种方式使用，标签没有任何优势。当您使用绑定将它锁定到您使用 Target 属性添加标题的控件时，它的真正好处就显现出来了，如下所示:

`<dataInput:Label Margin="7" Target="{Binding ElementName=txtModelNumber}">
</dataInput:Label>
<TextBox Margin="5" Grid.Column="1" x:Name="txtModelNumber"
 Text="{Binding ModelNumber, Mode=TwoWay}"></TextBox>`

当以这种方式使用时，标签会做一些有趣的事情。它不是依赖您为它提供一段固定的文本，而是检查被引用的元素，找到绑定的属性，并查找类似于下面这样的显示属性:

`[Display(Name="Model Number")]
public string ModelNumber
{ ... }`

然后，标签显示该文本—在本例中，是清晰分隔的两个单词的标题“型号”

![images](images/square.jpg) **注意**在将显示属性添加到数据类之前，需要添加一个对 System.ComponentModel.DataAnnotations.dll 程序集的引用。(还需要导入系统。定义显示属性的命名空间。)

从纯标记的角度来看，标签不保存任何击键。您可能会觉得编写连接标签的绑定表达式比用相同的文本填充 TextBlock 要花费更多的精力。然而，标签方法有几个优点。最明显的是，它具有高度的可维护性——如果您在任何时候更改数据类，新的标题将无缝地流入任何使用该数据类的数据表单，而不需要编辑一行标记。

标签并不局限于显示基本的标题。它还改变其外观，以标记必需的属性和验证错误。要指定必需的属性(为了使数据对象有效，必须提供该属性)，请添加必需的属性:

`[Required()]
[Display(Name="Model Number")]
public string ModelNumber
{ ... }`

默认情况下，标签通过加粗标题文本来响应。但是您可以通过在标签的控件模板中修改必需和非必需的可视状态来更改这种格式，甚至添加动画效果。(要查看控制模板和可视状态，请参考[第 15 章](15.html#ch15)。)

类似地，标签关注用户编辑数据时发生的错误。为此，您的绑定必须选择使用 ValidatesOnExceptions 和 NotifyOnValidationError 属性进行验证，如 UnitCost 属性所示:

`<dataInput:Label Margin="7" Grid.Row="2"
 Target="{Binding ElementName=txtUnitCost}"></dataInput:Label>
<TextBox Margin="5" Grid.Row="2" Grid.Column="1" x:Name="txtUnitCost" Width="100"
 HorizontalAlignment="Left" Text="{Binding UnitCost, Mode=TwoWay, ValidatesOnExceptions=true,
NotifyOnValidationError=true}"></TextBox>`

要测试这一点，请在单位成本字段中键入非数字字符，然后按 tab 键离开。标签中的标题文字从黑色变为红色(参见[图 21-1](#fig_21_1) )。如果您想要更有趣的东西，您可以更改标签的控件模板—这一次，您需要修改有效和无效的视觉状态。

![images](images/9781430234791_Fig21-01.jpg)

***图 21-1。**必需的型号和无效的单位成本*

![images](images/square.jpg) **注意**标签中的错误通知是在*中添加*到输入控制中的标准错误指示器。例如，在[图 21-1](#fig_21_1) 所示的页面中，单位成本文本框在右上角显示红色轮廓和红色三角形，表示其中包含的数据无效。此外，当“单位成本”文本框获得焦点时，会弹出一个带有错误描述的红色气球。

#### 描述查看器

Label 控件负责显示标题文本，并添加了突出显示必需属性和无效数据的功能。然而，当用户填写复杂的表单时，他们有时需要更多。几个词的描述性文本可以创造奇迹，DescriptionViewer 控件为您提供了一种方法，可以轻松地将这种指导合并到您的用户界面中。

这一切都始于您在上一节中看到的显示属性。除了 Name 属性，它还接受一个 Description 属性，该属性用于一句话、两句话或更多详细信息:

`[Display(Name="Model Number",
 Description="This is the alphanumeric product tag used in the warehouse.")]
public string ModelNumber
{ ... }`

以下是将 DescriptionViewer 添加到 ModelNumber 文本框旁边的列中的标记:

`<TextBlock Margin="7">Model Number</TextBlock>
<TextBox Margin="5" Grid.Column="1" x:Name="txtModelNumber"
 Text="{Binding ModelNumber, Mode=TwoWay, ValidatesOnExceptions=true,
NotifyOnValidationError=true}"></TextBox>
**<dataInput:DescriptionViewer Grid.Column="2"**
 Target="{Binding ElementName=txtModelNumber}"></dataInput:DescriptionViewer>`

DescriptionViewer 显示一个小的信息图标。当用户将鼠标移动到它上面时，描述文本出现在工具提示中([图 21-2](#fig_21_2) )。

![images](images/9781430234791_Fig21-02.jpg)

***图 21-2。**描述查看器*

通过设置 GlyphTemplate 属性，可以用不同的内容替换图标，该属性决定了 DescriptionViewer 的显示内容。下面是一个换入新图标的示例:

`<dataInput:DescriptionViewer Grid.Row="1" Grid.Column="2"
 Target="{Binding ElementName=ModelName}">            
  <dataInput:DescriptionViewer.GlyphTemplate>
    <ControlTemplate>
      <Image Source="info.jpg" Stretch="None"></Image>
    </ControlTemplate>
  </dataInput:DescriptionViewer.GlyphTemplate>
</dataInput:DescriptionViewer>`

当绑定数据有验证错误时，DescriptionViewer 不会更改其外观。但是，它包含一个 IsValid 属性，并且支持四种基本的可视化验证状态(ValidFocused、ValidUnfocused、InvalidFocused 和 InvalidUnfocused)。这意味着您可以更改 DescriptionViewer 模板，并添加某种区分器来更改其外观以突出显示错误或应用稳态动画。

#### 验证摘要

您已经看到了 Silverlight 帮助您标记无效数据的几种方式。首先，正如你在前一章所学的，大多数输入控件在出现问题时会改变它们的外观，例如，将它们的边框改为红色。其次，当控件获得焦点时，这些输入控件还会显示一条弹出错误消息。第三，如果您使用的是 Label 控件，它会将其标题文本变为红色。第四，如果您使用的是 DescriptionViewer 控件，您可以用一个对无效数据作出反应的控件模板来替换默认的控件模板(就像您可以通过为标签和输入控件提供自定义控件模板来更改它们显示错误通知的方式一样)。

所有这些技术都是为了给*原位*错误通知——出现在违规输入旁边或附近的消息。但是在长表单中，显示一个总结一组控件中的问题的错误列表通常是有用的。您可以通过对上一章描述的 BindingValidationError 做出反应来实现这样一个列表。但是 Silverlight 有一个更简单的选项，不需要代码就可以完成这项工作:ValidationSummary 控件。

ValidationSummary 监视容器中的错误事件。例如，如果您有带输入控件的网格，您可以使用 Target 属性将 ValidationSummary 指向该网格。然后，它将检测任何包含的输入控件中发生的错误。(从技术上讲，您可以将 ValidationSummary 指向单个输入控件，但这没有多大意义。)大多数时候，不需要设置目标属性。如果没有，ValidationSummary 将检索对其容器的引用，并监视其中的所有控件。要创建如图 21-3 所示的摘要，您需要在包含产品文本框的网格内的某处添加 ValidationSummary:

`<dataInput:ValidationSummary Grid.Row="6" Grid.ColumnSpan="3" Margin="7" />` ![images](images/9781430234791_Fig21-03.jpg)

***图 21-3。**有三个错误的验证摘要*

![images](images/square.jpg) **注意**记住，要捕捉 ValidationSummary 的错误，您的绑定必须将 Mode 设置为 TwoWay，并且必须将 ValidatesOnExceptions 和 NotifyOnValidationError 设置为 true。

当不存在错误时，ValidationSummary 是不可见的并且是折叠的，因此它不占用任何空间。当出现一个或多个错误时，您会看到如图[图 21-3](#fig_21_3) 所示的显示。它由一个标题(显示一个错误图标和错误数)和一个错误列表组成，该列表详细说明了有问题的属性和异常消息。如果用户单击其中一条错误消息，ValidationSummary 将触发 FocusingInvalidControl 事件，并将焦点转移到包含数据的输入控件(除非您已将 FocusControlsOnClick 属性显式设置为 false)。

如果要防止控件将其错误添加到 ValidationSummary 中，可以设置附加的 ShowErrorsInSummary 属性，如下所示:

`<TextBox Margin="5" x:Name="txtUnitCost" Width="100" HorizontalAlignment="Left"
** dataInput:ValidationSummary.ShowErrorsInSummary="False"**
 Text="{Binding UnitCost, Mode=TwoWay, ValidatesOnExceptions=true,
NotifyOnValidationError=true}"></TextBox>`

ValidationSummary 还提供了几个属性，您可以使用它们来自定义它的外观。使用 HeaderTemplate 提供更改标题显示方式的数据模板，使用 Header 提供您自己的自定义标题文本，使用 SummaryListBoxStyle 更改错误列表的格式。以编程方式，您可能希望检查 HasErrors 属性以确定表单是否有效，并检查 Errors 集合以检查检测到的所有问题。

**数据字段数据表单**

如果您使用 Silverlight 工具包，您会发现有两个工具可以帮助您构建丰富的数据表单。首先是 DataField 控件，这是一个用于编辑单个绑定属性的一体化包。DataField 控件结合了一个 Label 控件、一个 DescriptionViewer 控件和一个类似 TextBox 的输入控件。

接下来是一个更有野心的工具:数据表单控件。它是一个容器，创建显示和编辑数据对象所需的所有绑定控件。要使用数据表单显示单个数据对象，请设置 CurrentItem 属性，如下所示:

`dataForm.CurrentItem = product;`

或者，如果您有一个项目集合，则可以使用 ItemsSource 属性:

`dataForm.ItemsSource = products;`

无论哪种方式，数据表单都会为数据对象中的每个属性创建所需的输入控件，并为每个属性提供标签和说明查看器。如果使用 ItemsSource 属性绑定多个项，数据表单甚至会在表单顶部添加一个带有导航控件的栏。使用这些控件，用户可以遍历记录、添加新记录和删除现有记录。不言而喻，数据表单包括许多用于调整其外观的属性和一个可定制的模板，允许您对其布局进行更多的控制。但是为了实现完全的可定制性，大多数开发人员将继续手工创建他们的数据表单标记——至少在数据表单变得更加成熟并集成到核心 Silverlight 平台之前。

### 数据注释

现在，您已经看到了如何改进表单中的错误报告，值得考虑一个补充特性，该特性使检查数据的验证规则更容易实现。目前，Silverlight 验证会响应在您尝试设置属性时发生的未处理的异常。如果您想要实现自定义验证，您必须在属性设置器中编写代码来测试新值，并在需要时抛出异常。您需要的验证代码需要重复编写和繁琐的维护。如果您需要检查几种不同的错误情况，您的代码可能会变得混乱不堪，无意中漏掉某些错误。

Silverlight 提供了一个解决方案，它对*数据注释*提供了新的支持，这允许您通过将一个或多个属性附加到数据类的属性来应用验证规则。如果处理得当，数据注释可以让您将数据验证从代码中转移到修饰它的声明性元数据中，从而提高代码的清晰度和类的可维护性。

![images](images/square.jpg) **注**数据注释系统最初是为 ASP.NET 动态数据开发的，但 Silverlight 借用了相同的模型。从技术上讲，您已经看到了工作中的注释，因为上一节中演示的显示和必需属性都是数据注释。

#### 引发注释错误

在使用数据注释之前，您需要添加对 System.ComponentModel.DataAnnotations.dll 程序集的引用，该程序集就是您在上一节中用来访问显示和所需属性的程序集。您将在匹配的名称空间 system . component model . data annotations 中找到所有数据注释类。

数据注释通过一小组应用于数据类中属性定义的属性来工作。以下示例使用 StringLength 属性将 ModelName 字段的最大长度限制为 25 个字符:

`[StringLength(25)]
[Display(Name = "Model Name", Description = "This is the retail product name.")] public string
ModelName
{
    get { return modelName; }
    set
    {
        modelName = value;
        OnPropertyChanged(new PropertyChangedEventArgs("ModelName"));
    }
}`

这个设置看起来很完美:验证规则清晰可见，易于隔离，并且与属性设置代码完全分离。然而，对于 Silverlight 的数据绑定系统来说，这还不够。即使有数据注释，Silverlight 的所有标准控件都需要一个异常，才能识别无效数据的存在。

幸运的是，有一种简单的方法可以在你需要的时候抛出你需要的异常。诀窍在于 Validator 类，它提供了几个静态帮助器方法，可以测试您的数据注释并检查您的属性中是否有坏数据。如果特定值对于特定属性无效，ValidateProperty()方法将引发异常。ValidateObject()方法检查整个对象是否有问题，如果有任何属性不正常，就会抛出异常。TryValidateProperty()和 TryValidateObject()方法执行几乎相同的任务，但是它们提供解释潜在问题的 ValidationResult 对象，而不是抛出 ValidationException。

下面的示例显示了使用 ValidateProperty()方法检查属性值的三行代码。调用时，此代码检查附加到属性的所有验证属性，并在发现违反属性时抛出 ValidationException:

`[StringLength(25)]
[Display(Name = "Model Name", Description = "This is the retail product name.")]
public string ModelName
{
    get { return modelName; }
    set
    {
**        // Explicitly raise an exception if a data annotation attribute**
**        // fails validation.**
**        ValidationContext context = new ValidationContext(this, null, null);**
**        context.MemberName = "ModelName";**
**        Validator.ValidateProperty(value, context);**

        modelName = value;
        OnPropertyChanged(new PropertyChangedEventArgs("ModelName"));
    }
}`

通过将这样的代码添加到所有的属性设置器中，您可以享受数据注释系统的好处——编码验证逻辑的简单属性——并且仍然将验证插入到 Silverlight 数据绑定系统中。

![images](images/square.jpg) **注意**数据注释功能强大，但并不适合所有场景。特别是，它们仍然强制您的数据类抛出异常来指示错误情况。这种设计模式并不总是合适的(例如，如果您需要一个暂时处于无效状态的对象，或者您希望只对用户编辑施加限制，而不是编程更改，那么它就会遇到问题)。这也有点危险，因为在代码中对数据对象进行错误的更改有可能引发意外的异常并破坏应用程序。(为了避免这种情况，您可以在数据类中创建一个 AllowInvalid 属性，当该属性为 true 时，告诉它们绕过验证检查代码。但充其量还是尴尬。)由于这个原因，许多开发人员更喜欢使用 IDataError 或 INotifyDataError 接口来处理他们的数据对象，如第 20 章中的[所述。](20.html#ch20)

#### 标注属性

要对数据注释使用验证，需要向数据类添加正确的属性。以下部分列出了您可以使用的属性，所有这些属性都是从基本 ValidationAttribute 类派生的，并且可以在系统中找到。DataAnnotations 命名空间。所有这些属性都继承了 ValidationAttribute。ErrorMessage 属性，可以设置该属性以添加自定义错误信息文本。该文本出现在弹出的错误气球中，并显示在 ValidationSummary 控件中(如果您正在使用它)。

![images](images/square.jpg) **提示**您可以通过堆叠几个不同的数据注释属性来为一个属性添加多个限制。

##### 需要

该属性指定该字段必须存在—如果留空，用户会收到一个错误。这适用于零长度字符串，但对于数值来说相对无用，因为数值开始时是完全可以接受的 0 值:

`[Required()]
public string ModelNumber
{ ... }`

下面是一个添加错误消息的示例:

`[Required(ErrorMessage="You must valid ACME Industries ModelNumber.")]
public string ModelNumber
{ ... }`

##### 字符串长度

该属性设置字符串的最大长度。您还可以(可选)通过设置 minimum length 属性来设置最小长度，如下所示:

`[StringLength(25, MinimumLength=5)]
public string ModelName
{ ... }`

当使用具有重要参数(如 StringLength)的属性时，可以使用带编号的占位符将这些详细信息添加到错误消息中，其中{0}是正在编辑的字段的名称，{1}是构造函数参数，{2}是第一个属性特性，{3}是第二个属性特性，依此类推。这里有一个例子:

`[StringLength(25, MinimumLength=5, ErrorMessage=
 "Model names must have between {2} and {1} characters.")]
public string ModelName
{ ... }`

当 StringLength 导致验证失败时，它会将错误消息设置为以下文本:“模型名称必须包含 5 到 25 个字符。”

##### 范围

该属性强制值在最小值和最大值之间的范围内，如下所示:

`[Range(0,1000)]
public int UnitsInStock
{ ... }`

Range 属性通常用于数值数据类型，但您可以使用实现 IComparable 的任何类型，只需使用将数据类型作为类型参数的构造函数的重载版本，并以字符串形式提供您的值:

`[Range(typeof(DateTime), "1/1/2005", "1/1/2010"]
public DateTime ExpiryDate
{ ... }`

##### 正则表达式

这个属性根据一个*正则表达式*测试一个文本值，正则表达式是一个用专门的模式匹配语言编写的公式。

下面的例子允许一个或多个字母数字字符(大写字母从*A*–*Z*，小写字母从*A*–*Z*，数字从 0–9，但没有其他):

`^[A-Za-z0-9]+$`

第一个字符(^)表示字符串的开头。方括号中的部分标识了单个角色的选项范围——本质上，它表示该角色可以在 *A* 到 *Z* 或 *a* 到 *z* 之间，或者 0 到 9。紧跟其后的+扩展了这个范围，以匹配一个或多个字符的序列。最后，最后一个字符($)表示字符串的结尾。

要将此应用于属性，可以使用 RegularExpression 属性，如下所示:

`[RegularExpression("^[A-Za-z0-9]+$")]
public string ModelNumber
{ ... }`

在本例中，字符^、[]、+和$都是元字符，在正则表达式语言中具有特殊的含义。表 21-1 给出了你可能会用到的所有元字符的概要。

![images](images/9781430234791_tab21-01.jpg)

![images](images/9781430234791_tab21-01a.jpg)

正则表达式都是关于模式化文本的。在许多情况下，您不会自己设计正则表达式，而是寻找验证邮政编码、电子邮件地址等的正确的预制表达式。关于正则表达式语言的详细探索，请查阅一本专门的书，比如优秀的*掌握正则表达式* (O'Reilly，Jeffrey Friedl)。

**正则表达式基础知识**

所有正则表达式都由两种字符组成:文字和元字符。*文字*代表一个特定的定义字符。*元字符*是可以代表一系列值的通配符。正则表达式从它们支持的丰富的元字符集中获得力量(见[表 21-1](#tab_21_1) )。

正则表达式元字符的两个例子包括您已经看到的^和$字符，它们指定了字符串的开始和结束。两个更常见的元字符是\s(代表任何空白字符)和\d(代表任何数字)。使用这些字符，您可以构造以下表达式，它将成功匹配以数字 333 开头、后跟一个空白字符和任意三个数字的任何字符串。有效匹配包括 333 333、333 945，但不包括 334 333 或 3334 945:

`^333\s\d\d\d$`

您也可以使用加号(+)来表示重复的字符。例如，5+7 意味着“任意数量的 *5* 个字符，后跟单个 *7* 数字 57 匹配，555557 也匹配。此外，您可以使用括号将子表达式组合在一起。例如，(52)+7 匹配以序列 52 开头的任何字符串。匹配项包括 527、52527、52552527 等等。

您也可以使用方括号来分隔字符范围。[a-f]匹配从 *a* 到 *f* 的任意单个字符(仅小写)。以下表达式匹配任何以字母从 *a* 到 *f* 开头、包含一个或多个字母、以 *ing* 结尾的单词——可能的匹配包括 *acting* 和 *developing* :

`^[a-f][a-z]+ing$`

这个讨论只是触及了正则表达式的表面，正则表达式构成了它们自己的完整语言。然而，在开始使用正则表达式之前，您不需要学习所有关于正则表达式的知识。许多程序员在网上寻找有用的预置正则表达式。没有太多麻烦，您可以找到电子邮件、电话号码、邮政编码等示例，所有这些都可以直接放入您的应用程序中。

##### 自定义验证

最有趣的验证属性是 CustomValidation。它允许您在单独的类中编写自己的验证逻辑，然后将该逻辑附加到单个属性，或者用它来验证整个数据对象。

编写自定义验证器非常容易。您所需要做的就是在任何类中编写一个静态方法，该方法接受您想要验证的属性值(以及可选的 ValidationContext)并返回一个 ValidationResult。如果值有效，则返回 ValidationResult.Success。如果值无效，则创建一个新的 ValidationResult，传入问题的描述，然后返回该对象。然后，将该自定义验证类连接到要用 custom validation 属性验证的字段。

下面是一个名为 ProductValidation 的自定义验证类的示例。它检查 UnitCost 属性，只允许以 75、95 或 99 结尾的价格:

`public class ProductValidation
{` `**    public static ValidationResult ValidateUnitCost(double value,**
**      ValidationContext context)**
    {
        // Get the cents portion.
        string valueString = value.ToString();
        string cents = "";
        int decimalPosition = valueString.IndexOf(".");
        if (decimalPosition != -1)
        {
            cents = valueString.Substring(decimalPosition);
        }

        // Perform the validation test.    
        if ((cents != ".75") && (cents != ".99") && (cents != ".95"))
        {
**            return new ValidationResult(**
**              "Retail prices must end with .75, .95, or .99 to be valid.");**
        }
        else
        {
**            return ValidationResult.Success;**
        }
     }
}`

若要强制执行此验证，请使用 CustomValidation 属性为其附加适当的属性。您必须指定两个参数:自定义验证类的类型和执行验证的静态方法的名称。下面是一个指向 ProductValidation 类中的 ValidateUnitCost()方法的示例:

`[CustomValidation(typeof(ProductValidation), "ValidateUnitCost")]
public double UnitCost
{ ... }`

图 21-4 显示了这一规则的作用。

![images](images/9781430234791_Fig21-04.jpg)

***图 21-4。**违反自定义验证规则*

还可以使用 CustomValidation 属性来附加类范围的验证规则。如果您需要执行比较属性的验证(例如，确保一个属性小于另一个属性)，这将非常有用。下面是一个验证方法，它检查以确保 ModelNumber 和 ModelName 属性具有不同的值:

`public static ValidationResult ValidateProduct(Product product,
  ValidationContext context)
{
    if (product.ModelName == product.ModelNumber)
    {
        return new ValidationResult(
          "You can't use the same model number as the model name.");
    }
    else
    {
        return ValidationResult.Success;
    }
}`

下面是将它附加到产品类的 CustomValidation 属性:

`[CustomValidation(typeof(ProductValidation), "ValidateProduct")]
public class Product: INotifyPropertyChanged
{ ... }`

类范围的验证规则有一个明显的缺点。像属性验证规则一样，由您通过调用验证器来实施它们。验证对象()方法。不幸的是，在任何属性设置器中这样做都没有意义，因为类范围的验证应该在当前对象的整个编辑过程完成之后执行。Silverlight 的两个富数据控件——DataGrid 和 data form——通过触发验证器解决了这个问题。ValidateObject()方法本身。但是，如果您没有使用这些控件，自定义验证器可能不值得这么麻烦。

### 数据网格

顾名思义，DataGrid 是一种数据显示控件，它从对象集合中获取信息，并将其呈现在由行和单元格组成的网格中。每行对应一个单独的对象，每列对应该对象中的一个属性。

DataGrid 为在 Silverlight 中处理数据增加了急需的多功能性。其优点包括如下:

*   *灵活性*:使用基于列的模型来精确定义想要使用的列，并提供从绑定对象中提取数据的绑定表达式。数据网格还支持一些你在[第 20 章](20.html#ch20)中学到的重要工具，比如模板和值转换器。
*   *可定制性*:您可以使用属性彻底改变数据网格的外观，以及格式化网格各个组件的标题和样式。如果你真的很大胆，你可以给整个 DataGrid 一个新的控件模板，包括定制的视觉效果和动画。
*   *编辑*:DataGrid 让您能够监控编辑过程并回滚无效的更改。它支持你在[第 20 章](20.html#ch20)中学到的基于异常的验证，它还支持*数据注释*——使用属性而不是代码添加到数据类的灵活验证规则。
*   *性能*:DataGrid 拥有处理大型数据集的出色性能，因为它使用了*虚拟化*。这意味着 DataGrid 只为当前可见的数据保留内存中的对象，而不是为加载的整个数据集。这极大地减少了内存开销，并使控件可以容纳数万行而不会严重降低速度。

#### 创建简单的网格

数据网格是在熟悉的系统中定义的。控件命名空间，但它部署在与其他 Silverlight 元素不同的程序集中:System.Windows.Controls.Data.dll 程序集。默认情况下，您的 Silverlight 项目没有对此程序集的引用。但是，一旦从工具箱添加了 DataGrid，Visual Studio 就会添加引用并插入一个新的命名空间映射，如下所示:

`<UserControl xmlns:data=
 "clr-namespace:System.Windows.Controls;assembly=System.Windows.Controls.Data" ... >`

这将 DataGrid 及其相关类映射到名称空间前缀 *data* 。

要创建快速更新的数据网格，您可以使用自动列生成。为此，需要将 AutoGenerateColumns 属性设置为 true(这是默认值):

`<data:DataGrid x:Name="gridProducts" AutoGenerateColumns="True">
</data:DataGrid>`

现在，通过设置 ItemsSource 属性，可以像填充列表控件一样填充数据网格:

`gridProducts.DataSource = products;`

[图 21-5](#fig_21_5) 显示了一个使用自动列生成的数据网格，它包含了你在[第 20 章](20.html#ch20)中使用的产品对象的集合。当使用自动列生成时，DataGrid 使用反射来查找绑定数据对象中的每个公共属性。它为每个属性创建一列。为了显示非字符串属性，DataGrid 调用 ToString()，该方法适用于数字、日期和其他简单的数据类型，但如果您的对象包含更复杂的数据对象，就不太适用了。(在这种情况下，您可能希望显式定义列，这使您有机会绑定到子属性、使用值转换器或应用模板来获得正确的显示内容。)

   ![images](images/9781430234791_Fig21-05.jpg)

***图 21-5。**自动生成列的数据网格*

表 21-2 列出了一些可以用来定制数据网格基本显示的属性。在下面几节中，您将看到如何使用样式和模板获得细粒度的格式控制。您还将看到 DataGrid 如何处理排序和选择，并且您将考虑这些特性背后的更多属性。

T2】

#### 如何调整列的大小和重新排列

当显示自动生成的列时，DataGrid 会尝试智能地调整每列的宽度。最初，它使每一列的宽度足以显示当前视图中的最大值(或者标题，如果标题更宽的话)。

当用户开始滚动数据时，DataGrid 试图保留这种智能调整方法。一旦遇到包含较长数据的行，DataGrid 就会加宽相应的列以适应它。这种自动调整大小只是单向的，因此当您留下大量数据时，列不会收缩。

DataGrid 列的自动调整很有趣，而且通常很有用，但这并不总是您想要的。考虑图 21-5 所示的例子，它包含一个描述栏，里面有一长串文本。最初，Description 列被做得非常宽以适应这个数据，把其他列挤开了。(在[图 21-5](#fig_21_5) 中，用户已经手动将描述栏的大小调整到更合理的大小。所有其他列都保留其初始宽度。)调整列的大小后，当用户滚动数据时，列不会自动放大。

![images](images/square.jpg) **注意**显然，你不想强迫你的用户去处理宽得离谱的列。为了从一开始就正确地调整列的大小，您需要显式地定义列，如下一节所述。

通常，用户可以通过拖动列边缘来调整列的大小。通过将 CanUserResizeColumns 属性设置为 false，可以防止用户调整数据网格中列的大小。如果需要更具体的说明，可以通过将该列的 CanUserResize 属性设置为 false 来防止用户调整单个列的大小。还可以通过设置列的 MinWidth 属性来防止用户将列设置得非常窄。

数据网格还有另一个令人惊讶的地方，它允许用户定制列显示。不仅可以调整列的大小，还可以将它们从一个位置拖到另一个位置。如果不希望用户拥有这种重新排序能力，请将 DataGrid 的 CanUserReorderColumns 属性或特定列的 CanUserReorder 属性设置为 false。

#### 定义列

使用自动生成的列，您可以快速创建显示所有数据的数据网格。然而，你放弃了相当多的控制权。例如，您无法控制列的排序方式、宽度、内部值的格式以及顶部放置的标题文本。

一种更强大的方法是通过将 AutoGenerateColumns 设置为 false 来关闭自动列生成。然后，您可以使用所需的设置并按照所需的顺序显式定义所需的列。为此，您需要填充数据网格。包含右列对象的列集合。

目前，DataGrid 支持三种类型的列，它们由从 DataGridColumn 派生的三个不同的类表示:

*   *datagrid text column*<ins>:</ins>该列是大多数数据类型的标准选择。该值被转换为文本并显示在 TextBlock 中。编辑该行时，文本块会被标准文本框替换。
*   *DataGridCheckBoxColumn* :该列显示一个复选框。此列类型自动用于布尔值(或可为空的布尔值)。通常，复选框是只读的；但是当您编辑该行时，它就变成了一个普通的复选框。
*   *DataGridTemplateColumn* :这个列是目前最强大的选项。它允许您定义用于显示列值的数据模板，具有在列表控件中使用模板时所具有的所有灵活性和功能。例如，您可以使用 DataGridTemplateColumn 来显示图像数据，或者使用专用的 Silverlight 控件(如包含有效值的下拉列表或日期值的 DatePicker)。

例如，下面是一个经过修改的 DataGrid，它创建了一个包含产品名称和价格的两列显示。它还应用了更清晰的列标题，并加宽了产品列以适应其数据:

`<data:DataGrid x:Name="gridProducts" Margin="5" AutoGenerateColumns="False">
  <data:DataGrid.Columns>
    <data:DataGridTextColumn Header="Product" Width="175"
     Binding="{Binding ModelName}"></data:DataGridTextColumn>
    <data:DataGridTextColumn Header="Price"
     Binding="{Binding UnitCost}"></data:DataGridTextColumn>
  </data:DataGrid.Columns>
</data:DataGrid>`

定义列时，几乎总是要设置三个细节:出现在列顶部的标题文本、列的宽度，以及最重要的获取数据的绑定。

DataGrid 的数据绑定方法不同于大多数其他列表控件的方法。列表控件包括 DisplayMemberPath 属性，而不是 Binding 属性。绑定方法更加灵活——它允许您合并值转换器，而无需升级到完整的模板列。例如，下面是如何使用绑定的 StringFormat 属性将单位成本列格式化为货币值(参见[图 21-6](#fig_21_6) ):

`<data:DataGridTextColumn Header="Price" Binding=
 "{Binding UnitCost, StringFormat='C'}">
</data:DataGridTextColumn>` ![images](images/9781430234791_Fig21-06.jpg)

***图 21-6。**设置标题文本和格式列值*

![images](images/square.jpg) **提示**您可以通过修改相应列对象的 Visibility 属性来动态显示和隐藏列。此外，您可以随时通过更改列的 DisplayIndex 值来移动列。

##### DataGridCheckBoxColumn

产品类不包括任何布尔属性。如果是的话，DataGridCheckBoxColumn 将是一个有用的选项。

与 DataGridTextColumn 一样，Binding 属性提取数据—在本例中，是用于设置内部 CheckBox 元素的 IsChecked 属性的 true 或 false 值。DataGridCheckBoxColumn 还添加了一个名为 Content 的属性，该属性允许您在复选框旁边显示可选内容。最后，DataGridCheckBoxColumn 包含一个 IsThreeState 属性，该属性确定复选框是否支持未确定状态以及更明显的选中和未选中状态。如果使用 DataGridCheckBoxColumn 显示来自可为空的布尔值的信息，可以将 IsThreeState 属性设置为 true。这样，用户可以单击返回到未确定状态(显示浅阴影复选框)，将绑定值返回到 null。

##### datagrid template column

DataGridTemplateColumn 使用数据模板，其工作方式与您之前使用列表控件探索的数据模板功能相同。DataGridTemplateColumn 中唯一的区别是它允许您定义两个模板:一个用于数据显示(CellTemplate ),另一个用于数据编辑(CellEditingTemplate ),稍后您将会考虑到这一点。下面是一个使用模板数据列在网格中放置每个产品的缩略图的例子(见[图 21-7](#fig_21_7) ):

`<data:DataGridTemplateColumn>
  <data:DataGridTemplateColumn.CellTemplate>
    <DataTemplate>
      <Image Stretch="None" Source=
       "{Binding ProductImagePath, Converter={StaticResource ImagePathConverter}}">
      </Image>
    </DataTemplate>
  </data:DataGridTemplateColumn.CellTemplate>
</data:DataGridTemplateColumn>`

此示例假定您已经向 UserControl 添加了 ImagePathConverter 值转换器。资源集合:

`<UserControl.Resources>
  <local:ImagePathConverter x:Key="ImagePathConverter"></local:ImagePathConverter>
</UserControl.Resources>`

完整的 ImagePathConverter 代码如[第 20 章](20.html#ch20)所示。

   ![images](images/9781430234791_Fig21-07.jpg)

***图 21-7。**带有图像内容的数据网格*

#### 格式化和样式化列

通过设置 Foreground、FontFamily、FontSize、FontStyle 和 FontWeight 属性，可以像格式化 TextBlock 元素一样格式化 DataGridTextColumn。但是，DataGridTextColumn 并不公开 TextBlock 的所有属性。例如，如果您想要创建一个显示多行文本的列，则无法设置常用的 Wrapping 属性。在这种情况下，您需要改用 ElementStyle 属性。

本质上，ElementStyle 属性允许您创建应用于 DataGrid 单元格内的元素的样式。对于简单的 DataGridTextColumn，这是一个 TextBlock。(在 DataGridCheckBoxColumn 中，它是一个复选框；在 DataGridTemplateColumn 中，它是您在数据模板中创建的任何元素。)

下面是一个允许列中的文本换行的简单样式:

`<data:DataGridTextColumn Header="Description" Width="400"
 Binding="{Binding Description}">
  <data:DataGridTextColumn.ElementStyle>` `    <Style TargetType="TextBlock">
      <Setter Property="TextWrapping" Value="Wrap"></Setter>
    </Style>
  </data:DataGridTextColumn.ElementStyle>
</data:DataGridTextColumn>`

要查看换行的文本，必须扩展行高。不幸的是，DataGrid 不能像 Silverlight 布局容器那样灵活地调整自己的大小。相反，您必须使用 DataGrid 设置一个固定的行高。RowHeight 属性。这个高度适用于所有行，不管它们包含多少内容。[图 21-8](#fig_21_8) 显示了行高设置为 70 像素的例子。

![images](images/9781430234791_Fig21-08.jpg)

***图 21-8。**带有换行文本的数据网格*

![images](images/square.jpg) **提示**如果您想对多列应用相同的样式(例如，处理几个地方的可换行文本)，您可以在 Resources 集合中定义样式，然后使用 StaticResource 在每列中引用它。

您可以使用 EditingElementStyle 来设置编辑列时使用的元素的样式。对于 DataGridTextColumn，编辑元素是 TextBox 控件。

ElementStyle、ElementEditingStyle 和 column 属性为您提供了一种格式化特定列中所有单元格的方法。但是，在某些情况下，您可能希望将格式设置应用于每列中的每个单元格。最简单的方法是为数据网格配置一个样式。RowStyle 属性。DataGrid 还公开了一小组附加属性，允许您格式化网格的其他部分，如列标题和行标题。表 21-3 有完整的故事。

![images](images/9781430234791_tab21-03.jpg)

#### 控制列宽

若要设置列的初始大小，请设置其 Width 属性。你有三个基本选择:

*   *固定大小*:要使用这种方法，只需将 Width 属性设置为像素数(比如 200)。
*   *自动调整大小*:要使用这种方法，将 Width 属性设置为三个特殊值之一:SizeToCells(加宽以匹配显示的最大单元格值)、SizeToHeader(加宽以匹配标题文本)或 Auto(加宽以匹配显示的最大单元格值或标题，以较大者为准)。当您使用 SizeToCells 或 Auto 时，滚动时列可能会变宽，这要么是一种方便，要么是一种烦人的干扰，这取决于您的视角。顺便说一下，如果不设置 Width 属性，该列将使用 DataGrid 的值。ColumnWidth 属性，默认情况下为 Auto。
*   *比例大小*:要使用这种方法(也称为*星形大小*，将 Width 属性设置为星号(*)。这种方法类似于网格布局容器的比例大小调整。一旦放置了所有固定大小和自动调整大小的列，剩余的空间将在成比例的列之间进行分配。如果您想给某些列更多的可用空间，请设置一个数字后跟一个星号的宽度。例如，宽度为 2*的列获得的空间是宽度仅为*的列的两倍。

下面是一个示例，其中一列(型号编号)使用固定宽度，另一列(价格)使用自动调整大小，其余两列(型号名称和说明)使用比例调整大小:

`<data:DataGrid.Columns>
  <data:DataGridTextColumn Header="Model Number" Binding="{Binding ModelNumber}"` `   Width="100"></data:DataGridTextColumn>

  <data:DataGridTextColumn Header="Model Name" Width="100"
   Binding="{Binding ModelName}"></data:DataGridTextColumn>

  <data:DataGridTextColumn Header="Unit Cost" Width="*" MinWidth="50"
   Binding="{Binding UnitCost, StringFormat='C'}"></data:DataGridTextColumn<

  <data:DataGridTextColumn Width="2*" MinWidth="50"
   Binding="{Binding Description}" Header="Description" >
    <data:DataGridTextColumn.ElementStyle>
      <Style TargetType="TextBlock">
        <Setter Property="TextWrapping" Value="Wrap"></Setter>
      </Style>
    </data:DataGridTextColumn.ElementStyle>
  </data:DataGridTextColumn>
</data:DataGrid.Columns>`

[图 21-9](#fig_21_9) 显示了两种不同宽度的网格。

![images](images/9781430234791_Fig21-09.jpg)

***图 21-9。**用比例栏调整网格大小*

比例大小的好处在于它允许你创建适应可用空间的网格。只要添加一个按比例大小排列的列，GridView 就会删除水平滚动条。然后，如果调整 GridView 的大小(例如，在本例中通过调整浏览器窗口的大小)，GridView 会相应地调整其列的大小。

如果将 GridView 的大小调整得更大，按比例调整大小的列将获得所有额外的空间。如果缩小 GridView 的大小，按比例调整大小的列得到的空间会越来越小，直到达到它们的 MinWidth 值。如果您继续缩小 GridView 超过这一点，其他*列的大小将从它们原来的固定或自动大小减小，直到它们达到它们的 MinWidth 值。如果在 GridView 的所有列都达到其最小宽度后继续收缩 GridView，GridView 会继续将其列的宽度减小到 MinWidth 设置以下，直到每列都被折叠。这种行为有些复杂，但它完全是由 DataGrid 实现的。它不需要应用程序干预，对用户来说很直观。*

#### 格式化行

通过设置 DataGrid column 对象的属性，可以控制整列的格式。但是在许多情况下，标记包含特定数据的行更有用。例如，您可能希望引起对高价产品或过期货物的注意。您可以通过处理 DataGrid 以编程方式应用这种格式。LoadingRow 事件。

LoadingRow 事件是一个强大的行格式化工具。它允许您访问当前行的数据对象，允许您执行简单的范围检查、比较和更复杂的操作。它还为行提供了 DataGridRow 对象，允许您用不同的颜色或不同的字体设置行的格式。但是，您不能只格式化该行中的单个单元格—为此，您需要 DataGridTemplateColumn 和 IValueConverter。

当每行出现在屏幕上时，LoadingRow 事件将触发一次。这种方法的优点是，您的应用程序永远不会被迫格式化整个网格——相反，LoadingRow 只为当前可见的行触发。但是也有不好的一面。当用户在网格中滚动时，LoadingRow 事件被连续触发。因此，除非您希望滚动停止，否则不能将耗时的代码放在 LoadingRow 方法中。

还有另一个考虑因素:虚拟化。为了降低内存开销，当您滚动数据时，DataGrid 重用相同的 DataGrid 对象来显示新数据。(这就是为什么该事件被称为 LoadingRow 而不是 CreatingRow。)如果不小心，DataGrid 可能会将数据加载到已经格式化的 DataGridRow 中。为了防止这种情况发生，您必须显式地将每一行恢复到其初始状态。

在下面的例子中，高价商品被赋予亮橙色背景(见[图 21-10](#fig_21_10) )。正常价格的商品被赋予标准的白色背景:

`// Reuse brush objects for efficiency in large data displays.
private SolidColorBrush highlightBrush = new SolidColorBrush(Colors.Orange);
private SolidColorBrush normalBrush = new SolidColorBrush(Colors.White);

private void gridProducts_LoadingRow(object sender, DataGridRowEventArgs e)
{
    // Check the data object for this row.
    Product product = (Product)e.Row.DataContext;

    // Apply the conditional formatting.
    if (product.UnitCost > 100)
    {
        e.Row.Background = highlightBrush;
    }` `    else
    {
        // Restore the default white background. This ensures that used,
        // formatted DataGrid object are reset to their original appearance.
        e.Row.Background = normalBrush;
    }
}` ![images](images/9781430234791_Fig21-10.jpg)

***图 21-10。**高亮显示行*

请记住，您还有另一个选项来执行基于值的格式化:您可以使用 IValueConverter 来检查绑定数据并将其转换为其他数据。当与 DataGridTemplateColumn 结合使用时，这种技术尤其强大。例如，您可以创建包含 TextBlock 的基于模板的列，并绑定 TextBlock。背景属性设置为根据价格设置颜色的 IValueConverter。与前面显示的 LoadingRow 方法不同，这种技术允许您只格式化包含价格的单元格，而不是整行。有关此技术的更多信息，请参考第 20 章中的“应用条件格式”一节。

![images](images/square.jpg) **提示**您在 LoadingRow 事件处理程序中应用的格式仅在加载行时应用。如果您编辑一行，这个 LoadingRow 代码不会触发(至少，直到您将该行滚动到视图之外，然后再回到视图中)。

#### 行详细信息

DataGrid 还支持*行细节*——一个可选的、单独的显示区域，出现在一行的列值的正下方。行细节区域增加了两个不能单独从列中获得的东西。首先，它跨越了 DataGrid 的整个宽度，没有被分割成单独的列，这为您提供了更多的工作空间。第二，您可以配置行细节区域，使其只为选定的行显示，从而允许您在不需要时隐藏额外的细节。

图 21-11 显示了使用这两种行为的数据网格。行详细信息区域显示包装的产品描述文本，并且只为当前选择的产品显示。

![images](images/9781430234791_Fig21-11.jpg)

***图 21-11。**使用行细节区*

要创建这个示例，首先需要通过设置 DataGrid 来定义行细节区域中显示的内容。RowDetailsTemplate 属性。在这种情况下，行详细信息区域使用一个基本模板，该模板包含一个显示完整产品文本并在其周围添加边框的 TextBlock:

`<data:DataGrid.RowDetailsTemplate>
  <DataTemplate>
    <Border>
      <Border Margin="10" Padding="10" BorderBrush="SteelBlue" BorderThickness="3"
       CornerRadius="5">
        <TextBlock Text="{Binding Description}" TextWrapping="Wrap" FontSize="10">
        </TextBlock>
      </Border>
    </Border>
  </DataTemplate>
</data:DataGrid.RowDetailsTemplate>`

其他选项包括添加允许您执行各种任务的控件(例如，获取有关产品的更多信息、将其添加到购物列表、编辑它等等)。

![images](images/square.jpg) **注意**数据网格调整行细节区域的大小有一个捷径:它不考虑根元素的边距。因此，如果您在根元素上设置了 Margin 属性，您的部分内容将在底部和右边被截断。要解决这个问题，您可以添加一个额外的容器，如下例所示。这里，根级元素不包含边距，但是嵌套的 Border 元素包含边距，这避免了大小调整的问题。

您可以通过设置数据网格来配置行详细信息区域的显示行为。RowDetailsVisibilityMode 属性。默认情况下，该属性设置为 VisibleWhenSelected，这意味着当选择该行时，将显示行详细信息区域。或者，您可以将它设置为 Visible，这意味着每一行的行细节区域都将立即显示。或者，您可以使用 Collapsed，这意味着不会为任何行显示行细节区域，至少在您在代码中更改 RowDetailsVisibilityMode 之前不会显示(例如，当用户选择某种类型的行时)。

#### 冻结列

一个*冻结的*列保持在数据网格的左边，即使你向右滚动。[图 21-12](#fig_21_12) 显示了在滚动过程中冷冻产品栏是如何保持可见的。请注意水平滚动条如何仅在可滚动列下延伸，而不在冻结列下延伸。

    ![images](images/9781430234791_Fig21-12.jpg)

***图 21-12。**冻结产品栏*

对于非常宽的网格，列冻结是一个有用的功能，尤其是当您希望确保某些信息(如产品名称或唯一标识符)始终可见时。要使用它，需要将列的 IsFrozen 属性设置为 true:

`<data:DataGridTextColumn Header="Product" Width="175" IsFrozen="True"
 Binding="{Binding ModelName}"></data:DataGridTextColumn>`

有一个问题:冻结的列必须总是在网格的左侧。如果冻结一列，那一定是最左边的一列；如果释放两列，它们必须是左边的前两列；等等。

#### 选择

像普通的列表控件一样，DataGrid 允许用户选择单个项目。发生这种情况时，您可以对 SelectionChanged 事件做出反应。若要找出当前选择的数据对象，可以使用 SelectedItem 属性。如果希望用户能够选择多行，请将 SelectionMode 属性设置为 Extended。(Single 是唯一的其他选项，也是默认选项。)要选择多行，用户必须按住 Shift 或 Ctrl 键。可以从 selected items 属性中检索选定项的集合。

![images](images/square.jpg) **提示**您可以使用 SelectedItem 属性以编程方式设置选择。如果您将选择设置为当前不在视图中的项目，那么最好继续调用 DataGrid。ScrollIntoView()方法，该方法强制数据网格向前或向后滚动，直到您指示的项可见。

#### 排序

只要您正在绑定实现 IList 的集合(例如 List <t>和 ObservableCollection <t>集合)，DataGrid 就具有内置排序功能。如果您满足这个要求，您的数据网格将免费获得基本的排序。</t></t>

要使用排序，用户需要单击列标题。单击一次将根据数据类型对列进行升序排序(例如，数字从 0 开始排序，字母按字母顺序排序)。再次单击该列，排序顺序将反转。列标题的最右侧会出现一个箭头，指示数据网格是根据该列中的值进行排序的。箭头向上表示升序排序，向下表示降序排序。(当您不止一次单击某列时，箭头会以快速动画效果翻转。)

用户可以在单击时按住 Shift 键，根据多列进行排序。例如，如果按住 Shift 键并单击“类别”列，然后单击“价格”列，产品将按字母顺序排列成类别组，每个类别组中的项目将按价格排序。

对 DataGrid 排序过程进行一些控制是可能的，这取决于您愿意付出多少努力(以及您愿意忍受多少代码)。以下是您的选择:

*   *SortMemberPath 属性*:每一列都提供 sort member path 属性，该属性允许您在绑定数据对象中指定用于排序的属性。如果没有设置 SortMemberPath，则使用绑定数据对列进行排序，这是有意义的。但是，如果您有一个 DataGridTemplateColumn，则需要使用 SortMemberPath，因为没有绑定属性来提供绑定数据。否则，您的列将不支持排序。
*   PagedCollectionView 类:PagedCollectionView 包装了一个普通的集合，并为您提供了对其内容进行排序、过滤、分组和分页的附加功能。(在本章的后面，您将使用 PagedCollectionView 对数据网格进行分组和排序。)
*   *自定义模板*:如果你不喜欢指示排序顺序的箭头(或者你想添加 glitzier 动画)，你需要使用 DataGrid。ColumnHeaderStyle 属性应用新模板。它有三种关键状态:未排序状态(不应用排序时)、SortedAscending 状态(首次对列排序时)和 SortedDescending 状态(单击列标题两次，排序顺序颠倒)。定制这些插件以插入您自己的视觉效果。

还可以通过将 CanUserSortColumns 属性设置为 false 来禁用排序(或者通过设置列的 CanUserSort 属性来关闭特定列的排序)。

### 数据网格编辑

DataGrid 最大的便利之一是支持编辑。当用户双击数据网格单元格时，该单元格会切换到编辑模式。但是数据网格允许您以几种方式限制这种编辑能力:

*   *数据网格。IsReadOnly* :当该属性为 true 时，用户不能编辑任何内容。
*   *DataGridColumn。IsReadOnly* :当该属性为 true 时，用户不能编辑该列中的任何值。
*   *只读属性*:如果您的数据对象有一个没有属性设置器的属性，DataGrid 足够智能，可以注意到这个细节并禁用列编辑，就像您设置了 DataGridColumn 一样。IsReadOnly 为 true。同样，如果您的属性不是简单的文本、数字或日期类型，DataGrid 会将它设置为只读(尽管您可以通过切换到 DataGridTemplateColumn 来补救这种情况，如下所述)。

当单元格切换到编辑模式时会发生什么取决于列类型。DataGridTextColumn 显示一个文本框(尽管它是一个无缝的文本框，填充了整个单元格，没有可见的边框)。DataGridCheckBox 列显示一个可以选中或取消选中的复选框。但是 DataGridTemplateColumn 是迄今为止最有趣的。它允许您用一个更专业的输入控件来替换标准的编辑文本框，比如 DatePicker 或 ComboBox。

#### 用模板编辑

您已经看到了如何为 DataGridTemplateColumn 提供 CellTemplate。但是 DataGridTemplateColumn 支持两个模板。CellTemplate 决定了单元格在未被编辑时的外观。CellEditingTemplate 使用双向绑定表达式连接到适当的字段，指定应在编辑模式下显示的控件。这取决于您是否在两个模板中使用相同的控件。

例如，下面的列显示一个日期。当用户双击编辑该值时，它会变成一个下拉日期选择器(见[图 21-13](#fig_21_13) ),带有预先选择的当前值:

`<data:DataGridTemplateColumn Header="Date Added">
  <data:DataGridTemplateColumn.CellTemplate>
    <DataTemplate>
      <TextBlock Margin="4" Text=
  "{Binding DateAdded,Converter={StaticResource DateOnlyConverter}}"></TextBlock>
    </DataTemplate>
  </data:DataGridTemplateColumn.CellTemplate>` `  <data:DataGridTemplateColumn.CellEditingTemplate>
    <DataTemplate>
      <controls:DatePicker SelectedDate="{Binding DateAdded, Mode=TwoWay}">
      </controls:DatePicker>
    </DataTemplate>
  </data:DataGridTemplateColumn.CellEditingTemplate>
</data:DataGridTemplateColumn>` ![images](images/9781430234791_Fig21-13.jpg)

***图 21-13。**用日期选择器编辑日期*

您甚至可以使用模板列来提供数据输入选项的查找列表。例如，您可能希望将类别选择限制为预定义类别的列表。最简单的方法是在 CellEditingTemplate 中创建一个组合框。然后，绑定 ComboBox。产品的 SelectedItem 属性。CategoryName 使用双向绑定，并绑定 ComboBox。属性添加到包含允许值的集合中。在下面的示例中，这是产品公开的集合。CategoryChoices 属性:

`<data:DataGridTemplateColumn Header="Category">
  <data:DataGridTemplateColumn.CellTemplate>
    <DataTemplate>
      <TextBlock Margin="4" Text="{Binding CategoryName}"></TextBlock>
    </DataTemplate>
  </data:DataGridTemplateColumn.CellTemplate>

  <data:DataGridTemplateColumn.CellEditingTemplate>                        
    <DataTemplate>

**      <ComboBox Margin="4" ItemsSource="{Binding CategoryChoices}"**
**       SelectedItem="{Binding CategoryName, Mode=TwoWay}">**
      </ComboBox >
    </DataTemplate>
  </data:DataGridTemplateColumn.CellEditingTemplate>
</data:DataGridTemplateColumn>`

#### 验证和编辑事件

DataGrid 自动支持您在上一章中了解到的相同的基本验证系统，该系统对数据绑定系统中的问题(例如无法将提供的文本转换为适当的数据类型)或属性 setter 引发的异常做出反应。错误信息以红色弹出窗口的形式出现在违规列的旁边([图 21-14](#fig_21_14) )。

![images](images/9781430234791_Fig21-14.jpg)

***图 21-14。**出现属性设置异常*

DataGridTextColumn 自动使用支持验证的绑定表达式。但是，如果使用的是 DataGridTemplateColumn，则必须将 ValidatesOnExceptions 和 NotifyOnValidationError 属性添加到 CellEditingTemplate 中的绑定表达式中，如下所示:

`<data:DataGridTemplateColumn Header="Price">
  <data:DataGridTemplateColumn.CellTemplate>
    <DataTemplate>
      <TextBlock Margin="4"
       Text="{Binding UnitCost, StringFormat='C'}">
      </TextBlock>
    </DataTemplate>` `</data:DataGridTemplateColumn.CellTemplate>
  <data:DataGridTemplateColumn.CellEditingTemplate>
    <DataTemplate>` `      <TextBoxMargin="4"
       Text="{Binding UnitCost, Mode=TwoWay, ValidatesOnExceptions=true, NotifyOnValidationError=true}">
      </TextBox>
    </DataTemplate>
  </data:DataGridTemplateColumn.CellEditingTemplate>
</data:DataGridTemplateColumn>`

使用 DataGrid，您可以通过其他几种方式实现验证。一种选择是使用数据网格的编辑事件，这些事件在[表 21-4](#tab_21_4) 中列出。行的顺序与数据网格中事件的激发顺序相匹配。

![images](images/9781430234791_tab21-04.jpg)

如果您需要一个位置来执行特定于页面的验证逻辑(因此不能放入数据对象中)，可以编写响应 CellEditEnding 和 RowEditEnding 事件的自定义验证逻辑。检查 CellEditEnding 事件处理程序中的列规则，并验证 RowEditEnding 事件中整行的一致性。记住，如果你取消了一个编辑，你应该提供一个问题的解释(通常是在页面上其他地方的文本块中，尽管你也可以使用子窗口控件或消息框)。

最后，值得注意的是，DataGrid 支持数据注释的方式与您目前使用的普通输入控件不同。如果您的属性设置器使用验证器。ValidateProperty()方法检查无效值并抛出 ValidationException(如前所示)，DataGrid 以典型的方式响应，立即识别错误并在红色弹出窗口中显示错误消息。但是如果您不使用验证器，DataGrid *仍然*验证您设置的所有属性并验证整个对象。不同之处在于，在用户试图移动到另一行之前，它不会执行这种验证。此外，如果此时检测到验证错误，DataGrid 会以不同的方式处理它。它将用户返回到无效行，使其保持编辑模式，然后在 DataGrid 底部的阴影条中显示错误信息。[图 21-15](#fig_21_15) 显示了一个编辑违反了前面显示的 ProductValidation 类的自定义验证例程的例子。

![images](images/9781430234791_Fig21-15.jpg)

***图 21-15。**违反了一个数据注释*

这是另一种思考方式。当 CellEditEnding 事件触发时，将处理您在属性 setter 中引发的任何异常。并且当 RowEditEnding 事件触发时，DataGrid 会检查您应用但没有用代码显式强制的数据批注。

是否使用这种能力由你自己决定。如果您打算在普通控件和数据网格中执行编辑，您需要继续使用验证器。ValidateProperty()方法来防御无效数据。但是，如果您打算将 DataGrid 专门用于您的编辑需求，那么省略属性设置代码并让 DataGrid 执行验证可能是有意义的。请记住，以这种方式使用时，当您以编程方式设置值时，数据注释规则不会生效。(这也增加了出现特别奇怪的错误情况的可能性:如果 DataGrid 加载了无效数据，并且用户试图编辑该数据，则用户将被困在编辑模式中，直到值被更改。无法取消编辑，因为原始值无效。)

### 页面集合视图

数据网格还有一些需要 PagedCollectionView 支持的特性，这些特性可以在系统中找到。数据命名空间。PagedCollectionView 包装了一个集合，并为您提供了一种不同的查看方式。从概念上讲，PagedCollectionView 是数据的一个窗口，在数据出现在像 DataGrid 这样的绑定控件中之前，该窗口可以应用排序、筛选、分组和分页。

若要使用 PagedCollectionView，需要在代码中显式创建它。您将数据作为构造函数参数提供给源集合。然后，将 PagedCollectionView 绑定到适当的控件，而不是原始集合。

要在当前示例中实现这种方法，您需要更改以下代码，它会在 web 服务返回产品集合时做出反应:

`gridProducts.ItemsSource = e.Result;`

对此:

`PagedCollectionView view = new PagedCollectionView(e.Result);
gridProducts.ItemsSource = view;`

若要更改数据在绑定控件中的显示方式，请调整 PagedCollectionView 的设置。在下面几节中，您将看到使用最常修改的 PagedCollectionView 属性的示例。

#### 排序

您可以通过添加 SortDescription 对象(从系统。ComponentModel 命名空间)添加到 PagedCollectionView。SortDescriptions 集合。每个 SortDescription 对象基于单个属性应用单个级别的排序。SortDescription 对象是按照您添加它们的顺序应用的，这意味着下面的代码按类别对产品进行排序，然后从最低价格到最高价格对每个类别组进行排序:

`PagedCollectionView view = new PagedCollectionView(e.Result);

// Sort by category and price.
view.SortDescriptions.Add(
  new SortDescription("CategoryName", ListSortDirection.Ascending));
view.SortDescriptions.Add(
  new SortDescription("UnitCost", ListSortDirection.Ascending));

gridProducts.ItemsSource = view;`

这种方法与您在本章前面考虑的内置数据网格排序完美集成。数据网格在 PagedCollectionView 用于排序的任何列的标题中显示向上或向下排序箭头。如果用户单击列标题，旧的排序顺序将被放弃，行将被适当地重新排序。

#### 过滤

您可以使用 PagedCollectionView。设置过滤回调的 Filter 属性:测试每行是应该显示还是隐藏的例程。为了显示一行，回调返回 true。为了隐藏它，回调返回 false。

这里有一个例子，只显示了属于旅游类别的产品。

`PagedCollectionView view = new PagedCollectionView(e.Result);

// Show only travel items.
// The full list of products remains in the source collection, but the
// non-travel items are not visible through the PagedCollectionView.
view.Filter = delegate(object filterObject)
{
    Product product = (Product)filterObject;
    return (product.CategoryName == "Travel");
};

gridProducts.ItemsSource = view;`

#### 分组

DataGrid 还支持分组，这允许您将行组织到逻辑类别中。基本思想是选择一个属性用于分组(比如 CategoryName)。具有相同属性值的对象(例如，具有相同 CategoryName 的产品)被放入一个组中，该组可以在数据网格显示中折叠，如图[图 21-16](#fig_21_16) 所示。

![images](images/9781430234791_Fig21-16.jpg)

***图 21-16。**按类别名称分组的产品*

若要实现分组，请选择要分组的字段。然后添加一个 PropertyGroupDescription 对象(从系统。ComponentModel 命名空间)添加到 PagedCollectionView。GroupDescriptions 集合。下面是一个创建类别组的例子，如图[图 21-16](#fig_21_16) 所示:

`PagedCollectionView view = new PagedCollectionView(e.Result);
view.GroupDescriptions.Add(new PropertyGroupDescription("CategoryName"));
gridProducts.ItemsSource = view;`

如果要执行分组和子分组，可以添加多个 PropertyGroupDescription。以下代码按类别拆分产品，然后按产品状态进一步划分每个类别:

`PagedCollectionView view = new PagedCollectionView(e.Result);

view.GroupDescriptions.Add(new PropertyGroupDescription("CategoryName"));
view.GroupDescriptions.Add(new PropertyGroupDescription("Status"));` `gridProducts.ItemsSource = view;`

数据网格允许用户折叠和展开每个组。最初，所有组都是展开的。但是，DataGrid 使您能够通过其 ExpandRowGroup()和 CollapseRowGroup()方法以编程方式展开和折叠组。你所需要做的就是在 PagedCollectionView 中找到你想要的组。组集合。例如，以下代码折叠旅行组:

`foreach (CollectionViewGroup group in view.Groups)
{
    if (group.Name == "Travel")
      gridProducts.CollapseRowGroup(group, true);
}`

CollapseRowGroup()和 ExpandRowGroup()带两个参数:第一，要折叠或展开的组；第二，一个布尔值，它指示您是想要折叠还是展开其中的所有子组。

![images](images/square.jpg) **注意**理论上，PagedCollectionView 可以支持任何绑定的 ItemsControl，包括适度的 ListBox。这适用于排序、过滤和分页，但不适用于分组。对于分组，绑定控件需要一种方法来显示每个组的适当标题。目前，只有 DataGrid 具有这种能力。

标准的 PagedCollectionView 分组很简单，它通过精确匹配值来工作。在某些情况下，您可能希望创建更广泛的组，例如，您可能希望将名称以某个字母开头或价格在设定范围内的所有产品分组。为此，您需要使用 PropertyGroupDescription。转换器属性。这需要一个 IValueConverter(就像你在[第 20 章](20.html#ch20)中创建的那样)，它将源值改变成你想要用于分组的值。例如，要实现首字母分组，IValueConverter 只需从提供的字符串中提取首字母。

另一个挑战是改变每个组前面的标题的外观。DataGrid 的 RowGroupHeaderStyles 属性有所帮助，该属性允许您创建一个样式对象，该对象将其属性设置向下传递给组标题。下面是一个更改背景色和前景色的示例:

`<data:DataGrid.RowGroupHeaderStyles>
  <Style TargetType="data:DataGridRowGroupHeader">
    <Setter Property="Background" Value="#FF112255" />
    <Setter Property="Foreground" Value="#FFEEEEEE" />
  </Style>
</data:DataGrid.RowGroupHeaderStyles>`

![images](images/square.jpg) **注意**你的风格可以改变 DataGridRowGroupHeader 类的任何属性。但是更改文本有点麻烦——您需要为 DataGridRowGroupHeader 提供一个新的控件模板。模板属性。

RowGroupHeaderStyles 属性是一个集合，这意味着您可以提供任意数量的样式对象。这允许您对使用多个分组级别的数据网格中的标题应用自定义格式。如果您提供多个样式，第一个将应用于顶级组，第二个将应用于内部的子组，第三个将应用于子组中的子组，依此类推。

#### 分页

分页是 PagedCollectionView 将数据拆分成页面的能力，每个页面都有固定的行数。然后用户可以从一个页面浏览到另一个页面。当您有大量数据时，分页非常有用，因为它允许用户以更易于管理的块来查看数据。

PagedCollectionView 提供了两个配置分页的属性:

*   *PageSize* :这个属性设置一个页面上允许的最大记录数。默认情况下，它设置为 0，这意味着 PagedCollectionView 不使用分页，所有记录都保存在一起。
*   *PageIndex* :该属性表示用户当前页面，其中 0 为第一页，1 为第二页，以此类推。不能以编程方式设置 PageIndex 属性，但 PagedCollectionView 提供了几种更改页面的方法，包括 MoveToFirstPage()、MoveToLastPage()、MoveToPreviousPage()、MoveToNextPage()和 MoveToPage()。

如果您必须创建允许用户从一个页面移动到另一个页面的控件，分页会有点麻烦。幸运的是，Silverlight 有一个 DataPager 控件专门用于这项任务。您只需将 DataPager 添加到您的页面中(通常，您会将它放在 DataGrid 下)，设置一些属性来配置它的外观，然后将其连接到 PagedCollectionView。

下面是创建数据页面的标记，如图 21-7 所示:

`<data:DataPager Margin="5,0,5,5" Grid.Row="1" x:Name="pager"
  PageSize="5" DisplayMode="FirstLastPreviousNextNumeric"
  NumericButtonCount="3" IsTotalItemCountFixed="True"></data:DataPager>` ![images](images/9781430234791_Fig21-17.jpg)

***图 21-17。**使用数据分页器浏览分页数据*

要使 DataPager 可操作，您需要在创建视图后添加一行代码，它将 DataPager 连接到 PagedCollectionView:

`pager.Source = view;`

DataPager 是一个相当直观的控件。表 21-5 列出了它的主要特性。

![images](images/9781430234791_tab21-05.jpg)

![images](images/9781430234791_tab21-05a.jpg)

![images](images/9781430234791_Fig21-18.jpg)

***图 21-18。** PagerDisplayMode 选项*

### 树形视图

TreeView 控件允许您在可折叠的分层树中显示项目，就像 Windows 世界中常见的那种一样，出现在从 Windows 资源管理器文件浏览器到。NET 帮助库。

TreeView 的核心是一个专用的 its 控件，它承载 TreeViewItem 对象。诀窍在于每个 TreeViewItem 都是它自己独特的 ItemsControl，能够保存更多的 TreeViewItem 对象。这种灵活性允许您创建深度分层的数据显示。

#### 填充一个树形视图

下面是一个非常基本的 TreeView 的框架，它完全用标记声明:

`<controls:TreeView>
  <controls:TreeViewItem Header="Fruit">
    <controls:TreeViewItem Header="Orange"/>
    <controls:TreeViewItem Header="Banana"/>
    <controls:TreeViewItem Header="Grapefruit"/>
  </controls:TreeViewItem>
 <controls:TreeViewItem Header="Vegetables">
    <controls:TreeViewItem Header="Aubergine"/>
    <controls:TreeViewItem Header="Squash"/>
    <controls:TreeViewItem Header="Spinach"/>
  </controls:TreeViewItem>
</controls:TreeView>`

[图 21-19](#fig_21_19) 显示了结果。

![images](images/9781430234791_Fig21-19.jpg)

***图 21-19。**带有硬编码值的树形视图*

没有必要用 TreeViewItem 对象构造 TreeView。事实上，您可以向 TreeView 添加几乎任何元素，包括按钮、面板和图像。但是，如果您希望显示非文本内容，最好的方法是使用 TreeViewItem 包装器，并通过 TreeViewItem 提供您的内容。标题属性，如下所示:

`<controls:TreeViewItem>
  <controls:TreeViewItem.Header>
    <Button Content="There's a Button in this TreeView"></Button>
  </controls:TreeViewItem.Header>
</controls:TreeViewItem>`

这与将非 TreeViewItem 元素直接添加到 TreeView 中的效果相同，但可以访问丰富的 TreeViewItem 属性集，例如告诉您节点是被选中还是被折叠(is selected 和 IsExpanded)的属性，以及在发生时通知您的事件(被选中、未选中、展开和折叠)。

您还可以在 TreeViewItem 中显示普通的数据对象，如产品对象。这与你在第 20 章的列表框中显示数据对象的方式非常相似。只需使用 Header 属性提供数据对象，并使用 HeaderTemplate 属性提供格式化数据对象的数据模板。

#### 数据绑定的树形视图

通常，您不会用硬编码在标记中的固定信息填充树形视图。相反，您将以编程方式构造所需的 TreeViewItem 对象，或者使用数据绑定来显示对象集合。

用数据填充 TreeView 非常简单，与任何 ItemsControl 一样，只需设置 ItemsSource 属性。但是，这种技术只填充树视图的第一级。TreeView 的一个更有趣的用途是结合了具有某种嵌套结构的层次数据。

例如，考虑图 21-20 中[所示的树形视图。第一层由类别对象组成，而第二层显示属于每个类别的产品对象。](#fig_21_20)

![images](images/9781430234791_Fig21-20.jpg)

***图 21-20。**类别和产品的树形视图*

树形视图使分层数据显示变得容易。您只需要指定正确的数据模板。您的模板表明了不同级别的数据之间的关系。

例如，假设你想要构建如图 21-20 所示的例子。在[第 20 章](20.html#ch20)中，您看到了如何调用名为 GetCategoriesWithProducts()的 web 方法来检索 Category 对象的集合，每个对象包含一个 Product 对象的集合。对于这个例子，您可以使用相同的方法——您只需要将 Category 集合绑定到树，这样它就出现在第一层。下面是查询 web 服务并显示结果的页面代码:

`private void Page_Loaded(object sender, RoutedEventArgs e)
{
    StoreDbClient client = new StoreDbClient();    
**    client.GetCategoriesWithProductsCompleted +=**
**      client_GetCategoriesWithProductsCompleted;**
**    client.GetCategoriesWithProductsAsync();**` `    lblStatus.Text = "Contacting service ...";
}

private void client_GetCategoriesWithProductsCompleted(object sender,
  GetCategoriesWithProductsCompletedEventArgs e)
{
    try
    {
**        treeCategoriesProducts.ItemsSource = e.Result;**
        lblStatus.Text = "Received results from web service.";
    }
    catch (Exception err)
    {
        lblStatus.Text = "An error occured: " + err.Message;
    }
}`

要显示类别，您需要提供一个树形视图。可以处理绑定对象的 ItemTemplate。在本例中，您需要以粗体显示每个 Category 对象的 CategoryName 属性。下面是实现这一点的数据模板，它是用户控件中的一个资源。资源集合:

`<UserControl.Resources>
  <common:HierarchicalDataTemplate x:Key="CategoryTemplate">
    <TextBlock Text="{Binding CategoryName}" FontWeight="Bold" />
  </common:HierarchicalDataTemplate>
</UserControl.Resources>`

这里唯一不同寻常的细节是。ItemTemplate 是使用 HierarchicalDataTemplate 对象而不是 DataTemplate 设置的。HierarchicalDataTemplate 还有一个额外的优点，即它可以包装第二个模板。HierarchicalDataTemplate 然后可以从第一级提取一个项目集合，并将其提供给第二级模板。您只需设置 ItemsSource 属性来标识具有子项的属性(在本例中，它是类别。Products 集合)，并设置 ItemTemplate 属性来指示每个对象的格式。在此示例中，子产品对象使用第二个 HierarchicalDataTemplate 进行格式化，该模板仅用斜体显示 ModelName。下面是两个模板:

`<UserControl.Resources>
  <common:HierarchicalDataTemplate x:Key="CategoryTemplate"
   ItemsSource="{Binding Products}" ItemTemplate="{StaticResource ProductTemplate}">
    <TextBlock Text="{Binding CategoryName}" FontWeight="Bold" />
  </common:HierarchicalDataTemplate>

  <common:HierarchicalDataTemplate x:Key="ProductTemplate">
    <TextBlock FontStyle="Italic" Text="{Binding ModelName}" />
  </common:HierarchicalDataTemplate>
</UserControl.Resources>`

实际上，您现在有两个模板，树的每一层都有一个。第二个模板使用从第一个模板中选择的项目作为其数据源。

最后，这里是 TreeView，它指定根级项目(类别)应该用 CategoryTemplate 格式化:

`<controls:TreeView x:Name="treeCategories" Margin="5"` `  ItemTemplate="{StaticResource CategoryTemplate}">
</controls:TreeView>`

这就是你需要得到的类别和产品树，如图 21-20 所示。

### 数据透视查看器

现在，您已经考虑了与 Silverlight 应用程序一起工作的各种数据控件。所有这些控件共有的一个细节是它们的灵活性。使用列表、网格、表单和树的组合，您几乎可以构建任何类型的用户界面。

PivotViewer 是一种完全不同的数据控件。它是围绕特定的场景(数据可视化和分析)设计的，并配备了许多高级功能。PivotViewer 的优点是您可以获得一个只需要很少代码的完美界面。缺点是您的定制选项更加有限。如果 PivotViewer 不能完全满足您的需要，您可能无法对其进行修改或扩展以适应您的项目。

PivotViewer 的核心是一个用于剖析大型数据集合(通常是包含数百或数千个项目的集合)的工具。PivotViewer 提供了过滤选项，让用户可以专注于他们感兴趣的数据子集。例如，使用 PivotViewer，您可以获取二手物品的目录，并在家居装饰部分找到所有绿色的物品。或者，您可以查看销售信息数据库，找出哪些客户城市对高价产品下了最多订单。

到目前为止，这些场景听起来并不具有革命性。毕竟，Silverlight 已经有了几种过滤数据的方法，包括 LINQ 查询(第 20 章)和 PagedCollectionView(在上一节中描述)。但是有两个特征使 PivotViewer 与众不同:

> *旋转*:旋转是从一组过滤设置切换到另一组过滤设置的动作。这是你退后一步，以不同的方式看待同样的数据的时刻——可能会发现新的见解。(如果您曾经在 Microsoft Excel 中使用过数据透视表，那么您应该已经熟悉了这个概念。)数据透视查看器旨在简化这一发现过程。它允许用户轻松地组合和更改过滤设置，从而从一个有利位置“旋转”到另一个有利位置。最重要的是，您不需要编写任何代码来管理过滤过程。
> 
> *图像和视觉风格*:尽管这不是绝对必要的，但几乎每个 PivotViewer 示例都使用某种图像来表示集合中的每个项目。然后，这些图像被拼接成一个可缩放、可滚动的高分辨率表面。这种视觉感受是 PivotViewer 工作方式的一个关键部分，您需要通过一个示例来真正感受它。在最好的情况下，PivotViewer 对图像的强调有助于用户理解和连接底层数据。由于 PivotViewer 在幕后使用 DeepZoom 技术(第 12 章)，您可以使用大量高分辨率图片，而不会显著降低性能。

理解 PivotViewer 目录中的图片可以是任何东西是很重要的。根据您的数据，图片可能是实物(比如，古董店中物品的照片)、人物(公司员工的照片)，甚至是文档(已发表文章的首页图片)。用户从顶层开始，过滤掉大量的数据，并可以逐渐放大特定的项目，以查看其细节并近距离观看相应的图像。

要了解这在实践中是如何工作的，您需要一个例子。Web 上有许多实时的 PivotViewer 演示，包括浏览网飞电影、棒球卡、MSDN 文章等的应用程序。这些示例中的大多数是使用旧版本的 PivotViewer 构建的，该版本与 Silverlight 控件工具包捆绑在一起，并与 Silverlight 4 一起使用。

下图显示了您接下来要研究的更简单的例子。它从你在本章中使用的熟悉的产品集合开始([图 21-21](#fig_21_21) )。与许多普通的数据绑定控件一样，数据透视查看器的初始显示是用数据模板创建的。在这里，示例结合了一个边框、一些绑定数据和一张图片。产品被平铺以适应可用空间，如果有更多的空间，PivotViewer 会放大它们，如果空间更有限，它会缩小它们。

![images](images/9781430234791_Fig21-21.jpg)

***图 21-21。**数据透视查看器中的初始产品集合*

![images](images/square.jpg) **注意**pivot viewer 显示界面的行为就像你在[第 12 章](12.html#ch12)中学到的 DeepZoom 图像一样。您可以使用滑块(在右上角)或鼠标滚轮来放大，放大图片以显示细节。你也可以将平铺的表面拉到一边，它会漂移一小段距离，利用一种微妙的惯性效应。

现在，您可以使用过滤器窗格(在左侧)来提取特定的数据子集。正如您将看到的，筛选条件是特定于数据类型的，它们可以组合应用来显示您想要的或多或少的项目。在[图 21-22](#fig_21_22) 中，集合被过滤以显示两类项目。

![images](images/9781430234791_Fig21-22.jpg)

***图 21-22。**过滤产品*

图 21-22 所不能展示的是数据透视查看器流畅的动画效果。当您应用过滤设置时，不需要的项目会飞离显示表面，而其他项目会重新排列并调整大小以适合显示表面。其效果类似于[第 14 章](14.html#ch14)中描述的 FluidMoveBehavior，但更加惊人。动画还有一个实用的目的，通过给用户一个在给定子集中包含和排除的项目数量的总体“感觉”。

最后，点击单个项目会弹出一个详细信息窗格(在右边)，显示所选项目的完整数据([图 21-23](#fig_21_23) )。

![images](images/9781430234791_Fig21-23.jpg)

***图 21-23。**查看单个产品*

该视图还提供了“旋转”显示的变化。只需单击其中一个数据项即可更改匹配的过滤设置。例如，如果您单击类别名称(在当前示例中是“Communications”)，PivotViewer 将显示“communications”类别中的所有产品，同样带有漂亮的动画效果，使新项目飞入显示面。

在接下来的部分中，您将构建这个简单的 PivotViewer 显示。在这个过程中，您将了解到 PivotViewer 的一些细节，包括文本搜索、基于数字和日期的筛选、图表显示和项目选择。

#### 定义数据透视查看器

在使用数据透视查看器之前，需要添加对 System.Windows.Controls.Pivot.dll 程序集的引用。然后，您可以将前缀映射到相应的名称空间:

`<UserControl x:Class="DataControls.PivotViewerTest"  xmlns:pv=
"clr-namespace:System.Windows.Controls.Pivot;assembly=System.Windows.Controls.Pivot" ... >`

准备就绪后，您就可以将 PivotViewer 添加到页面中了:

`<pv:PivotViewer x:Name="pivotViewer">
</pv:PivotViewer>`

##### 数据模板

要定义 PivotViewer 为每个项目显示的内容，您需要一个数据模板。从技术上讲，您不会使用 DataTemplate 类，而是使用 PivotViewerItemTemplate 类。PivotViewerItemTemplate 从 DataTemplate 派生，只添加一个属性 MaxWidth。虽然不需要设置 MaxWidth 属性，但可以用它来设置数据项的缩放大小的上限。这可以防止用户过于靠近低分辨率图像进行放大。

下面是数据透视查看器及其数据模板。该模板可能看起来很熟悉，因为它实际上与您在第 20 章中用于在列表框中显示产品图像的模板相同。

`<pv:PivotViewer x:Name="pivotViewer">
  <pv:PivotViewer.ItemTemplates>                
    <pv:PivotViewerItemTemplate>
      <Border Margin="5" BorderThickness="1" BorderBrush="SteelBlue" Width="125"
       CornerRadius="4">
        <Grid Margin="3">
          <Grid.RowDefinitions>
            <RowDefinition></RowDefinition>
            <RowDefinition></RowDefinition>
            <RowDefinition></RowDefinition>
          </Grid.RowDefinitions>
          <TextBlock FontWeight="Bold"
           Text="{Binding Path=ModelNumber}"></TextBlock>
          <TextBlock Grid.Row="1" Text="{Binding Path=ModelName}"></TextBlock>
          <Image MinHeight="100" Grid.Row="2" Grid.RowSpan="2" Source=
"{Binding Path=ProductImagePath, Converter={StaticResource ImagePathConverter}}">
          </Image>
        </Grid>
      </Border>
    </pv:PivotViewerItemTemplate>
  </pv:PivotViewer.ItemTemplates>
</pv:PivotViewer>`

##### 透视属性

有了模板，PivotViewer 现在能够将其数据集合显示为一组动画图块。但是，如果要使用 PivotViewer 的筛选器窗格和详细信息窗格，则需要添加一些附加信息。

你需要的是枢纽*属性*。每个属性都映射到数据项中的一个字段。属性告诉 PivotViewer 如何使用这些信息。如果您没有为数据对象中的给定字段添加透视属性，则 PivotViewer 会忽略该字段。

若要定义透视属性，请填充 PivotViewer。数据透视属性集合。例如，如果您想要映射一个普通的字符串(如类别名称)，您可以添加一个 PivotViewerStringProperty，如下所示:

`<pv:PivotViewer x:Name="pivotViewer" ItemDoubleClick="pivotViewer_ItemDoubleClick">
  <pv:PivotViewer.PivotProperties>
    <pv:PivotViewerStringProperty Id="CategoryName" DisplayName="Category"
     Binding="{Binding CategoryName}" />
  </pv:PivotViewer.PivotProperties>
  ...` `</pv:PivotViewer>`

您需要为每个 pivot 属性提供三个关键细节:唯一的 Id(通常与字段名相同)、DisplayName(设置在 PivotViewer 中为该字段显示的文本)和 Binding(从相应的绑定字段中提取信息)。只要您提供这三个细节，当用户选择项目时，该字段将出现在细节窗格中(如图[图 21-23](#fig_21_23) 所示)。但是，该字段不会用于过滤。为此，您需要添加 Options 属性:

`<pv:PivotViewerStringProperty Id="CategoryName" DisplayName="Category"
 Binding="{Binding CategoryName}" Options="CanFilter" />`

CanFilter 选项告诉 PivotViewer 将该字段添加到左侧的筛选器窗格中，并填写图 21-21 中的复选框。Options 属性还支持一些值，包括 Private(在详细信息窗格中隐藏该属性)、WrappingText(允许值换行)和 CanSearchText(允许您使用文本搜索框查找并应用筛选值)。如有必要，您可以使用逗号来组合多个值:

`<pv:PivotViewerStringProperty Id="ModelName" DisplayName="Category"
 Binding="{Binding CategoryName}" Options="CanFilter,CanSearchText" />`

[图 21-24](#fig_21_24) 显示了正在运行的文本搜索。如果您有一个很长的值列表，并且您不想强迫用户滚动查找他们想要的值，那么这种技术就很有用。

![images](images/9781430234791_Fig21-24.jpg)

***图 21-24。**用搜索框查找过滤值*

PivotViewer 还支持对数字数据类型和日期的专门过滤([图 21-25](#fig_21_25) )。要过滤数字数据，您可以拖动条来设置您想要考虑的最小和最大范围。要过滤日期，您可以使用日期选择器下拉列表。要获得这种高级筛选，您需要使用 PivotVieweverNumericProperty 或 PivotViewerDateTimeProperty:

`<pv:PivotViewerNumericProperty Id="UnitCost" DisplayName="Cost"
 Binding="{Binding UnitCost}" Format="C" Options="CanFilter" />
<pv:PivotViewerDateTimeProperty Id="DateProperty" DisplayName="Date Added"
 Binding="{Binding DateAdded}" Options="CanFilter"  />` ![images](images/9781430234791_Fig21-25.jpg)

***图 21-25。**过滤数字和日期*

以下是透视属性的完整列表:

`<pv:PivotViewer x:Name="pivotViewer" ItemDoubleClick="pivotViewer_ItemDoubleClick">
  <pv:PivotViewer.PivotProperties>
    <pv:PivotViewerStringProperty Id="CategoryName" DisplayName="Category"
     Binding="{Binding CategoryName}" Options="CanFilter" />
    <pv:PivotViewerStringProperty Id="ModelNumber" DisplayName="Model Number"
     Binding="{Binding ModelNumber}" Options="CanSearchText" />
    <pv:PivotViewerStringProperty Id="ModelName" DisplayName="Model Name"
     Binding="{Binding ModelName}" Options="CanFilter" />
    <pv:PivotViewerNumericProperty Id="UnitCost" DisplayName="Cost"
     Binding="{Binding UnitCost}" Format="C" Options="CanFilter" />
    <pv:PivotViewerDateTimeProperty Id="DateProperty" DisplayName="Date Added"
     Binding="{Binding DateAdded}" Options="CanFilter"  />
    <pv:PivotViewerStringProperty Id="Description" DisplayName="Description"
     Binding="{Binding Description}"  />
    </pv:PivotViewer.PivotProperties>
  ...
</pv:PivotViewer>`

#### 导航数据透视查看器

如果您已经设置了数据模板和透视属性，则可以像处理任何其他数据绑定控件一样加载集合:通过为 ItemsSource 属性提供集合。

您现在可以浏览收藏、应用过滤器设置和选择项目。PivotViewer 触发标准的 SelectionChanged 事件，让您知道用户何时选择了要关注的特定项目，以及一个新的 ItemDoubleClick 事件，该事件在用户双击某个项目时发出信号(此时您可能希望启动另一个任务):

`private void pivotViewer_ItemDoubleClick(object sender,
System.Windows.Controls.Pivot.PivotViewerItemDoubleClickEventArgs e)
{
    Product product = ((Product)e.Item);
    MessageBox.Show("You clicked " + product.ModelName + ".");
}`

您还可以通过关注 FilterChanged、SortPivotPropertyChanged 和 ViewChanged 等事件来对 PivotViewer 中发生的更改做出反应。

PivotViewer 提供的另一个漂亮的效果是类似图表的条形图显示。您可以通过点击 PivotViewer 控件右上角的小条形图图标从平铺视图切换到图表视图([图 21-26](#fig_21_26) )。然后，您可以专注于特定的数据栏(只需单击它)，或者使用不同的 pivot 属性(使用排序列表)来拆分图表。与往常一样，您所做的任何筛选更改都伴随着 PivotViewer 流畅的视觉转换。

![images](images/9781430234791_Fig21-26.jpg)

***图 21-26。**将你的数据拆分成列*

**深入数据透视查看器**

您还可以自定义 PivotViewer。其中一些很简单(例如，您可以调整 PivotViewer 属性来更改其整体配色方案)。其中大部分都比较困难(例如，使用新的控件模板更改“过滤器”窗格或“细节”窗格，或者使用 PivotViewerMultiScaleSubImageHost 在模板中承载具有 DeepZoom 性能的高分辨率图像)。网上有大量的 PivotViewer 信息，但在撰写本文时，其中大部分是为 PivotViewer 的第一个版本编写的，该版本是与 Silverlight 控件工具包一起发布的，使用了不同的数据模型。

在不久的将来，微软的 PivotViewer 站点(`[www.microsoft.com/silverlight/pivotviewer](http://www.microsoft.com/silverlight/pivotviewer)`)将针对 PivotViewer 的 Silverlight 5 版本进行更新。这些网页包含了大量有用的信息和例子，但是对于宣传视频要有所保留。在很大程度上，他们认为 PivotViewer 将成为从文档搜索(忽略生成文档图像的高成本)到基因组学研究(忽略 PivotViewer 缺乏严肃的数据分析能力)的开创性工具。尽管 PivotViewer 控件很酷，但它的数据可视化技巧只是很方便，而不是革命性的。

### 最后一句话

在本章中，您深入研究了数据绑定，这是 Silverlight 的关键支柱之一。您了解了如何构建需要较少代码的智能数据表单，以及如何从属性中提取所需的信息。在这个过程中，您掌握了 Label、DescriptionViewer 和 ValidationSummary 控件，并且学习了如何使用新的数据注释模型实现验证。

本章的大部分时间都花在了探索 Silverlight 丰富的数据控件上，尤其是非常灵活的 DataGrid，它对格式和编辑提供了细粒度的支持。您了解了如何使用 PagedCollectionView 实现高级过滤、分组和分页。最后，您看了一下 TreeView，它允许您绑定数据对象的嵌套层，而不需要额外的代码。

这将把您带到数据绑定旅程的终点。在下一章，你将从一个新的主题开始，学习如何在本地计算机上用独立存储存储数据。